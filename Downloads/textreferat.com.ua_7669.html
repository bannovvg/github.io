<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

<head>

    <meta http-equiv="Content-Type" content="text/html; charset=windows-1251">

    <meta name="description" content="Реферати, курсові, дипломи - referatbank.com.ua">

    <meta name="keywords" content="Реферати, курсові, дипломи - referatbank.com.ua">

     <title>Реферати, курсові, дипломи - referatbank.com.ua</title>
                                                                  <style type="text/css">
     body{font-family: Verdana, Arial; font-size: 10pt; color: #000000;}
     
     </style>

 </head>



<body marginheight="0" marginwidth="0" leftmargin="0" rightmargin="0" topmargin="0" bgcolor="#FFFFFF">
<table border="0" width="640" cellpadding="20" cellspacing="1" style="border: 1px dashed #585858;" align=center><tr><td>
 <center><img src="http://textreferat.com.ua/i/c/logo.gif" border=0><br><br>Реферат на тему <b>Assembler</b><br>
 
 </center>
<p>Після створення процесора 8086 фірма Intel розробила більш досконалі процесори об’єднані під назвою I 80x86, така назва означає, що всі команди мікропроцесора, які виконуються на молодших моделях обов’язково виконуються на старше, отже все ПЗ, які розроблені для процесора 8086 успішно будуть працювати і на останніх моделях 80486 і Pentium. Ми будемо розглядати процесори з точки зору програміста. Не дивлячись на різноманітність моделей процесорів, найбільш важливим з точки зору біології програмування є 8086 як базова модель і 80386 , як перший процесор фірми Intel, який в повному об’ємі реалізував принцип багатозадачності. 
<p><b>Програмування на мові асемблера</b> 
<p>Програмування на мові асемблера вважається складною задачею, причини цього такі: 
<p>1. Мова асемблера будь-якого процесора суттєво складніша будь-якої мови високого рівня. Щоб скористатись всіма можливостями мови асемблера, треба по крайній мірі знати команди мікропроцесора, а їх число з усіма можливими варіантами переважає 100, їх кількість значно перевищує кількість операторів і ключових слів інших мов високого рівня. Проблема ускладнюється ще тим, що зміни в асемблері виникають набагато швидше ніж в мовах високого рівня, це зв’язано з появою нових мікропроцесорів і відповідно нових команд. 
<p>2. Програміст, який використовує мови асемблера повинен сам слідкувати за розподілом пам’яті та вмістом регістрів, щоб коректно розподіляти і оперувати пам’яттю, в мовах високого рівня це робиться автоматично при допомозі компілятора, але ця обставина має перевагу: можна оптимально розташувати дані в пам’яті, забезпечити максимальну швидкість виконання та мінімальну довжину програми. 
<p>3. Програми на мові асемблера важче проектувати та підлагоджувати, треба весь час пам’ятати, що конкретно знаходиться в кожному регістрів в даній комірці пам’яті. Прийнято вважати, що розробка програми тільки на мові асемблера, деякого процесора, навіть якщо він поширений не рекомендується. Зрозуміло, що будь-яку програму можна написати тільки з допомогою асемблера, але для цього треба використати набагато більшу кількість команд і час який піде на її виконання і відладку буде набагато більший ніж для мови високого рівня. Набагато вигідніше писати програми на мові високого рівня, а найбільш критичні частини на швидкодії писати на мові асемблера. Наприклад на асемблері можна скласти процедури для реалізації вводу-виводу низького рівня, процедури обробки переривань та деякі інші. <p align="center"><b>Етапи створення програми.</b> 
<p>Розробка програми на мові асемблера включає кілька етапів. 
<p>1) Підготовка початкового тексту програми; 
<p>2) Асемблювання програми(отримання об’єктного коду); 
<p>3) Компоновка програми(отримання виконуваного файлу); 
<p>4) Відладка програми(знаходження помилок). 
<p>Ці етапи циклічно повторюються. 
<p><b>Підготовка лістінгу програми.</b> 
<p>Текст програми на мові асемблера записується в один або кілька файлів, імена файлів і їх розширення можуть бути будь-які, прийнято для файлів які містять програми мовою асемблера прийнято використовувати розширення *.asm. Для файлів визначених констант і повних типів розширення *.inc. Ці файли є текстовими їх можна набрати в будь-якому текстовому редакторі. Можна також використати інтегровані середовища для розробки програм, при програмуванні зручно виділяти один каталог для збереження всіх файлів програми і звідти запускати всі необхідні програми для підготовки, асемблювання та компонування програми. При використанні стандартних редакторів тексту, редаговані тексти треба зберігати у вигляді звичайних файлів у форматі ASCII, це означає, що ці файли треба зберігати без додаткових символів, ці символи часто вставляють в текст різні спеціалізовані редактори, наприклад WORD. <p align="center"><b>Асемблювання програми.</b> 
<p>Підготовлений текст мови асемблер є початковим для спеціальних програм, які називаються асемблерами, далі <b>програма асемблера</b>. Задача програми асемблера перетворити текст програми у форму двійкових команд, останні можуть вже бути виконанні мікропроцесором. Після асемблювання дістають так звані файли об’єктних модулів, які мають відповідні розширення *.obj. Для отримання об’єктних файлів необхідного виконати відповідну програму асемблера masm фірми Microsoft, або tasm фірми Borland. В обох випадках після команди вказується ім’я файлу : <b>masm prog1.asm</b>, <b>tasm prog1.asm</b>. 
<p>Така форма команди є мінімальною, крім цієї форми можна використовувати іншу форму задаючи перед іменем файлу опції або ключі. Якщо програма складається з декількох файлів, то їх асемблювання проводиться незалежно один від одного, хоча отримані об’єктні файли представлені вже в двійковій формі запускати їх на виконання не можливо. <p align="center"><b>Компоновка програми.</b> 
<p>Текст програми може знаходитись в декількох файлах, змінні які описані в цих файлах можуть використовуватися спільно, якщо такі файли асемблюються окремо, то не можливо дістати повну інформацію, для того, щоб генерувати виконавчий код. Тому процес підготовки програми обов’язково включає в себе етап компоновки. На цьому етапі визначають всі невідомі, при окремому асемблювані, адреси всіх змінних або функцій, які використовуються спільно. Процес об’єднання об’єктних модулів в один файл виконується спец. програмою, яка називається компоновщиком. Це може бути програма link фірми Microsoft, або tlink фірми Borland, отримуваний виконуваний файл має розширення *.exe, або *.com. Компановщику треба передати імена відповідних об’єктних файлів. 
<p><b>Link prog1.obj prog2.obj</b> 
<p><b>Tlink prog1.obj prog2.obj</b> 
<p>Після компонування отримується виконуваний файл, він отримує ім’я файла, який стоїть перший у відповідній команді.<b>Відладка програми.</b> 
<p>За винятком початкових простих програм практично всі програми на мові асемблера мають потребу в відладці. Для відладки можна використовувати різні відладчики, наприклад <b>tg386-Turbo Debuger</b> фірми Borland. Сучасні відладчики дозволяють в процесі відладки контролювати значення регістрів загального призначення, а також значення змінних і змінювати їх в процесі відладки, можна переглядати зміст різних ділянок пам’яті, можна контролювати виконання покроково, або розставляти точки зупинки.<b>Використання інтегрованих середовищ (ІС).</b> 
<p>Дуже зручно користуватись для підготовки тексту програми редакторами ІС, такі можливості передбачають практично всі виробники сучасних асемблерів. ІС мають суттєву перевагу, так як дають доступ до довідкової інформації. Вони дозволяють також зразу асемблювати та компонувати набрані тексти і провести його відладку. Потім знову можна повернутись до його редагування, при цьому складається ілюзія роботи з однією програмою. Слід відмітити, що відладчики вбудовані в ІС мають дещо обмежені можливості. <p align="center"><b>Основні відомості та правила для написання програм на асемблері.</b> 
<p>Всі данні в мікропроцесорі представляються у вигляді набору бітів певної довжини, тільки окремі команди мікропроцесора розглядають вміст регістру або комірки пам’яті в певному форматі. В переважній більшості випадків сам програміст вирішує як розглядати певний набір бітів: як код клавіш, як число без знаку чи зі знаком, або як двійково-десяткове число. Всі числа які представляють певні данні розглядаються в позиційній системі числення. При представленні чисел команді мікропроцесора використовується двійкова система числення. Щоб спростити процес програмування мова асемблера дає можливість данні записувати так, як це зручно програмісту, при цьому можна записувати данні в різних системах числення. Можна навіть замість числа записувати вирази, процес перетворення цих чисел у двійковий вигляд буде виконувати програма асемблера. При записі двійкових чисел використовують суфікс <b>В</b> або <b>в: 11011111В, 11010101в.</b> 
<p>При записі чисел в 16-вій системі числення треба враховувати, що для чисел 10-15ами. 
<p>За винятком пбукви латинського алфавіту. Щоб відрізнити 16-ві числа дописується суфікс <b>Н</b> або <b>h, </b>крім того перш0пбуква в записі шістнадцяткового числа повинн0пбути арабською цифрою. Тобто для написання числа c5h не достатньо суфікса h, треба обов’язково поставити спершу 0:0C5h. За умовчанням використовується десяткове CЧ. При допомозі директиви <b>radix </b>можна міняти CЧ.Двійкові числа.Для великої кількості команд допускається, що інформація представлена в двійкових кодах, довжина цих двійкових чисел може бути різною. Мікропроцесори сімейства І 80х86 підтримують дані таких розмірностей: 
<p align="center">
 <p>1. Байти; 
<p>2. Слова; 
<p>3. Подвійні слова; 
<p>4. Рядки. 
<p>Крім того до специфічних даних можна віднести адрес переходів. Байт – це мінімальна к-сть інформації при роботі мікропроцесора, складається із 8 біт. Вся пам’ять мікропроцесора може розглядатись як велика к-сть байтів. <p align="center">210б=1Кб 220б=1Мб 230б=1Гб 240б=1Тб 
<p>Так як байт складається з 8 біт, кожен біт може перебувати в двох станах, то байт може перебувати в 256-тьох станах. Крім представлення чисел байт використовується для збереження символьних кодів, наприклад це може бути символ, що набирається з клавіатури. 256 різних значень байта дозволяють описати з допомогою ASCII не тільки десяткові числа, а й весь англійський алфавіт, а також знаки пунктуації, спеціальні знаки, управляючі символи, символи національних алфавітів. Слово може містити 216=65536 різних станів, а це є 64 Кб. Слово це найбільш зручний спосіб збереження інформації в даному сімействі мікропроцесорів, адже їх внутрішні регістри як мінімум 16-ти розрядні. У всіх мікропроцесорів фірми Intel правило запису багатобайтних чисел таке: молодший байт знаходиться за молодшою адресою в пам’яті, старший за старшою адресою. Адреса деякої ділянки пам’яті яка розглядається як слова рівна адресі молодшого байту. Наприклад, якщо за адресою N записано слово 1539H, то це означає, що за адресою N записаний байт 39H, а за адресою N+1 – 15Н. Важливим є число 65536, для процесорів 80х86 це число визначає максимальну довжину сегменту, тобто області пам’яті, яка містить код або данні програми, тому за допомогою таких чисел до 65536 можна адресувати комірки пам’яті всередині даного сегменту, така адресація, коли використовується зміщення всередині сегменту називається <b>ближньою – Near</b>. Подвійні слова рівні 4 байт, або 32 біт. Одне слово може мати 4294967296=4Мб. Подвійні слова зберігаються в пам’яті за цим же правилом: молодший байт за молодшою адресою, байти в пам’яті розташинятком ппослідовно один за одним 12554959Н – слово подвійне, якщо воно знаходиться за адресою N, то за адресою N знаходиться байт 59Н, N+1 – 49H, N+2 – 55H, N+3 – 12H. Подвійне слово при програмуванні для процесорів молодших 80386 має достатньо місця для збереження не тільки адреси всередині сегменту, а й адреси початку сегменту і адреси зміщення в середині сегменту називається <b>дальньою – for adress </b>адресою. При програмуванні , коли для завдання адреси використовується 32 біти (для мікропроцесорів 80386 і старше) в подвійному слові кожна зберігати 32-розрядне зміщення. За допомогою цього зміщення можна звертатись до будь-якої комірки пам’яті. Рядки в мікропроцесорах родини І 80х86 можна виконувати операції над рядками. Рядок – це послідовність байтів або слів, а для мікропроцесорів старших 80386 подвійних слів, які знаходяться в пам’яті комп’ткера. Мінімальна довжина рядку 1 елемент, максимальна довжина рядку може досягати 64 Кб для мікропроцесорів молодших 80386, і 4Гб для мікропроцесорів старших 80386. <p align="center"><b>Представлення чисел зі знаком.</b> 
<p>Мікропроцесори даної родини підтримають обробку чисел зі знаком, для чисел, які мають розмірність байт, слово, подвійне слово. Для представлення знаку використовують самий старший розряд числа 0 – “+”, 1 – “-“. В зв’язку з цим діапазон представлення чисел звужується. Наприклад для байтів зі знаком мінім. число : -128, макс. число : 127. Відповідно слово зі знаком : -32768 і 32768, подвійне слово : -2147483648 і 2147483647. 
<p>Від’ємні числа зберігаються в додатковому коді. Використання двійквого коду має переваги: можна виконувати арифметичні операції не знаючи як представлені операнди: зі знаком чи без знаку. Це означає, що сам програміст вирішує як інтерпретувати результат зі знаком чи без. <b>Двійково-десяткові числа.</b>Мікропроцесори даної родини дозволяють працювати з так званими двійково-десятковими числами, вони представляють собою числа від 0 до 9 записані в двійковому вигляді, для їх запису використовується 4 біти. На відміну від просто двійкових чисел тут не ми. 
<p>За винятком птетради, які відповідають числам a – f 16-вої СЧ. Мікропроцесори цьої родини підтримують роботу з двома форматами двійково-десяткових чисел: унакованими і неунакованими двійково-десятковими числами. 
<p>Вони займають 1б – 2птетради. </p><table border=0 cellspacing="0" cellpadding="0" align="center"> <tr> <td width=25 valign=top > 
<p>0 </td> <td width=25 valign=top > 
<p>0 </td> <td width=25 valign=top > 
<p>0 </td> <td width=25 valign=top > 
<p>0 </td> <td width=25 valign=top > 
<p>0 </td> <td width=25 valign=top > 
<p>0 </td> <td width=25 valign=top > 
<p>0 </td> <td width=25 valign=top > 
<p>0 </td> </tr> </table> 
<p><img width=203 height=12 src="http://referatbank.com.ua/images/76882_image001.gif"> 
<p> 0 0 
<p>отже при допомозі однобайтного двійково-десяткового числа можна записати десяткові числа 0 – 99. </p><table border=0 cellspacing="0" cellpadding="0" align="center"> <tr> <td width=25 valign=top > 
<p>1 </td> <td width=25 valign=top > 
<p>0 </td> <td width=25 valign=top > 
<p>0 </td> <td width=25 valign=top > 
<p>1 </td> <td width=25 valign=top > 
<p>1 </td> <td width=25 valign=top > 
<p>0 </td> <td width=25 valign=top > 
<p>0 </td> <td width=25 valign=top > 
<p>1 </td> </tr> </table> 
<p><img width=202 height=13 src="http://referatbank.com.ua/images/76882_image002.gif"> 
<p> 9 9 
<p>При необхідності працювати з більшими числами необхідно використовувати кілька байт. Зауважимо, що не має стандартної форми запису для від’ємного представлення таких чисел: старший біт тут не можна використовувати як знаковий. Програміст сам повинен турбуватися про збереження інформації про знак числа і самостійно обробляти знак при виконанні арифметичних дій. МП для такої обробки не мають відповідних команд. <p align="center"><b>Неунаковані двійково-десяткові числа.</b> 
<p>Як і унаковані вони займають 1б, але в цьому байті записується тільки одна десяткова цифра, ця цифра записується в молодшій тетраді: </p><table border=0 cellspacing="0" cellpadding="0" align="center"> <tr> <td width=25 valign=top > 
&nbsp;</td> <td width=25 valign=top > 
&nbsp;</td> <td width=25 valign=top > 
&nbsp;</td> <td width=25 valign=top > 
&nbsp;</td> <td width=25 valign=top > 
&nbsp;</td> <td width=25 valign=top > 
&nbsp;</td> <td width=25 valign=top > 
&nbsp;</td> <td width=25 valign=top > 
&nbsp;</td> </tr> </table> 
<p><img width=202 height=13 src="http://referatbank.com.ua/images/76882_image002.gif"> 
<p>0 – 9 
<p>Отже діапазон представлення чисел 0 – 9. Значення старшоWптетради не суттєве: </p><table border=0 cellspacing="0" cellpadding="0" align="center"> <tr> <td width=25 valign=top > 
<p>х </td> <td width=25 valign=top > 
<p>х </td> <td width=25 valign=top > 
<p>х </td> <td width=25 valign=top > 
<p>Х </td> <td width=25 valign=top > 
<p>1 </td> <td width=25 valign=top > 
<p>0 </td> <td width=25 valign=top > 
<p>0 </td> <td width=25 valign=top > 
<p>1 </td> </tr> </table> 
<p><img width=202 height=13 src="http://referatbank.com.ua/images/76882_image002.gif"> 
<p>9 
<p>Для зручності відладки в старшCптетраду записують 0: 
<p><img width=12 height=21 src="http://referatbank.com.ua/images/76882_image003.gif"><img width=12 height=22 src="http://referatbank.com.ua/images/76882_image004.gif"><img width=12 height=21 src="http://referatbank.com.ua/images/76882_image005.gif"><img width=12 height=21 src="http://referatbank.com.ua/images/76882_image006.gif"> 0 0 0 0 
<p> </p><table border=0 cellspacing="0" cellpadding="0" align="center"> <tr> <td width=25 valign=top > 
<p>Х </td> <td width=25 valign=top > 
<p>х </td> <td width=25 valign=top > 
<p>х </td> <td width=25 valign=top > 
<p>Х </td> <td width=25 valign=top > 
<p>1 </td> <td width=25 valign=top > 
<p>0 </td> <td width=25 valign=top > 
<p>0 </td> <td width=25 valign=top > 
<p>1 </td> </tr> </table> 
<p><img width=101 height=12 src="http://referatbank.com.ua/images/76882_image007.gif"><img width=101 height=12 src="http://referatbank.com.ua/images/76882_image008.gif"> <p align="center"> 0 –9 
<p>Зворотне представлення просте: молодш0птетрада, якщо вона знаходиться у межах представлення чисел 0 – 9 визначає відповідне двійково-десяткове неунаковане число. При необхідності працювати з великою розрядністю таких чисел необхідно використовувати також кілька байт. 
<p align="center">
<p><b>Лекція за 24.09.98.</b> 
<p><b>Приклад структури програми на мові асемблера (ш0блон).</b> 
<p>Приведемо основні директиви, які використовуються і програмі на мові асемблера. Тепер використовуються спрощені способи опису сегментів. Сегменти – це частини програми (сегменти даних). Текст програми можна набирати великими або малими буквами, програма асемблера самостійно переводить текст у верхній регістр. Обов’язково у тексті програми писати коментарі. Текст який стоїть за символом “;” є коментарем, він ігнорується при асемблюванні програми. Директива яка як правило йде з початку програми <b>dosseg</b> описує розташування сегментів. Директива <b>mode small</b> – директива опису моделі пам’яті, наприклад в цьому випадку говорять, що модель пам’яті типу<b> small</b>, тобто є один сегмент коду і один сегмент коду і один сегмент даних. Директива <b>.stack 100</b> – директива, яка задає початок сегменту стеку. В стеці зберігаються тимчасові змінні і адреси повернення з підпрограми або переривань. Як правило будь-яка програма має сегмент стеку. В даному випадку такий запис директиви <b>.stack 100</b> позначає, що стек має довжину 100байтів. Точну величину стеку визначає число викликів підпрограм та системних ф-цій, стек треба збільшувати. В кінцевому підсумку розмір стеку підбирають експериментально, коли програма вже написана і відлагоджена. Директива <b>.data</b> – директива початку сегменту ініціалізованих даних, після цього рядка поміщають змінні значення яких відоме (ініціалізовані змінні). Директива <b>.data</b> <b>?</b> – директива початку сегменту неініціалізованих даних. Директива <b>.code</b> – початок сегменту коду. Сегмент коду – це частина коду яка містить команди МП, власне це й є сама програма. В деяких випадках в цей сегмент можна поміщати не тільки команди, а й дані. Наприклад у підпрограмах обробки переривань. Директива <b>.startup</b> – точка початку виконання програми. З наступного після даного рядка починається виконання програми після її завантаження в пам’ять, ця директива повинн0пбути обов’язково всередині сегмента коду, але не обов’язково н0пйого початку. Директива <b>.exit 0.</b> – це директива закінчення програми при виконанні цього рядка управління буде передане ОС. Таких директив в програмі може бути кілька, число після директиви може приймати кілька значень, це число після закінчення програми присвоюється змінній ОС з назвою <b>ERRORLEVEL</b>, ця змінна використовується в командних файлах. Є спеціальні команди для роботи з цією змінною. Використовуючи різні числа можна повідомляти ОС, яка причина закінчення програми. Директиви початку і закінчення програми є по суті макровизначеними, вони визначають необхідний код який автоматично додається на початок і кінець програми. Цей код можна подивитись у файлі лістингу після асемблювання. <b>End</b> – директива закінчення тексту програми на мові асемблера. Рядки які розміщені після директиви <b>end</b> можна писати коментар в довільній формі. 
<p><b>Команди мови асемблера.</b> 
<p>Мінімальна одиниця тексту програми на мові асемблера – це рядок. Асемблер проглядає програму порядкові зверху в низ, кожний рядок закінчується символом переведення рядка Vпйого довжина в більшості випадків не може перевищувати 255 символів, однак зручно обмежувати довжину рядка широкою екрану (80 символів). При необхідності вводити в програмі довгі рядки їх можна об’єднувати, в кінець рядка при цьому потрібно включати символ <b></b>. 
<p>Рядок 1  
<p>Рядок 2 Рядок 1 Рядок 2. 
<p>В текст програми можна вставляти порожні рядки, які складаються тільки із розділювачів. В мові асемблера розділювачами служать символи пропуску та горизонтальна табуляція. При допомозі пустих рядків зручно розділяти логічні частини програми. Рядок може складатись тільки із коментарів, в такому випадку перший символ рядка обов’язково <b>;</b>. В кожному рядку може розміщуватись або команда мікропроцесора, яка записана у мнемонічному (словом) вигляді, або директива, директиви інакше називають псевдооператорами. Команда мікропроцесора – це інструкція яку мікропроцесор буде виконувати в процесі виконання програми. Асемблер переводить рядки з мнемоніками (буквеними записами команд) у послідовності байт, які безпосередньо може виконувати процесор. Директиви служать для визначення даних, які використовуються в програмі і для управління процесом асемблювання. Рядок у програмі на мові асемблера може складатися з 4 полів: 
<p>1. Поле мітки (поле імені); 
<p>2. Поле оператора (або псевдооператора); 
<p>3. Поле операндів; 
<p>4. Поле коментарів. 
<p>Обов’язковим є тільки поле оператора або псевдооператора, всі решту полів можуть бути відсутні. Мітка є спрощеною мнемонічною формою запису адреси команди в сегменті коду. Так саме ім’я є спрощеною формою запису вмісту деякої переважно в сегменті даних. Отже рядки в програмі записуються в такому загальному вигляді: 
<p>[&lt; мітка &gt;]: &lt; команда &gt; &lt; операнди &gt;; коментарі 
<p>&lt; ім’я &gt; &lt;директива &lt; операнди &gt;; коментарі 
<p>Потрібно звернути увагу на відсутність “<b>:</b>” після імені. Поля в рядках мови асемблера розділяються між собою на крайній мірі одним пропуском. Розглянемо поля детальніше. <b>Поле мітки. </b>При визначенні в програмі мітки або імені змінної можна використовувати букви латинського алфавіту великі або малі, а також символи :? _ @ $. Максимальна к-сть символів з яких може складатись мітка або ім’я 255, але відрізняються мітки та імена по перших 32символах. Доцільно в програмі використовувати осмислені імена. Зручно і програмі для швидкого розпізнавання міток від імені починати всі мітки з букви L і записувати їх тільки великими буквами. При записі імен змінних зручно використовувати префікс, який означає тип змінної, наприклад : <b>skp_byte</b>. При програмуванні з використанням асемблера <b>masm</b>, або <b>tasm</b> можна використовувати будь-яке число локальних міток @@. Для переходу до таких міток треба використовувати зарезервовані слова: @F – forward; @B – backward. Перш0п@F – це перехід до наступної мітки, @B – це перехід до попередньої мітки. Мітка або ім’я змінної не повиннVпбути зарезервованим словом. 
<p><b>Поле операндів.</b> 
<p>Поле операндів залежить від попереднього поля. 
<p><b>Поле коментарів.</b> 
<p><b>Структура програми на мові asm.</b> 
<p>При роботі будь-якої програми в будь-який момент часу можна виділяти декілька ділянок пам’яті з якими працює процесор. Використання сегментів є особливістю процесорів х86. Воно переслідує таку мету:ами. 
<p>За вання сегментів є спробою заха вити незв’язані ділянки пам’яті в програмі. Допускалось, що для того, щоб визначити адресу деякої комірки пам’яті потрібно знати дві складові цієї адреси: адресу початкового сегменту та адресу зміщення комірки пам’яті від початку сегменту. Адреси початків сегментів знаходяться у відповідних сегментах регістрах CS, DS, SS, ES – змінюючи вміст цих регістрів можна дістати доступ до тих чи інших ділянок пам’яті, тому такий запис легко зламати. Тому в процесорі 386 в захащеному режимі роботи адреси початків сегментів, їх довжини та права доступу зберігаються в спеціальних системних одиницях. В сегментних регістрах зберігають тільки індекс структури всередині таблиці. Це дозволило ізолювати сегменти та обмежило доступ до них з програми. Адже для доступу потрібно знати не тільки вміст сегменту регістру, але й тієї структури на яку він вказує. Така зміна можлива тільки при використанні привілейованих команд, що виконується тільки в певних умовах, можуть виконуватись в ОС, але не можуть використовуватись в програмах користувача. Паралельно з цим збільшення розміру сегментів:амід 64Кб для 86, до 4Гб для 486. Крім того програма буде виконуватись, якщо змінити адресу початку сегменту. Це означає, що в пам’яті він буде перенесений в інше місце. При цьому відносне зміщення в сегменті не можна зміщувати. Це дозволить переносити програму в пам’яті навіть під час її виконання. Використання сегментації пам’яті дозволяє різко збільшити розміри пам’яті, яку можна використати. Так, в захащеному режимі максимально можливий об’єм пам’яті, яку можна адресувати – 64Тб. Це віртуальна пам’ять. Тоді як фізичний об’єм пам’яті складає 4Гб. В деяких випадках використовувати сегментацію недоцільно. Тому в старших моделях можна працювати із сегментами довжиною до 4Гб. Це означає, що вся фізична пам’ять розглядається як один сегмент. Повністю усі переваги сегментації пам’яті проявляється в захащеному режимі роботи. В реальному режимі роботи оперує з 4-ма сегментами:а 
<p align="center">
<p>1. Сегмент коду; 
<p>2. Сегмент даних; 
<p>3. Сегмент стеку; 
<p>4. Сегмент додаткових даних. 
<p>Для процесорів 386 з’явились ще 2 сегменти додаткових даних. Ці сегменти в пам’яті можуть розташиняватись як завгодно по відношенню один до одного. Ніяких обмежень на їх розташування немає. Сегменти можуть починатись з однієї адреси, тобто можуть перекриватись. Вони можуть розташиняватись в пам’яті без перекривання, або між ними можуть бути проміжки. 
<p>Для визначення адреси наступної команди після виконання попередньої використовують 2 регістри: CS (регістр сегменту коду, він містить початок адресу цього сегменту), і IP(регістр вказівника команд, якість зміщення команди відносно початку сегменту). В процесі виконання програми вміст ІР автоматично змінюється. Якщо змінити вміст регістрів CS, та ІР, то виклик програми почнеться з іншої адреси. Але явним чином змінити вміст цих регістрів неможливо. Це можна зробити тільки при використані деяких команд. Наприклад при виклику підпрограми. Або виконані програми безумовного переходу. Як уже відмічалось в сегменті коду можна також описувати дані. Але це роблять тільки в обгрунтованих випадках, наприклад в програмі обробки переривань. 
<p><b>Початок програми.</b> 
<p>В початковій версії необхідно було відмітити точку входу в програму деякою міткою. Ім’я цієї мітки потім вказувалось в директиві <b>end</b>. Це було ознакою закінчення файлу з програмою. У сучасних асемблерах для визначення точки входу в програму використовується директива <b>startup</b>. Вона записується в сегменті коду, це спрощує запис і, крім цього, автоматично ініціалізує значення сегментних регістрів. В старих версіях це потрібно було робити вручну. 
<p><b>Кінець програми.</b> 
<p>Для закінчення програми потрібно було скористяватись стандартною директивою. Вона робить відповідний виклик автоматично. Якщо програму необхідно закінчити спеціальним чином, наприклад встановити резидентну програму, то користяватись цією директивою не можна. В таких випадках потрібно явно викликати відповідну функцію операційної системи. 
<p><b>Змінні в програмі.</b> 
<p>В усіх інших сегментах виділяється місце для змінних, що використовуються в програмі. Поділ сегментів на сегменти даних, стеку та додаткових даних зумовлена тим, що змінні, які тут визначені мають різні властивості. Змінні в програмі можна розбити на 2 великі групи: 
<p>1. Змінні, які явна використовуються в програмі виходячи з її логіки. Такі змінні як правило мають імена і використовуються вони для збереження даних, які мають наперед визначений зміст. Наприклад, змінна що використовується для збереження коду натиснутої клавіші. 
<p>2. Часто в програмі необхідно мати місце для збереження тимчасових даних. 
<p><b>Сегмент даних.</b> 
<p>Використовується для збереження змінних, що визначає програміст. Як правило це робиться при допомозі псевдооператорів виділення пам’яті. Для визначення адреси початку сегменту використовується регістр DS. Для визначення другої компоненти адреси (відповідного зміщення всередині сегменту) використовується кілька способів адресації. Зауважимо, що способів визначення адреси змінної набагато більше ніж способів визначення адреси команди. В мові асемблер є засоби для явного розділ. збереження змінних. Ці змінні можуть мати або не мати початкових значень, а також можуть бути змінними константами. Розділяти ці типи змінних не обов’язково. Усіх їх можна зберігати в сегменті даних. 
<p><b>Ініціалізовані змінні.</b> 
<p>Змінні, початкові значення яких відоме як правило записуються в сегменті, що починається директивою <b>data</b>. До цих змінних відносяться також ті, початкові значення яких відоме і в процесі роботи вони не повиннVпмінятись. 
<p><b>Неініціалізовані змінні.</b> 
<p>Неініціалізовані змінні записуються в сегмент який починається директивою <b>data</b>. 
<p>Сегмент стеку використовується для збереження тимчасових даних для яких недоцільно виділяти змінні. Адреса початку цього сегменту розміщується в регістрі SS, а зміщення відносно початку в регістрі SP. Для визначення сегменту стеку використовується директива <b>stack</b>. Цей сегмент відрізняється від сегменту даних і коду. В сегменті даних і коду можна явно адресувати б-я комірку пам’яті. Тут значення регістру при виконанні команд. В кожний момент часу пара цих регістрів SS і SP вказує на так звану вершину стеку. Сюди можна записати або прочитати значення. Стек організований за правилом: перший записаний, останній прочитаний. Тому у програмі команди запису і зчитування зі стеку потрібно використовувати попарно. Стек переважно використовується для тимчасового зберігання адреси повернення з програми або перервань. Ще одне ми. 
<p>За вання стеку – при його допомозі можна передавати аргументи підпрограмам і організовувати локальні змінні. 
<p><b>Лекція за 1.10.</b> 
<p><b>Моделі пам’яті</b> 
<p>1. <b>Tiny (файл *.com). </b>При цьому регістри CS, DS, SS містять однакові значення. Це найбільш компактна модель пам’яті. Розмір пам’яті не може перевищувати 63Кб. Адресація здійснюється за допомогою зміщення і міток. Оскільки програма на асемблері не є великими, то це не є значним обмеженням. Ця модель широко використовується, особливо в резидентних програмах. 
<p>2. <b>Small</b>. Сегмент коду відділений від сегменту стеку і сегменту даних. Сегмент даних і стеку об’єднані в єдине. Тому CS і DS мають однакові значення. Це найбільш поширена модель при розробці програм на асемблері. Всі переходи і виклики підпрограм здійснюються за допомогою короткої адресації. 
<p>3. <b>Compact</b>. Використовується 1 сегмент коду і можливе ми. 
<p>3.За вання кількох сегментів даних. тому виклики підпрограм і переходи в програмі є короткими, а доступи до даних – далекими. Сегмент даних і стек об’єднані в одну групу. 
<p>4. <b>Medium.</b> В значній мірі протилежна до попередніх. Є кілька сегментів коду і один сегмент даних. Тому доступ до підпрограм і переходи в програмі є далекими (потрібна адреса сегменту та зміщення). А доступ до даних здійснюється за допомогою короткої адресації (вказується тільки зміщення). 
<p>5. <b>Large.</b> Це найбільш загальний спосіб організації пом’яті. Тут можуть використовуватись декілька сегментів коду і даних. Доступ до змінних, переходи на мітки здійснюються за допомогою адреси сегментів та зміщень. 
<p>6. <b>Huge, Flat.</b> Це досить поширені моделі. Така ж організація пам’яті, як і в <b>large</b>. Вона використовується для поєднання асемблера змовами високого рівня. В них можна задати таку модель пам’яті, з’являється можливість роботи з даними що займають більше 64 Кб. В програмі на асемблері таку модель використовувати недоцільно. Модель <b>Flat</b> відповідає моделі <b>Small</b>, різниця в тому, що використовуються 32 розрядні регістри. Таку модель можна організувати використовуючи процесор вище <b>і80386.</b> Переважно її використовують для роботи в захащеному режимі. В цьому випадку доступ до всієї області пам’яті здійснюються за допомогою одного сегменту. 
<p>При програмуванні на асемблері краще використовувати перші 2 моделі пам’яті. Можна використовувати інші моделі, але в цих випадках програма ускладнюється, адже доводиться слідкувати за розміщенням кожного сегменту. Для визначення моделі пам’яті використовується директива <b>model</b>, що має такий формат запису: 
<p>Model [ &lt; модифікатор &gt;] &lt; тип &gt;. 
<p>В цій директиві може бути вказано ще ряд параметрів. Єдиним необхідним параметром є параметр &lt;тип&gt;. Тип можна додатково модифікувати. Для цього необхідно вказати один із 4 модифікаторів:а<b>nearstack; farstack; use16; use32. </b>При першому стек і дані розташинані в межах одного сегменту; <b>farstack </b>вказує, що сегмент даних буде розташинаний за межами стеку. <b>Nearstack</b> використовується по замовчуванню у всіх стандартних моделях пам’яті. Він дозволяє організувати інтерфейс з мовами високого рівня. Тут глобальні дані розміщені в сегменті даних, а локальні – в сегменті стеку. Два останні модифікатори використовуються тільки для МП 80386 і старше, вони вказують які сегменти використовуються в програмі, 16-розрядні (64 Кб сегмент) і 32-розрядні (4Гб сегмент). Доцільно використовувати ці модифікатори при розробці програм при використанні 32-розрядних компіляторів. 
<p align="center">
<p><b>Псевдооператори (директиви).</b> 
<p>Псевдооператори керують роботою асемблера, а не МП. Вони дозволяють визначати сегменти і процедури (надавати імена програмам і елементам даних, резервувати області пом’яті та виконувати багато інших задач). Псевдооператори мають таку загальну форму запиту:а 
<p>[&lt;ідентифікатор&gt;] псевдооператор [&lt;операнд&gt;][; коментар]. 
<p>Обов’язковим є тільки поле псевдооператори. Для одних псевдооператорів ідентифікатор обов’язковий, для інших заборонений, для третіх необов’язковий, це ж відноситься і до операнди, коментарі завжди необов’язкові. Псевдооператор може починатися в будь-якому місці рядка, він повинен бути віддаленим від попереднього поля хоча б одним пропуском. Ми розглянемо найбільш розповсюджені псевдооператори, їх можна поділити на дві групи: псевдооператори даних і псевдооператори керування лістингом. Псевдооператори даних можна розділити на 5 груп:а 
<p>1. Псевдооператори визначення ідентифікаторів. Вони дозволяють виразу присвоїти символічне ім’я, тобто ідентифікатор. В якості виразу може бути константа, адреса, інше символічне ім’я. Після такої директиви цей ідентифікатор можна використовувати в будь-якому місці де необхідно вказати вираз. Два оператори:а<b>EQU</b> і <b>=</b>, ці псевдооператори подібні, але між ними є істотна різниця:а 
<p>Позначені знаком “=” ідентифікатори можна перевизначати, а визначені псевдооператором <b>EQU</b> неможна. Псевдооператор <b>EQU</b> можна використовувати як з числовими такі з текстовими виразами, а псевдооператор “=” тільки з числовими. Приклади: 
<p><b>К1аEQU 1024 – </b>присвоєння імені константі; <b>T_1аEQU DS:[BP][SI].</b> Комбінації адрес <b>DS:[BP][SI]</b> присвоюється символічне ім’я, всюди в програмі замість комбінації цих адрес можна використовувати <b>T_1</b>. <b>В_Т EQU B_T1</b>, визначення синоніму, тобто ім’я <b>В_Т</b> буде мати те ж значення як і зміна <b>В_Т1</b>. <b>REG1аEQU CX</b> – присвоєння імені регістру. При використанні псевдооператора “=” в якості виразу можуть виступати математичні перетворення. В директиві <b>EQU</b> також можуть бути прості математичні перетворення, вони будуть виконані асемблером під час трансляції. Наприклад:<b> CON1аEQU CON2*2 CONS1=24 CONS1=29 CONS1=CONS1+1.</b> 
<p>2. Псевдооператори визначення даних. В асемблері можна використовувати комірки пам’яті для збереження поіменованих даних, тобто змінних. Найбільш використовуються такі псевдооператори для резервування пам’яті:1) DB – Define Byte; 2) DW – Define Word; 3) DD – Define Double Word; 4) DQ; 5) DF; 6) DT. В основному вони розрізняються по об’єму пам’яті, який резервується. Псевдооператори визначення даних мають такий формат запису: <b>ім’я псевдооператор вираз [,……]. </b>В якості виразу найчастіше може бути константа. Псевдооператор DB резервує пам’ять об’ємом 1 байт. DW – об’ємом одне слово. DD – подвійне слово. DQ – 2пподвійні слова. DF – 6 байт. DT – 10 байт. Наприклад змінна xyz DW 2S – резервує для змінної ( ). Треба пам’ятати про макс. Vпмін. значення даних, які можуть бути розміщені у відведеній пам’яті в кожному з цих випадків, так наприклад: макс. значення байта без знака не може перевищувати 255, макс. значення байта зі знаком 127, а мін. – 128. Псевдооператори можна використовувати для створення в пам’яті таблиць, наприклад: <b>А_ТАВ DB 3, 2, 4, 6, 8, 0, 0, 0</b> 
<p><b> DB 5, 4, 2, 1</b> 
<p>Такий псевдооператор <b>DB</b> резервує в пам’яті місце для 12 значень елементів таблиці <b>А_ТАВ</b> кожний розміром в байт. Можна вказувати довільну кількість елементів таблиці рядку, важливо, щоб вони помістились в 132 позиції рядка. В асемблері є операція <b>DUP</b>, яка дозволяє скорочувати задання таблиць у випадку однакових елементів. Даний псевдооператор можна записати так: 
<p><b>А_ТАВ DB 3, 2, 4, 6, 8, 3 DUP (0),</b> 
<p><b> DB 5, 4, 2, 1</b> 
<p>В пам’яті можна резервувати пам’ять для змінної, але конкретного значення їй не надавати. Для цього в полі виразу треба вказати знак питання. Приклад: <b>X_1аDB ? X_2 DW ?</b>. Такі псевдооператори резервують в пам’яті місце байту і слова, але початкового значення їм не надають. <b>X_1аi X_2 </b>при цьому не будуть містити ніяких специфічних значень, навіть <b>(0)</b>. Можна зарезервувати в пам’яті місце для таблиці. Наприклад: <b>А_ТАВ DB 12 DUP (3)</b> резервує місце для таблиці з 12 елементів. Можна в якості значення змінної задавати рядок символів, для цього текст заключається в апострофи. 
<p>3. Псевдооператори визначення сегменту і процедури. Для визначення сегменту використовуються псевдооператори: <b>SEGMENTаi ENDS</b>. Це псевдооператори ділять вихідну програму на сегменти. Вони відповідно відмічають початок і кінець сегменту, але вини не повідомляють асемблер якого роду сегмент повинен бути визначений. Для цього використовується псевдооператор <b>ASSUME</b><b>, </b>він має таку форму запису: <b>ASSUME </b>регістр сегмента: ім’я сегмента [,…….]. це регістр сегмента – це ім’я одного із сегментних регістрів <b>CS</b><b>, </b><b>DS</b><b>, </b><b>SS</b><b>, </b><b>ES</b>. Якщо П 80386 і вище то там ще буде <b>FS</b><b>, </b><b>GS</b>. Ім’я сегмента це ім’я яке вказується в псевдооператорі <b>SEGMENT</b>. Цей псевдооператор допомагає асемблеру перетворювати мітки в адреси, він повідомляє, яким регістром хочете скористяватися при адресації міток. Наприклад:<b>ASSUME</b><b>DS</b><b>: </b><b>DSEG</b><b> – </b>означає, якщо при трансляції програми буде згадана мітка із сегмента <b>DSEG</b>, тобто регістр <b>DS</b> буде завжди вказувати на початок сегмента <b>DSEG</b>. Майже завжди його поміщають після псевдооператора <b>SEGMENT. </b>Зауважимо, що адресу початку сегменту потрібно явно завантажити в <b>DS</b>. Псевдооператори <b>PROG</b>і <b>ENDP</b> визначають початок і кінець процедури. Кожна процедура повинн0ппочинатись 
<p><b>Структура программы на ассемблере Синтаксис ассемблера Стандартные директивы сегментации Упрощенные директивы сегментации </b> 
<p>Программа на ассемблере представляет собой совокупность блоков памяти, называемых сегментами памяти. Программа может состоять из одного или нескольких таких блоков-сегментов. Каждый сегмент содержит совокупность предложений языка, каждое из которых занимает отдельную строку кода программы. Предложения ассемблера бывают четырех типов: 
<p>команды или инструкции представляющие собой символические аналоги машинных команд. В процессе трансляции инструкции ассемблера преобразуются в соответствующие команды системы команд микропроцессора; <b>макрокоманды</b> - оформляемые определенным образом предложения текста программы, замещаемые во время трансляции другими предложениями; <b>директивы,</b> являющиеся указанием транслятору ассемблера на выполнение некоторых действий. У директив нет аналогов в машинном представлении; <b>строки комментариев</b>, содержащие любые символы, в том числе и буквы русского алфавита. Комментарии игнорируются транслятором. 
<p><b>Синтаксис ассемблера Предложения, составляющие программу, могут представлять собой синтаксическую конструкцию, соответствующую команде, макрокоманде, директиве или комментарию. Для того чтобы транслятор ассемблера мог распознать их, они должны формироваться по определенным синтаксическим правилам. Для этого лучше всего использовать формальное описание синтаксиса языка наподобие правил грамматики. Наиболее распространенные способы подобного описания языка программирования - синтаксические диаграммы и расширенные формы Бэкуса-Наура. Для практического использования более удобны синтаксические диаграммы. К примеру, синтаксис предложений ассемблера можно описать с помощью синтаксических диаграмм, показанных на следующих рисунках.</b> 
<p><img width=644 height=109 src="http://referatbank.com.ua/images/76885_image009.gif"> 
<p><b>Рис. 1. </b>Формат предложения ассемблера 
<p><img width=433 height=128 src="http://referatbank.com.ua/images/76885_image010.gif"> 
<p><b>Рис. 2. </b>Формат директив 
<p><img width=470 height=124 src="http://referatbank.com.ua/images/76885_image011.gif"> 
<p><b>Рис. 3. </b>Формат команд и макрокоманд 
<p>На этих рисунках: 
<p><b>имя метки</b> - идентификатор, значением которого является адрес первого байта того предложения исходного текста программы, которое он обозначает; имя - идентификатор, отличающий данную директиву от других одноименных директив. В результате обработки ассемблером определенной директивы этому имени могут быть присвоены определенные характеристики; <b>код операции</b> (КОП) и директива - это мнемонические обозначения соответствующей машинной команды, макрокоманды или директивы транслятора; <b>операнды</b> - части команды, макрокоманды или директивы ассемблера, обозначающие объекты, над которыми производятся действия. Операнды ассемблера описываются выражениями с числовыми и текстовыми константами, метками и идентификаторами переменных с использованием знаков операций и некоторых зарезервированных слов. <b>Как использовать синтаксические диаграммы? </b>Очень просто: для этого нужно всего лишь найти и затем пройти путь от входа диаграммы (слева) к ее выходу (направо). Если такой путь существует, то предложение или конструкция синтаксически правильны. Если такого пути нет, значит эту конструкцию компилятор не примет. При работе с синтаксическими диаграммами обращайте внимание на направление обхода, указываемое стрелками, так как среди путей могут быть и такие, по которым можно идти справа налево. По сути, синтаксические диаграммы отражают логику работы транслятора при разборе входных предложений программы. 
<p align="center">
<p>Допустимыми символами при написании текста программ являются: <ol > <li class=MsoNormal >все латинские буквы: <b>A-Z</b>,<b> a-z</b>. При этом заглавные и строчные буквы считаются эквивалентными; </li> <li class=MsoNormal >цифры от <b>0</b> до <b>9</b>; </li> <li class=MsoNormal >знаки <b>?</b>,<b> @</b>,<b> $</b>,<b> _</b>,<b> &amp;</b>; </li> <li class=MsoNormal >разделители <b>, . [ ] ( ) &lt; &gt; { } + / * % ! " &quot; ?  = # ^</b>. </li> </ol> 
<p>Предложения ассемблера формируются из лексем, представляющих собой синтаксически неразделимые последовательности допустимых символов языка, имеющие смысл для транслятора. <b>Лексемами являются</b>: <b>идентификаторы</b> - последовательности допустимых символов, использующиеся для обозначения таких объектов программы, как коды операций, имена переменных и названия меток. Правило записи идентификаторов заключается в следующем: идентификатор может состоять из одного или нескольких символов. В качестве символов можно использовать буквы латинского алфавита, цифры и некоторые специальные знаки - _, ?, $, @. Идентификатор не может начинаться символом цифры. Длина идентификатора может быть до 255 символов, хотя транслятор воспринимает лишь первые 32, а остальные игнорирует. Регулировать длину возможных идентификаторов можно с использованием опции командной строки <b>mv</b>. Кроме этого существует возможность указать транслятору на то, чтобы он различал прописные и строчные буквы либо игнорировал их различие (что и делается по умолчанию). Для этого применяются опции командной строки <b>/mu, /ml, /mx</b>;<b>цепочки символов</b> - последовательности символов, заключенные в одинарные или двойные кавычки; <b>целые числа</b> в одной из следующих систем счисления: двоичной, десятичной, шестнадцатеричной. Отождествление чисел при записи их в программах на ассемблере производится по определенным правилам: <b>Десятичные числа</b> не требуют для своего отождествления указания каких-либо дополнительных символов, например 25 или 139. Для отождествления в исходном тексте программы <b>двоичных чисел</b> необходимо после записи нулей и единиц, входящих в их состав, поставить латинское &quot;<b>b</b>&quot;, например 10010101<b>b</b>. <b>Шестнадцатеричные числа</b> имеют больше условностей при своей записи: Во-первых, они состоят из цифр <b>0 .9</b>, строчных и прописных букв латинского алфавита <b>a</b>,<b> b</b>, <b>c</b>,<b> d</b>,<b> e</b>,<b> f</b> или <b>A</b>,<b> B</b>,<b> C</b>,<b> D</b>,<b> E</b>,<b> F</b>. Во-вторых, у транслятора могут возникнуть трудности с распознаванием шестнадцатеричных чисел из-за того, что они могут состоять как из одних цифр 0 .9 (например 190845), так и начинаться с буквы латинского алфавита (например <b>ef15</b>). Для того чтобы &quot;объяснить&quot; транслятору, что данная лексема не является десятичным числом или идентификатором, программист должен специальным образом выделять шестнадцатеричное число. Для этого на конце последовательности шестнадцатеричных цифр, составляющих шестнадцатеричное число, записывают латинскую букву &quot;<b>h</b>&quot;. Это обязательное условие. Если шестнадцатеричное число начинается с буквы, то перед ним записывается ведущий ноль: <b>0</b>ef15<b>h</b>. Таким образом, мы разобрались с тем, как конструируются предложения программы ассемблера. Но это лишь самый поверхностный взгляд. 
<p>Практически каждое предложение содержит описание объекта, над которым или при помощи которого выполняется некоторое действие. Эти объекты называются операндами. Их можно определить так: <b>операнды</b> - это объекты (некоторые значения, регистры или ячейки памяти), на которые действуют инструкции или директивы, либо это объекты, которые определяют или уточняют действие инструкций или директив. Операнды могут комбинироваться с арифметическими, логическими, побитовыми и атрибутивными операторами для расчета некоторого значения или определения ячейки памяти, на которую будет воздействовать данная команда или директива. Возм<b>ожно провести следующую классификацию операндов: </b> 
<p>постоянные, или непосредственные, операнды ,адресные операнды .перемещаемые операнды ,счетчик адреса ,регистровый операнд .базовый и индексный операнды .структурные операнды ,Записи ,Рассмотрим подробнее характеристику операндов из приведенной классификации: <b>Постоянные или непосредственные операнды</b> - число, строка, имя или выражение, имеющие некоторое фиксированное значение. Имя не должно быть перемещаемым, то есть зависеть от адреса загрузки программы в память. К примеру, оно может быть определено операторами <b>equ</b> или <b>=</b>. num equ 5imd = num-2 mov al,num ;эквивалентно mov al,5 ;5 здесь непосредственный операнд add [si],imd ; imd=3 - непосредственный операнд mov al,5 ;5 - непосредственный операнд 
<p>В данном фрагменте определяются две константы, которые затем используются в качестве непосредственных операндов в командах пересылки mov и сложения add. Адресные операнды - задают физическое расположение операнда в памяти с помощью указания двух составляющих адреса: сегмента и смещения (рис. 4). <img width=615 height=219 src="http://referatbank.com.ua/images/76886_image012.gif"> <ul > <li class=MsoNormal ><b>Рис. 4. </b>Синтаксис описания адресных операндов</li> </ul> 
<p>К примеру: mov ax,0000h mov ds,ax mov ax,ds:0000h ;записать слово в ax из области памяти по ;физическому адресу 0000:0000 
<p>· Здесь третья команда mov имеет адресный операнд. <ul > <li class=MsoNormal >Перемещаемые операнды - любые символьные имена, представляющие некоторые адреса памяти. Эти адреса могут обозначать местоположение в памяти некоторых инструкции (если операнд - метка) или данных (если операнд - имя области памяти в сегменте данных). Перемещаемые операнды отличаются от адресных тем, что они не привязаны к конкретному адресу физической памяти. Сегментная составляющая адреса перемещаемого операнда неизвестна и будет определена после загрузки программы в память для выполнения. </li> </ul> 
<p>К примеру: data segmentmas_w dw 25 dup (0):code segment: lea si,mas_w ;mas_w - перемещаемый операнд 
<p>· В этом фрагменте mas_w - символьное имя, значением которого является начальный адрес области памяти размером 25 слов. Полный физический адрес этой области памяти будет известен только после загрузки программы в память для выполнения. <ul > <li class=MsoNormal >Счетчик адреса - специфический вид операнда. Он обозначается знаком <b>$</b>. Специфика этого операнда в том, что когда транслятор ассемблера встречает в исходной программе этот символ, то он подставляет вместо него текущее значение счетчика адреса. Значение счетчика адреса, или, как его иногда называют, счетчика размещения, представляет собой смещение текущей машинной команды относительно начала сегмента кода. В формате листинга счетчику адреса соответствует вторая или третья колонка (в зависимости от того, присутствует или нет в листинге колонка с уровнем вложенности). Если взять в качестве пример любой листинг, то видно, что при обработке транслятором очередной команды ассемблера счетчик адреса увеличивается на длину сформированной машинной команды. Важно правильно понимать этот момент. К примеру, обработка директив ассемблера не влечет за собой изменения счетчика. Директивы, в отличие от команд ассемблера, - это лишь указания транслятору на выполнение определенных действий по формированию машинного представления программы, и для них транслятором не генерируется никаких конструкций в памяти. В качестве примера использования в команде значения счетчика адреса можно привести следующий: </li> </ul> jmp $+3 ;безусловный переход на команду mov cld ;длина команды cld составляет 1 байт mov al,1 
<p> При использовании подобного выражения для перехода не забывайте о длине самой команды, в которой это выражение используется, так как значение счетчика адреса соответствует смещению в сегменте команд данной, а не следующей за ней команды. В нашем примере команда jmp занимает 2 байта. Но будьте осторожны, длина команды зависит от того, какие в ней используются операнды. Команда с регистровыми операндами будет короче команды, один из операндов которой расположен в памяти. В большинстве случаев эту информацию можно получить, зная формат машинной команды и анализируя колонку листинга с объектным кодом команды. <b>Регистровый операнд</b> - это просто имя регистра. В программе на ассемблере можно использовать имена всех регистров общего назначения и большинства системных регистров. mov al,4 ;константу 4 заносим в регистр al mov dl,pass+4 ;байт по адресу pass+4 в регистрdl add al,dl ;команда с регистровыми 
<p align="center">
<p>операндами <ul > <li class=MsoNormal >Базовый и индексный операнды. Этот тип операндов используется для реализации косвенной базовой, косвенной индексной адресации или их комбинаций и расширений. </li> <li class=MsoNormal >Структурные операнды используются для доступа к конкретному элементу сложного типа данных, называемого структурой. </li> <li class=MsoNormal >Записи (аналогично структурному типу) используются для доступа к битовому полю некоторой записи. </li> </ul> 
<p>Операнды являются элементарными компонентами, из которых формируется часть машинной команды, обозначающая объекты, над которыми выполняется операция. В более общем случае операнды могут входить как составные части в более сложные образования, называемые выражениями. <b>Выражения</b> представляют собой комбинации операндов и операторов, рассматриваемые как единое целое. 
<p>Результатом вычисления выражения может быть адрес некоторой ячейки памяти или некоторое константное (абсолютное) значение. 
<p>Возможные типы операндов мы уже рассмотрели. Перечислим теперь возможные типы операторов ассемблера и синтаксические правила формирования выражений ассемблера. 
<p>Арифметические операторы Операторы сдвига Операторы сравнения Логические операторы Индексный оператор Оператор переопределения типа Оператор переопределения сегмента Оператор именования типа структуры Оператор получения сегментной составляющей адреса выражения Оператор получения смещения выражения 
<p>В табл. 2 приведены поддерживаемые языком ассемблера операторы и перечислены их приоритеты. Дадим краткую характеристику операторов: <ul > <li class=MsoNormal >Арифметические операторы. К ним относятся: </li> <ul > <li class=MsoNormal >унарные &quot;<b>+</b>&quot; и &quot;<b>-</b>&quot;; </li> <li class=MsoNormal >бинарные &quot;<b>+</b>&quot; и &quot;<b>-</b>&quot;; </li> <li class=MsoNormal >умножения &quot;<b>*</b>&quot;; </li> <li class=MsoNormal >целочисленного деления &quot;<b>/</b>&quot;; </li> <li class=MsoNormal >получения остатка от деления &quot;<b>mod</b>&quot;. </li> </ul> </ul> 
<p>Эти операторы расположены на уровнях приоритета 6, 7, 8 в табл. 2. Например, tab_size equ 50 ;размер массива в байтахsize_el equ 2 ;размер элементов:;вычисляется число элементов массива и заносится врегистр cx 
<p> mov cx,tab_size / size_el ;оператор &quot;/&quot; <ul > <li class=MsoNormal ><b>Рис. 5. </b>Синтаксис арифметических операций</li> <li class=MsoNormal >Операторы сдвига выполняют сдвиг выражения на указанное количество разрядов (рис. 6). Например, </li> </ul> mask_b equ 10111011: 
<p>mov al,mask_b shr 3 ;al=00010111 
<p><img border=0 width=423 height=103 src="http://referatbank.com.ua/images/76887_image013.gif"> <ul > <li class=MsoNormal ><b>Рис. 6. </b>Синтаксис операторов сдвига</li> <li class=MsoNormal >Операторы сравнения (возвращают значение &quot;истина&quot; или &quot;ложь&quot;) предназначены для формирования логических выражений (см. рис. 7 и табл. 1). Логическое значение &quot;истина&quot; соответствует цифровой единице, а &quot;ложь&quot; - нулю. Например, </li> </ul> </p><table border=0 cellspacing="0" cellpadding="0" align="center"> <tr> <td width=330 > tab_size equ 30 ;размер таблицы: mov al,tab_size ge 50 ;загрузка размератаблицы в al cmp al,0 ;если tab_size &lt; 50, то je m1 ;переход на m1:m1: :</td> </tr> </table> <ul > <li class=MsoNormal >В этом примере если значение tab_size больше или равно 50, то результат в al равен 0ffh, а если tab_size меньше 50, то al равно 00h. Команда cmp сравнивает значение al с нулем и устанавливает соответствующие флаги в flags/eflags. Команда je на основе анализа этих флагов передает или не передает управление на метку m1. </li> <li class=MsoNormal ><img border=0 width=32 height=32 src="http://referatbank.com.ua/images/76887_image014.gif"></li> <li class=MsoNormal ><b>Рис. 7.</b> Синтаксис операторов сравнения</li> </ul> 
<p><b>· Таблица 1. Операторы сравнения</b> </p><table border=0 cellspacing="0" cellpadding="0" align="center"> <tr> <td width=72 > 
<p>Оператор </td> <td width=441 > 
<p>Значение </td> </tr> <tr> <td width=72 > 
<p>eq </td> <td width=441 > 
<p>ИСТИНА, если выражение_1 равно выражение_2 </td> </tr> <tr> <td width=72 > 
<p>ne </td> <td width=441 > 
<p>ИСТИНА, если выражение_1 не равно выражение_2 </td> </tr> <tr> <td width=72 > 
<p>lt </td> <td width=441 > 
<p>ИСТИНА, если выражение_1 меньше выражение_2&gt;ИСТИНА, если выражение_1 не равно выражение_2 </td> </tr> <tr> <td width=72 > 
<p>le </td> <td width=441 > 
<p>ИСТИНА, если выражение_1 меньше или равно выражение_2 </td> </tr> <tr> <td width=72 > 
<p>gt </td> <td width=441 > 
<p>ИСТИНА, если выражение_1 больше выражение_2 </td> </tr> <tr> <td width=72 > 
<p>ge </td> <td width=441 > 
<p>ИСТИНА, если выражение_1 больше или равно выражение_2 </td> </tr> </table> <ul > <li class=MsoNormal >Логические операторы выполняют над выражениями побитовые операции (рис. 8). Выражения должны быть абсолютными, то есть такими, численное значение которых может быть вычислено транслятором. Например: </li> </ul> </p><table border=0 cellspacing="0" cellpadding="0" align="center"> <tr> <td width=330 > flags equ 10010011 mov al,flags xor 01h ;al=10010010;пересылка в al поля flags с ;инвертированным пр авым битом</td> </tr> </table> 
<p><img border=0 width=528 height=132 src="http://referatbank.com.ua/images/76887_image015.gif"> 
<p> <ul > <li class=MsoNormal ><b>Рис. 8. </b>Синтаксис логических операторов</li> <li class=MsoNormal >Индексный оператор <b>[ ]</b>. Не удивляйтесь, но скобки тоже являются оператором, и транслятор их наличие воспринимает как указание сложить значение <b>выражение_1</b> за этими скобками с <b>выражение_2</b>, заключенным в скобки (рис. 9). Например, </li> </ul> </p><table border=0 cellspacing="0" cellpadding="0" align="center"> <tr> <td width=330 > mov ax,mas[si] ;пересылка слова по адресу mas+(si) в регистр ax</td> </tr> </table> <ul > <li class=MsoNormal ><img border=0 width=250 height=40 src="http://referatbank.com.ua/images/76887_image016.gif"></li> <li class=MsoNormal ><b>Рис. 9.</b> Синтаксис индексного оператора</li> </ul> 
<p>· Заметим, что в литературе по ассемблеру принято следующее обозначение: когда в тексте речь идет о содержимом регистра, то его название берут в круглые скобки. Мы также будем придерживаться этого обозначения. К примеру, в нашем случае запись в комментариях последнего фрагмента программы mas + (si) означает вычисление следующего выражения: значение смещения символического имени mas плюс содержимое регистра si. <ul > <li class=MsoNormal >Оператор переопределения типа <b>ptr</b> применяется для переопределения или уточнения типа метки или переменной, определяемых выражением (рис. 10). Тип может принимать одно из следующих значений: <b>byte, word, dword, qword, tbyte, near, far</b>. Например, </li> </ul> </p><table border=0 cellspacing="0" cellpadding="0" align="center"> <tr> <td width=330 >d_wrd dd 0 . mov al,byte ptr d_wrd+1 ;пересылка второго байта из двойного слова</td> </tr> </table> <ul > <li class=MsoNormal >Поясним этот фрагмент программы. Переменная d_wrd имеет тип двойного слова. Что делать, если возникнет необходимость обращения не ко всей переменной, а только к одному из входящих в нее байтов (например, ко второму)? Если попытаться сделать это командой mov al,d_wrd+1, то транслятор выдаст сообщение о несовпадении типов операндов. Оператор <b>ptr</b> позволяет непосредственно в команде переопределить тип и выполнить команду. </li> <li class=MsoNormal ><img border=0 width=442 height=32 src="http://referatbank.com.ua/images/76887_image017.gif"></li> <li class=MsoNormal ><b>Рис. 10. </b>Синтаксис оператора переопределения типа</li> <li class=MsoNormal >Оператор переопределения сегмента <b>:</b> (двоеточие) заставляет вычислять физический адрес относительно конкретно задаваемой сегментной составляющей: &quot;имя сегментного регистра&quot;, &quot;имя сегмента&quot; из соответствующей директивы SEGMENT или &quot;имя группы&quot; (рис. 11). Этот момент очень важен, поэтому поясню его подробнее. При обсуждении сегментации мы говорили о том, что микропроцессор на аппаратном уровне поддерживает три типа сегментов - кода, стека и данных. В чем заключается такая аппаратная поддержка? К примеру, для выборки на выполнение очередной команды микропроцессор должен обязательно посмотреть содержимое сегментного регистра cs и только его. А в этом регистре, как мы знаем, содержится (пока еще не сдвинутый) физический адрес начала сегмента команд. Для получения адреса конкретной команды микропроцессору остается умножить содержимое cs на 16 (что означает сдвиг на четыре разряда) и сложить полученное 20-битное значение с 16-битным содержимым регистра ip. Примерно то же самое происходит и тогда, когда микропроцессор обрабатывает операнды в машинной команде. Если он видит, что операнд - это адрес (эффективный адрес, который является только частью физического адреса), то он знает, в каком сегменте его искать - по умолчанию это сегмент, адрес начала которого записан в сегментном регистре ds. А что же с сегментом стека? Посмотрите раздел &quot;Программная модель микропроцессора&quot;, там, где мы описывали назначение регистров общего назначения. В контексте нашего рассмотрения нас интересуют регистры sp и bp. Если микропроцессор видит в качестве операнда (или его части, если операнд - выражение) один из этих регистров, то по умолчанию он формирует физический адрес операнда используя в качестве его сегментной составляющей содержимое регистра ss. Что подразумевает термин &quot;по умолчанию&quot;? Вспомните &quot;рефлексы&quot;, о которых мы говорили на уроке 1. Это набор микропрограмм в блоке микропрограммного управления, каждая из которых выполняет одну из команд в системе машинных команд микропроцессора. Каждая микропрограмма работает по своему алгоритму. Изменить его, конечно же, нельзя, но можно чуть-чуть подкорректировать. Делается это с помощью необязательного поля префикса машинной команды (см. формат машинной команды). Если мы согласны с тем, как работает команда, то это поле отсутствует. Если же мы хотим внести поправку (если, конечно, она допустима для конкретной команды) в алгоритм работы команды, то необходимо сформировать соответствующий префикс. Префикс представляет собой однобайтовую величину, численное значение которой определяет ее назначение. Микропроцессор распознает по указанному значению, что этот байт является префиксом, и дальнейшая работа микропрограммы выполняется с учетом поступившего указания на корректировку ее работы. Сейчас нас интересует один из них - префикс замены (переопределения) сегмента. Его назначение состоит в том, чтобы указать микропроцессору (а по сути, микропрограмме) на то, что мы не хотим использовать сегмент по умолчанию. Возможности для подобного переопределения, конечно, ограничены. Сегмент команд переопределить нельзя, адрес очередной исполняемой команды однозначно определяется парой cs:ip. А вот сегменты стека и данных - можно. Для этого и предназначен оператор &quot;<b>:</b>&quot;. Транслятор ассемблера, обрабатывая этот оператор, формирует соответствующий однобайтовый префикс замены сегмента. Например, </li> </ul> </p><table border=0 cellspacing="0" cellpadding="0" align="center"> <tr> <td width=330 >.code . jmp met1 ;обход обязателен, иначе поле indбудет трактоваться ;как очередная командаind db 5 ;описание поля данных в сегменте командmet1: .mov al,cs:ind ;переопределение сегмента позволяет работать с ;данными, определенными внутри сегмента кода</td> </tr> </table> <ul > <li class=MsoNormal ><img border=0 width=461 height=200 src="http://referatbank.com.ua/images/76887_image018.gif"></li> <li class=MsoNormal ><b>Рис. 11. </b>Синтаксис оператора переопределения сегмента</li> <li class=MsoNormal >Оператор именования типа структуры <b>.</b> (точка) также заставляет транслятор производить определенные вычисления, если он встречается в выражении. </li> <li class=MsoNormal >Оператор получения сегментной составляющей адреса выражения <b>seg</b> возвращает физический адрес сегмента для выражения (рис. 12), в качестве которого могут выступать метка, переменная, имя сегмента, имя группы или некоторое символическое имя. </li> </ul> 
<p align="center">
<p><img border=0 width=200 height=32 src="http://referatbank.com.ua/images/76888_image019.gif"> 
<p><b>Рис. 12. </b>Синтаксис оператора получения сегментной составляющей <ul > <li class=MsoNormal >Оператор получения смещения выражения <b>offset</b> позволяет получить значение смещения выражения (рис. 13) в байтах относительно начала того сегмента, в котором выражение определено. </li> </ul> 
<p><img border=0 width=200 height=32 src="http://referatbank.com.ua/images/76888_image020.gif"> 
<p><b>Рис. 13. </b>Синтаксис оператора получения смещения 
<p>Например, </p><table border=0 cellspacing="0" cellpadding="0" align="center"> <tr> <td width=330 > .datapole dw 5 code . mov ax,seg pole mov es,ax mov dx,offset pole ;теперь в паре es:dx полный адрес pole</td> </tr> </table> 
<p>Как и в языках высокого уровня, выполнение операторов ассемблера при вычислении выражений осуществляется в соответствии с их приоритетами (см. табл. 2). Операции с одинаковыми приоритетами выполняются последовательно слева направо. Изменение порядка выполнения возможно путем расстановки круглых скобок, которые имеют наивысший приоритет. 
<p><b>Таблица 2. Операторы и их приоритет</b> </p><table border=0 cellspacing="0" cellpadding="0" align="center"> <tr> <td width=253 > 
<p>Оператор </td> <td width=81 > 
<p>Приоритет </td> </tr> <tr> <td width=253 > 
<p>length, size, width, mask, (, ), [, ], &lt;, &gt; </td> <td width=81 > 
<p>1 </td> </tr> <tr> <td width=253 > 
<p>. </td> <td width=81 > 
<p>2 </td> </tr> <tr> <td width=253 > 
<p>: </td> <td width=81 > 
<p>3 </td> </tr> <tr> <td width=253 > 
<p>ptr, offset, seg, type, this </td> <td width=81 > 
<p>4 </td> </tr> <tr> <td width=253 > 
<p>high, low </td> <td width=81 > 
<p>5 </td> </tr> <tr> <td width=253 > 
<p>+, - (унарные) </td> <td width=81 > 
<p>6 </td> </tr> <tr> <td width=253 > 
<p>*, /, mod, shl, shr </td> <td width=81 > 
<p>7 </td> </tr> <tr> <td width=253 > 
<p>+, -, (бинарные) </td> <td width=81 > 
<p>8 </td> </tr> <tr> <td width=253 > 
<p>eq, ne, lt, le, gt, ge </td> <td width=81 > 
<p>9 </td> </tr> <tr> <td width=253 > 
<p>not </td> <td width=81 > 
<p>10 </td> </tr> <tr> <td width=253 > 
<p>and </td> <td width=81 > 
<p>11 </td> </tr> <tr> <td width=253 > 
<p>or, xor </td> <td width=81 > 
<p>12 </td> </tr> <tr> <td width=253 > 
<p>short, type </td> <td width=81 > 
<p>13 </td> </tr> </table> 
<p><b>Директивы сегментации</b> 
<p>В ходе предыдущего обсуждения мы выяснили все основные правила записи команд и операндов в программе на ассемблере. Открытым остался вопрос о том, как правильно оформить последовательность команд, чтобы транслятор мог их обработать, а микропроцессор - выполнить. 
<p>При рассмотрении архитектуры микропроцессора мы узнали, что он имеет шесть сегментных регистров, посредством которых может одновременно работать: <ul > <li class=MsoNormal >с одним сегментом кода; </li> <li class=MsoNormal >с одним сегментом стека; </li> <li class=MsoNormal >с одним сегментом данных; </li> <li class=MsoNormal >с тремя дополнительными сегментами данных. </li> </ul> 
<p>Еще раз вспомним, что физически сегмент представляет собой область памяти, занятую командами и (или) данными, адреса которых вычисляются относительно значения в соответствующем сегментном регистре. 
<p>Синтаксическое описание сегмента на ассемблере представляет собой конструкцию, изображенную на рис. 14: 
<p><img border=0 width=692 height=250 src="http://referatbank.com.ua/images/76888_image021.gif"> 
<p><b>Рис. 14. </b>Синтаксис описания сегмента 
<p>Важно отметить, что функциональное назначение сегмента несколько шире, чем простое разбиение программы на блоки кода, данных и стека. Сегментация является частью более общего механизма, связанного с концепцией модульного программирования. Она предполагает унификацию оформления объектных модулей, создаваемых компилятором, в том числе с разных языков программирования. Это позволяет объединять программы, написанные на разных языках. Именно для реализации различных вариантов такого объединения и предназначены операнды в директиве <b>SEGMENT</b>. Рассмотрим их подробнее. <ul > <li class=MsoNormal ><b>Атрибут выравнивания сегмента</b> (тип выравнивания) сообщает компоновщику о том, что нужно обеспечить размещение начала сегмента на заданной границе. Это важно, поскольку при правильном выравнивании доступ к данным в процессорах i80х86 выполняется быстрее. Допустимые значения этого атрибута следующие: </li> <ul > <li class=MsoNormal ><b>BYTE</b> - выравнивание не выполняется. Сегмент может начинаться с любого адреса памяти; </li> <li class=MsoNormal ><b>WORD</b> - сегмент начинается по адресу, кратному двум, то есть последний (младший) значащий бит физического адреса равен 0 (выравнивание на границу слова); </li> <li class=MsoNormal ><b>DWORD</b> - сегмент начинается по адресу, кратному четырем, то есть два последних (младших) значащих бита равны 0 (выравнивание на границу двойного слова); </li> <li class=MsoNormal ><b>PARA</b> - сегмент начинается по адресу, кратному 16, то есть последняя шестнадцатеричная цифра адреса должна быть 0h (выравнивание на границу параграфа); </li> <li class=MsoNormal ><b>PAGE</b> - сегмент начинается по адресу, кратному 256, то есть две последние шестнадцатеричные цифры должны быть 00h (выравнивание на границу 256-байтной страницы); </li> <li class=MsoNormal ><b>MEMPAGE</b> - сегмент начинается по адресу, кратному 4 Кбайт, то есть три последние шестнадцатеричные цифры должны быть 000h (адрес следующей 4-Кбайтной страницы памяти). </li> </ul> </ul> 
<p>По умолчанию тип выравнивания имеет значение <b>PARA</b>. <ul > <li class=MsoNormal > </li> <li class=MsoNormal ><b>Атрибут комбинирования сегментов</b> (комбинаторный тип) сообщает компоновщику, как нужно комбинировать сегменты различных модулей, имеющие одно и то же имя. Значениями атрибута комбинирования сегмента могут быть: </li> <ul > <li class=MsoNormal ><b>PRIVATE</b> - сегмент не будет объединяться с другими сегментами с тем же именем вне данного модуля; </li> <li class=MsoNormal ><b>PUBLIC</b> - заставляет компоновщик соединить все сегменты с одинаковыми именами. Новый объединенный сегмент будет целым и непрерывным. Все адреса (смещения) объектов, а это могут быть, в зависимости от типа сегмента, команды и данные, будут вычисляться относительно начала этого нового сегмента; </li> <li class=MsoNormal ><b>COMMON</b> - располагает все сегменты с одним и тем же именем по одному адресу. Все сегменты с данным именем будут перекрываться и совместно использовать память. Размер полученного в результате сегмента будет равен размеру самого большого сегмента; </li> <li class=MsoNormal ><b>AT xxxx</b> - располагает сегмент по абсолютному адресу параграфа (параграф - объем памяти, кратный 16; поэтому последняя шестнадцатеричная цифра адреса параграфа равна 0). Абсолютный адрес параграфа задается выражением xxx. Компоновщик располагает сегмент по заданному адресу памяти (это можно использовать, например, для доступа к видеопамяти или области ПЗУ), учитывая атрибут комбинирования. Физически это означает, что сегмент при загрузке в память будет расположен, начиная с этого абсолютного адреса параграфа, но для доступа к нему в соответствующий сегментный регистр должно быть загружено заданное в атрибуте значение. Все метки и адреса в определенном таким образом сегменте отсчитываются относительно заданного абсолютного адреса; </li> <li class=MsoNormal ><b>STACK</b> - определение сегмента стека. Заставляет компоновщик соединить все одноименные сегменты и вычислять адреса в этих сегментах относительно регистра ss. Комбинированный тип STACK (стек) аналогичен комбинированному типу PUBLIC, за исключением того, что регистр ss является стандартным сегментным регистром для сегментов стека. Регистр sp устанавливается на конец объединенного сегмента стека. Если не указано ни одного сегмента стека, компоновщик выдаст предупреждение, что стековый сегмент не найден. Если сегмент стека создан, а комбинированный тип STACK не используется, программист должен явно загрузить в регистр ss адрес сегмента (подобно тому, как это делается для регистра ds). </li> </ul> </ul> 
<p align="center">
<p>По умолчанию атрибут комбинирования принимает значение <b>PRIVATE</b>. <ul > <li class=MsoNormal > </li> <li class=MsoNormal ><b>Атрибут класса сегмента</b> (тип класса) - это заключенная в кавычки строка, помогающая компоновщику определить соответствующий порядок следования сегментов при собирании программы из сегментов нескольких модулей. Компоновщик объединяет вместе в памяти все сегменты с одним и тем же именем класса (имя класса, в общем случае, может быть любым, но лучше, если оно будет отражать функциональное назначение сегмента). Типичным примером использования имени класса является объединение в группу всех сегментов кода программы (обычно для этого используется класс &quot;code&quot;). С помощью механизма типизации класса можно группировать также сегменты инициализированных и неинициализированных данных; </li> <li class=MsoNormal ><b>Атрибут размера сегмента</b>. Для процессоров i80386 и выше сегменты могут быть 16 или 32-разрядными. Это влияет, прежде всего, на размер сегмента и порядок формирования физического адреса внутри него. Атрибут может принимать следующие значения: </li> <ul > <li class=MsoNormal ><b>USE16</b> - это означает, что сегмент допускает 16-разрядную адресацию. При формировании физического адреса может использоваться только 16-разрядное смещение. Соответственно, такой сегмент может содержать до 64 Кбайт кода или данных; </li> <li class=MsoNormal ><b>USE32</b> - сегмент будет 32-разрядным. При формирования физического адреса может использоваться 32-разрядное смещение. Поэтому такой сегмент может содержать до 4 Гбайт кода или данных. </li> </ul> </ul> 
<p>Все сегменты сами по себе равноправны, так как директивы <b>SEGMENT</b> и <b>ENDS</b> не содержат информации о функциональном назначении сегментов. Для того чтобы использовать их как сегменты кода, данных или стека, необходимо предварительно сообщить транслятору об этом, для чего используют специальную директиву <b>ASSUME</b>, имеющую формат, показанный на рис. 15. Эта директива сообщает транслятору о том, какой сегмент к какому сегментному регистру привязан. В свою очередь, это позволит транслятору корректно связывать символические имена, определенные в сегментах. Привязка сегментов к сегментным регистрам осуществляется с помощью операндов этой директивы, в которых имя_сегмента должно быть именем сегмента, определенным в исходном тексте программы директивой <b>SEGMENT</b> или ключевым словом <b>nothing</b>. Если в качестве операнда используется только ключевое слово <b>nothing</b>, то предшествующие назначения сегментных регистров аннулируются, причем сразу для всех шести сегментных регистров. Но ключевое слово <b>nothing</b> можно использовать вместо аргумента имя сегмента; в этом случае будет выборочно разрываться связь между сегментом с именем имя сегмента и соответствующим сегментным регистром (см. рис. 15). 
<p><img border=0 width=32 height=32 src="http://referatbank.com.ua/images/76889_image014.gif"> 
<p><b>Рис. 15.</b> Директива ASSUME 
<p>На уроке 3 мы рассматривали пример программы с директивами сегментации. Эти директивы изначально использовались для оформления программы в трансляторах MASM и TASM. Поэтому их называют стандартными директивами сегментации. 
<p>Для простых программ, содержащих по одному сегменту для кода, данных и стека, хотелось бы упростить ее описание. Для этого в трансляторы MASM и TASM ввели возможность использования упрощенных директив сегментации. Но здесь возникла проблема, связанная с тем, что необходимо было как-то компенсировать невозможность напрямую управлять размещением и комбинированием сегментов. Для этого совместно с упрощенными директивами сегментации стали использовать директиву указания модели памяти <b>MODEL</b>, которая частично стала управлять размещением сегментов и выполнять функции директивы <b>ASSUME</b> (поэтому при использовании упрощенных директив сегментации директиву ASSUME можно не использовать). Эта директива связывает сегменты, которые в случае использования упрощенных директив сегментации имеют предопределенные имена, с сегментными регистрами (хотя явно инициализировать ds все равно придется). 
<p>В листинге 1 приведен пример программы с использованием упрощенных директив сегментации: </p><table border=0 cellspacing="0" cellpadding="0" align="center"> <tr> <td width=330 > Листинг 1. Использование упрощенных директив сегментации;---------Prg_3_1.asm-------------------------------masm ;режим работы TASM: ideal или masmmodel small ;модель памяти.data ;сегмент данныхmessage db "Введите две шестнадцатеричные цифры,$".stack ;сегмент стека db 256 dup ("?") ;сегмент стека.code ;сегмент кодаmain proc ;начало процедуры main mov ax,@data ;заносим адрес сегмента данных в регистр ax mov ds,ax ;ax в ds;далее текст программы (см. сегмента кода в листинге 3.1 книги) mov ax,4c00h ;пересылка 4c00h в регистр ax int 21h ;вызов прерывания с номером 21hmain endp ;конец процедуры mainend main ;конец программы с точкой входа main</td> </tr> </table> 
<p>Синтаксис директивы <b>MODEL</b> показан на рис. 16. 
<p><img border=0 width=711 height=90 src="http://referatbank.com.ua/images/76889_image022.gif"> 
<p><b>Рис. 16. </b>Синтаксис директивы MODEL 
<p>Обязательным параметром директивы MODEL является модель памяти. Этот параметр определяет модель сегментации памяти для программного модуля. Предполагается, что программный модуль может иметь только определенные типы сегментов, которые определяются упомянутыми нами ранее упрощенными директивами описания сегментов. Эти директивы приведены в табл. 3. 
<p><b>Таблица 3. Упрощенные директивы определения сегмента</b> </p><table border=0 cellspacing="0" cellpadding="0" align="center"> <tr> <td width=105 > 
<p>Формат директивы (режим MASM) </td> <td width=122 > 
<p>Формат директивы (режим IDEAL) </td> <td width=334 > 
<p>Назначение </td> </tr> <tr> <td width=105 > 
<p>.CODE [имя] </td> <td width=122 > 
<p>CODESEG[имя] </td> <td width=334 > 
<p>Начало или продолжение сегмента кода </td> </tr> <tr> <td width=105 > 
<p>.DATA </td> <td width=122 > 
<p>DATASEG </td> <td width=334 > 
<p>Начало или продолжение сегмента инициализированных данных. Также используется для определения данных типа near </td> </tr> <tr> <td width=105 > 
<p>.CONST </td> <td width=122 > 
<p>CONST </td> <td width=334 > 
<p>Начало или продолжение сегмента постоянных данных (констант) модуля </td> </tr> <tr> <td width=105 > 
<p>.DATA? </td> <td width=122 > 
<p>UDATASEG </td> <td width=334 > 
<p>Начало или продолжение сегмента неинициализированных данных. Также используется для определения данных типа near </td> </tr> <tr> <td width=105 > 
<p>.STACK [размер] </td> <td width=122 > 
<p>STACK [размер] </td> <td width=334 > 
<p>Начало или продолжение сегмента стека модуля. Параметр [размер] задает размер стека </td> </tr> <tr> <td width=105 > 
<p>.FARDATA [имя] </td> <td width=122 > 
<p>FARDATA [имя] </td> <td width=334 > 
<p>Начало или продолжение сегмента инициализированных данных типа far </td> </tr> <tr> <td width=105 > 
<p>.FARDATA? [имя] </td> <td width=122 > 
<p>UFARDATA [имя] </td> <td width=334 > 
<p>Начало или продолжение сегмента неинициализированных данных типа far </td> </tr> </table> 
<p>Наличие в некоторых директивах параметра <b>[имя]</b> говорит о том, что возможно определение нескольких сегментов этого типа. С другой стороны, наличие нескольких видов сегментов данных обусловлено требованием обеспечить совместимость с некоторыми компиляторами языков высокого уровня, которые создают разные сегменты данных для инициализированных и неинициализированных данных, а также констант. 
<p>При использовании директивы <b>MODEL</b> транслятор делает доступными несколько идентификаторов, к которым можно обращаться во время работы программы, с тем, чтобы получить информацию о тех или иных характеристиках данной модели памяти (см. табл. 5). Перечислим эти идентификаторы и их значения (табл. 4). Таблица 4. Идентификаторы, создаваемые директивой MODEL </p><table border=0 cellspacing="0" cellpadding="0" align="center"> <tr> <td width=145 > 
<p>Имя идентификатора </td> <td width=416 > 
<p>Значение переменной </td> </tr> <tr> <td width=145 > 
<p>@code </td> <td width=416 > 
<p>Физический адрес сегмента кода </td> </tr> <tr> <td width=145 > 
<p>@data </td> <td width=416 > 
<p>Физический адрес сегмента данных типа near </td> </tr> <tr> <td width=145 > 
<p>@fardata </td> <td width=416 > 
<p>Физический адрес сегмента данных типа far </td> </tr> <tr> <td width=145 > 
<p>@fardata? </td> <td width=416 > 
<p>Физический адрес сегмента неинициализированных данных типа far </td> </tr> <tr> <td width=145 > 
<p>@curseg </td> <td width=416 > 
<p>Физический адрес сегмента неинициализированных данных типа far </td> </tr> <tr> <td width=145 > 
<p>@stack </td> <td width=416 > 
<p>Физический адрес сегмента стека </td> </tr> </table><p align="center">
<p>Если вы посмотрите на текст листинга 1, то увидите пример использования одного из этих идентификаторов. Это <b>@data</b>; с его помощью мы получили значение физического адреса сегмента данных нашей программы. 
<p>Теперь можно закончить обсуждение директивы <b>MODEL</b>. Операнды директивы <b>MODEL</b> используют для задания модели памяти, которая определяет набор сегментов программы, размеры сегментов данных и кода, способ связывания сегментов и сегментных регистров. В табл. 5 приведены некоторые значения параметра модель памяти директивы <b>MODEL</b>. Таблица 5. Модели памяти </p><table border=0 cellspacing="0" cellpadding="0" align="center"> <tr> <td width=84 > 
<p>Модель </td> <td width=51 > 
<p>Тип кода </td> <td width=71 > 
<p>Тип данных </td> <td width=356 > 
<p>Назначение модели </td> </tr> <tr> <td width=84 > 
<p>TINY </td> <td width=51 > 
<p>near </td> <td width=71 > 
<p>near </td> <td width=356 > 
<p>Код и данные объединены в одну группу с именем DGROUP. Используется для создания программ формата .com. </td> </tr> <tr> <td width=84 > 
<p>SMALL </td> <td width=51 > 
<p>near </td> <td width=71 > 
<p>near </td> <td width=356 > 
<p>Код занимает один сегмент, данные объединены в одну группу с именем DGROUP. Эту модель обычно используют для большинства программ на ассемблере </td> </tr> <tr> <td width=84 > 
<p>MEDIUM </td> <td width=51 > 
<p>far </td> <td width=71 > 
<p>near </td> <td width=356 > 
<p>Код занимает несколько сегментов, по одному на каждый объединяемый программный модуль. Все ссылки на передачу управления - типа far. Данные объединены в одной группе; все ссылки на них - типа near </td> </tr> <tr> <td width=84 > 
<p>COMPACT </td> <td width=51 > 
<p>near </td> <td width=71 > 
<p>far </td> <td width=356 > 
<p>Код в одном сегменте; ссылка на данные - типа far </td> </tr> <tr> <td width=84 > 
<p>LARGE </td> <td width=51 > 
<p>far </td> <td width=71 > 
<p>far </td> <td width=356 > 
<p>Код в нескольких сегментах, по одному на каждый объединяемый программный модуль </td> </tr> </table> 
<p>Параметр модификатор директивы <b>MODEL</b> позволяет уточнить некоторые особенности использования выбранной модели памяти (табл. 6). Таблица 6. Модификаторы модели памяти </p><table border=0 cellspacing="0" cellpadding="0" align="center"> <tr> <td width=132 > 
<p>Значение модификатора </td> <td width=430 > 
<p>Назначение </td> </tr> <tr> <td width=132 > 
<p>use16 </td> <td width=430 > 
<p>Сегменты выбранной модели используются как 16-битные (если соответствующей директивой указан процессор i80386 или i80486) </td> </tr> <tr> <td width=132 > 
<p>use32 </td> <td width=430 > 
<p>Сегменты выбранной модели используются как 32-битные (если соответствующей директивой указан процессор i80386 или i80486) </td> </tr> <tr> <td width=132 > 
<p>dos </td> <td width=430 > 
<p>Программа будет работать в MS-DOS </td> </tr> </table> 
<p>Необязательные параметры язык и модификатор языка определяют некоторые особенности вызова процедур. Необходимость в использовании этих параметров появляется при написании и связывании программ на различных языках программирования. 
<p>Описанные нами стандартные и упрощенные директивы сегментации не исключают друг друга. Стандартные директивы используются, когда программист желает получить полный контроль над размещением сегментов в памяти и их комбинированием с сегментами других модулей. <b>Упрощенные директивы</b> целесообразно использовать для простых программ и программ, предназначенных для связывания с программными модулями, написанными на языках высокого уровня. Это позволяет компоновщику эффективно связывать модули разных языков за счет стандартизации связей и управления. 
<p></td></tr></table>
 <br><br>
<table border="0" width="640" cellpadding="20" cellspacing="1" style="border: 1px dashed #585858;" align=center><tr><td>
Банк рефератів: <a href="http://textreferat.com.ua" target="_blank">http://textreferat.com.ua</a>  <br>
 <br>Завантажено з <a href="http://textreferat.com.ua/referat2.php?id=7669" target="_blank">http://textreferat.com.ua/referat2.php?id=7669</a> 
</td></tr></table>
</body></html>