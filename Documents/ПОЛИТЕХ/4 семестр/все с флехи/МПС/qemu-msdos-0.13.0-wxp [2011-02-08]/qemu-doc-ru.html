<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html><head><!-- Created on March, 19 2006 by texi2html 1.76 --><!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

--><title>Документация пользователя эмулятора процессора QEMU</title>






<meta name="description" content="Документация пользователя эмулятора процессора QEMU">
<meta name="keywords" content="Документация пользователя эмулятора процессора QEMU">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style></head><body alink="#ff0000" bgcolor="#ffffff" lang="ru" link="#0000ff" text="#000000" vlink="#800080">

<h1>Документация пользователя эмулятора процессора QEMU</h1>
<p><i>ПЕРЕВОД: Павел Марьянов &lt;<a href="mailto:acid_jack@ukr.net">acid_jack@ukr.net</a>&gt;, март 2006</i>
</p>
<hr>
<h1>Содержание</h1>
<div class="contents">

<ul class="toc">
  <li><a name="TOC1" href="#SEC1">1. Введение</a>
  <ul class="toc">
    <li><a name="TOC2" href="#SEC2">1.1 Возможности</a></li>
  </ul></li>
  <li><a name="TOC3" href="#SEC3">2. Установка</a>
  <ul class="toc">
    <li><a name="TOC4" href="#SEC4">2.1 Linux</a></li>
    <li><a name="TOC5" href="#SEC5">2.2 Windows</a></li>
    <li><a name="TOC6" href="#SEC6">2.3 Mac OS X</a></li>
  </ul></li>
  <li><a name="TOC7" href="#SEC7">3. Запуск QEMU в качестве эмулятора системы типа PC</a>
  <ul class="toc">
    <li><a name="TOC8" href="#SEC8">3.1 Введение</a></li>
    <li><a name="TOC9" href="#SEC9">3.2 Быстрый запуск</a></li>
    <li><a name="TOC10" href="#SEC10">3.3 Запуск</a></li>
    <li><a name="TOC11" href="#SEC11">3.4 Клавиши</a></li>
    <li><a name="TOC12" href="#SEC12">3.5 Монитор QEMU</a>
    <ul class="toc">
      <li><a name="TOC13" href="#SEC13">3.5.1 Команды</a></li>
      <li><a name="TOC14" href="#SEC14">3.5.2 Целочисленные выражения</a></li>
    </ul></li>
    <li><a name="TOC15" href="#SEC15">3.6 Образы дисков</a>
    <ul class="toc">
      <li><a name="TOC16" href="#SEC16">3.6.1 Быстрое создание образа диска</a></li>
      <li><a name="TOC17" href="#SEC17">3.6.2 Режим snapshot</a></li>
      <li><a name="TOC18" href="#SEC18">3.6.3 Запуск <code>qemu-img</code></a></li>
    </ul></li>
    <li><a name="TOC19" href="#SEC19">3.7 Эмуляция сети</a>
    <ul class="toc">
      <li><a name="TOC20" href="#SEC20">3.7.1 Использование сетевого интерфейса tun/tap</a></li>
      <li><a name="TOC21" href="#SEC21">3.7.2 Использование сетевого стека в режиме пользователя</a></li>
    </ul></li>
    <li><a name="TOC22" href="#SEC22">3.8 Непосредственная загрузка Linux</a></li>
    <li><a name="TOC23" href="#SEC23">3.9 Использование GDB</a></li>
    <li><a name="TOC24" href="#SEC24">3.10 Дополнительная информация по эмулируемой ОС</a>
    <ul class="toc">
      <li><a name="TOC25" href="#SEC25">3.10.1 Linux</a></li>
      <li><a name="TOC26" href="#SEC26">3.10.2 Windows</a>
      <ul class="toc">
        <li><a name="TOC27" href="#SEC27">3.10.2.1 Поддержка графических режимов SVGA</a></li>
        <li><a name="TOC28" href="#SEC28">3.10.2.2 Снижение загрузки процессора</a></li>
        <li><a name="TOC29" href="#SEC29">3.10.2.3 Проблема с переполнением диска в Windows 2000</a></li>
        <li><a name="TOC30" href="#SEC30">3.10.2.4 Завершение работы Windows 2000</a></li>
        <li><a name="TOC31" href="#SEC31">3.10.2.5 Использование общих каталогов для Unix и Windows</a></li>
        <li><a name="TOC32" href="#SEC32">3.10.2.6 Проблемы с безопасностью в Windows XP</a></li>
      </ul></li>
      <li><a name="TOC33" href="#SEC33">3.10.3 MS-DOS и FreeDOS</a>
      <ul class="toc">
        <li><a name="TOC34" href="#SEC34">3.10.3.1 Снижение загрузки процессора</a></li>
      </ul>
</li>
    </ul>
</li>
  </ul></li>
  <li><a name="TOC35" href="#SEC35">4. Запуск QEMU в качестве эмулятора системы типа PowerPC</a></li>
  <li><a name="TOC36" href="#SEC36">5. Запуск QEMU в качестве эмулятора системы типа Sparc32</a></li>
  <li><a name="TOC37" href="#SEC37">6. Запуск QEMU в качестве эмулятора системы типа Sparc64</a></li>
  <li><a name="TOC38" href="#SEC38">7. Запуск QEMU в качестве эмулятора системы типа MIPS</a></li>
  <li><a name="TOC39" href="#SEC39">8. Запуск QEMU в качестве эмулятора пользовательского пространства</a>
  <ul class="toc">
    <li><a name="TOC40" href="#SEC40">8.1 Быстрый запуск</a></li>
    <li><a name="TOC41" href="#SEC41">8.2 Запуск Wine</a></li>
    <li><a name="TOC42" href="#SEC42">8.3 Опции командной строки</a></li>
  </ul></li>
  <li><a name="TOC43" href="#SEC43">9. Компиляция из исходного кода</a>
  <ul class="toc">
    <li><a name="TOC44" href="#SEC44">9.1 Linux/Unix</a>
    <ul class="toc">
      <li><a name="TOC45" href="#SEC45">9.1.1 Компиляция</a></li>
      <li><a name="TOC46" href="#SEC46">9.1.2 Версии проверенных утилит</a></li>
    </ul></li>
    <li><a name="TOC47" href="#SEC47">9.2 Windows</a></li>
    <li><a name="TOC48" href="#SEC48">9.3 Кросс-компиляция в Linux для Windows</a></li>
    <li><a name="TOC49" href="#SEC49">9.4 Mac OS X</a></li>
  </ul>
</li>
</ul>
</div>
<hr>
<a name="SEC_About"></a>
<table border="0" cellpadding="1" cellspacing="1">
<tbody><tr><td align="left" valign="middle">[<a href="#SEC1" title="Cover (top) of document">Top</a>]</td>
<td align="left" valign="middle">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td align="left" valign="middle">[Index]</td>
<td align="left" valign="middle">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></tbody></table>

<a name="SEC1"></a>
<h1 class="chapter"> <a href="#TOC1">1. Введение</a> </h1>


<a name="SEC2"></a>
<h2 class="section"> <a href="#TOC2">1.1 Возможности</a> </h2>

<p>QEMU - это БЫСТРЫЙ! эмулятор процессора, использующий динамическую трансляцию для достижения хорошей скорости эмуляции.
</p>
<p>QEMU имеет два режима работы:
</p>
<ul class="toc">
<li>-
Эмуляция всей системы. В этом режиме QEMU эмулирует полноценную систему
(например ПК), включая процессор и различное периферийное оборудование.
Его можно использовать для запуска различных операционных систем без
необходимости перезагрузки ПК или для отладки кода системы.
</li><li>-
Эмуляция пользовательского режима (только Linux-машины). В этом режиме
QEMU может запускать процессы Linux, скомпилированные для одного
процессора, на другом процессоре. Его можно использовать для запуска
Wine - эмулятора API Windows (<a href="http://www.winehq.org/">http://www.winehq.org</a>), или для упрощённой кросс-компиляции и кросс-отладки.

</li></ul>

<p>QEMU может работать на системе-хозяине без драйвера, обеспечивая при этом удовлетворительную производительность.
</p>
<p>При эмуляции целой системы поддерживается следующее оборудование:
</p><ul class="toc">
<li> PC (процессор x86 или x86_64)
</li><li> PREP (процессор PowerPC)
</li><li> G3 BW PowerMac (процессор PowerPC)
</li><li> Mac99 PowerMac (процессор PowerPC, в процессе разработки)
</li><li> Sun4m (32-битный процессор Sparc)
</li><li> Sun4u (64-битный процессор Sparc processor, в процессе разработки)
</li><li> Malta board (32-битный процессор MIPS, в процессе разработки)
</li></ul>

<p>При эмуляции пользователя поддерживаются процессоры x86, PowerPC, ARM и Sparc32/64.
</p>

<a name="SEC3"></a>
<h1 class="chapter"> <a href="#TOC3">2. Установка</a> </h1>

<p>Если вы хотите самостоятельно скомпилировать QEMU, обратитесь к <a href="#SEC43">compilation</a>.
</p>

<a name="SEC4"></a>
<h2 class="section"> <a href="#TOC4">2.1 Linux</a> </h2>

<p>Если для вашего дистрибутива есть пакет с уже откомпилированными
бинарными файлами - вам нужно просто установить их. В противном случае
см. <a href="#SEC43">compilation</a>.
</p>

<a name="SEC5"></a>
<h2 class="section"> <a href="#TOC5">2.2 Windows</a> </h2>

<p>Экспериментальный бинарный инсталлятор можно загрузить с <a href="http://www.free.oszoo.org/download.php">http://www.free.oszoo.org/download.php</a>.
</p>

<a name="SEC6"></a>
<h2 class="section"> <a href="#TOC6">2.3 Mac OS X</a> </h2>

<p>Экспериментальный бинарный инсталлятор можно загрузить с
<a href="http://www.freeoszoo.org/download.php">http://www.freeoszoo.org/download.php</a>.
</p>

<a name="SEC7"></a>
<h1 class="chapter"> <a href="#TOC7">3. Запуск QEMU в качестве эмулятора системы типа PC</a> </h1>


<a name="SEC8"></a>
<h2 class="section"> <a href="#TOC8">3.1 Введение</a> </h2>


<p>Как эмулятор системы QEMU эмулирует следующее периферийное оборудование:
</p>
<ul class="toc">
<li>-
i440FX host PCI bridge и PIIX3 PCI to ISA bridge
</li><li>-
PCI VGA-карту Cirrus CLGD 5446 или фиктивную VGA-карту с
VESA-расширениями Bochs (аппаратный уровень, включая все нестандартные
режимы).
</li><li>-
PS/2-мышь и клавиатуру
</li><li>-
2 PCI IDE-интерфейса с поддержкой жёстких и приводов CD-ROM
</li><li>-
дисковод
</li><li>-
сетевые PCI-адаптеры NE2000
</li><li>-
последовательные порты
</li><li>-
звуковую карту Soundblaster 16
</li></ul>

<p>QEMU использует PC BIOS проекта Bochs и Plex86/Bochs LGPL VGA BIOS.
</p>


<a name="SEC9"></a>
<h2 class="section"> <a href="#TOC9">3.2 Быстрый запуск</a> </h2>

<p>Загрузите и распакуйте образ linux (<tt>`linux.img'</tt>), а затем наберите:
</p>
<table><tbody><tr><td>&nbsp;</td><td><pre class="example">qemu linux.img
</pre></td></tr></tbody></table>
<p>Должен загрузиться Linux, предоставив вам строку приглашения.
</p>

<a name="sec_005finvocation"></a>
<a name="SEC10"></a>
<h2 class="section"> <a href="#TOC10">3.3 Запуск</a> </h2>

<table><tbody><tr><td>&nbsp;</td><td><pre class="example">использование: qemu [опции] [образ_диска]
</pre></td></tr></tbody></table>
<p><var>disk_image</var> - это "сырой" образ жёсткого диска,
соответствующий нулевому жёсткому IDE-диску.
</p>
<p>Общие параметры:
</p><dl compact="compact">
<dt> <samp>`-fda файл'</samp></dt>
<dt> <samp>`-fdb файл'</samp></dt>
<dd><p>Здесь <var>файл</var> - образ дискеты для дисковода 0/1 соответственно (See <a href="#SEC15">Образы дисков</a>.). Вы можете использовать дискету системы-хозяина, указав <tt>`/dev/fd0'</tt> в качестве файла.
</p>
</dd>
<dt> <samp>`-hda файл'</samp></dt>
<dt> <samp>`-hdb файл'</samp></dt>
<dt> <samp>`-hdc файл'</samp></dt>
<dt> <samp>`-hdd файл'</samp></dt>
<dd><p>Здесь <var>файл</var> - образ жёсткого диска 0, 1, 2 или 3 соответственно (See <a href="#SEC15">Образы дисков</a>.).
</p>
</dd>
<dt> <samp>`-cdrom файл'</samp></dt>
<dd><p>Здесь <var>file</var> - образ CD-ROM (вы не можете одновременно использовать <samp>`-hdc'</samp> и <samp>`-cdrom'</samp>). Вы можете использовать CD-ROM системы-хозяина, указав <tt>`/dev/cdrom'</tt> в качестве файла.
</p>
</dd>
<dt> <samp>`-boot [a|c|d]'</samp></dt>
<dd><p>Загрузка с дискеты (a), жёсткого диска (c) или CD-ROM (d). По умолчанию выполняется загрузка с жёсткого диска.
</p>
</dd>
<dt> <samp>`-snapshot'</samp></dt>
<dd><p>Запись во временный файл, а не в файл образа жёсткого диска. В
этом случае образ "сырого" диска остаётся нетронутым. Однако вы можете
принудительно включить запись, нажав клавиши <kbd>C-a s</kbd> (See <a href="#SEC15">Образы дисков</a>.).
</p>
</dd>
<dt> <samp>`-m megs'</samp></dt>
<dd><p>Устанавливает объём виртуальной памяти в <var>megs</var> мегабайт. По умолчанию он составляет 128 МБ.
</p>
</dd>
<dt> <samp>`-nographic'</samp></dt>
<dd>
<p>Обычно QEMU использует SDL для вывода VGA-данных. Используя эту
опцию, вы можете вообще отключить графический вывод, сделав, таким
образом, QEMU простым консольным приложением. Эмулируемый
последовательный порт перенаправляется в консоль. Зато вы так вы можете
использовать QEMU для отладки ядра Linux, имея в своём распоряжении
последовательную консоль.
</p>
</dd>
<dt> <samp>`-k язык'</samp></dt>
<dd>
<p>Использование раскладки клавиатуры для данного <var>языка</var> (например <code>ru</code>
для русского). Эта опция нужна только в тех случаях, когда трудно
получить "сырые" коды клавиш (напр., на Mac'ах или в некоторых серверах
X11). Вам не нужно использовать её на машинах PC/Linux или PC/Windows.
</p>
<p>Доступны следующие раскладки:
</p><table><tbody><tr><td>&nbsp;</td><td><pre class="example">ar  de-ch  es  fo     fr-ca  hu  ja  mk     no  pt-br  sv
da  en-gb  et  fr     fr-ch  is  lt  nl     pl  ru     th
de  en-us  fi  fr-be  hr     it  lv  nl-be  pt  sl     tr
</pre></td></tr></tbody></table>
<p>По умолчанию используется раскладка <code>en-us</code>.
</p>
</dd>
<dt> <samp>`-enable-audio'</samp></dt>
<dd>
<p>По умолчанию эмуляция SB16 отключена, поскольку она может вызвать
некоторые проблемы у Windows. Вы можете включить её вручную с помощью
этой опции.
</p>
</dd>
<dt> <samp>`-localtime'</samp></dt>
<dd><p>Настраивает часы реального времени согласно локальному времени
(по умолчанию в UTC). Эта опция нужна для обеспечения правильного
времени в MS-DOS или Windows.
</p>
</dd>
<dt> <samp>`-full-screen'</samp></dt>
<dd><p>Запуск в полноэкранном режиме.
</p>
</dd>
<dt> <samp>`-pidfile файл'</samp></dt>
<dd><p>Сохраняет идентификатор процесса QEMU в <var>файл</var>. Полезно, если вы запускаете QEMU из скрипта.
</p>
</dd>
<dt> <samp>`-win2k-hack'</samp></dt>
<dd><p>Используйте эту опцию при установке Windows 2000, чтобы
предотвратить ошибку переполнения диска. После установки Windows 2000,
вам больше не нужно использовать эту опцию (она замедляет передачу
данных по IDE).
</p>
</dd>
</dl>

<p>Сетевые опции:
</p>
<dl compact="compact">
<dt> <samp>`-n скрипт'</samp></dt>
<dd><p>Задаёт скрипт инициализации сети TUN/TAP
[default=/etc/qemu-ifup]. Этот скрипт запускается для настройки
сетевого интерфейса системы-хозяина (обычно tun0), соответствующего
виртуальной сетевой карте NE2000.
</p>
</dd>
<dt> <samp>`-nics n'</samp></dt>
<dd>
<p>Эмуляция <var>n</var>-ого числа сетевых карт (по умолчанию 1).
</p>
</dd>
<dt> <samp>`-macaddr адрес'</samp></dt>
<dd>
<p>Задаёт mac-адрес первого интерфейса (в hex-формате типа
aa:bb:cc:dd:ee:ff). Mac-адрес увеличивается для каждого нового сетевого
интерфейса.
</p>
</dd>
<dt> <samp>`-tun-fd fd'</samp></dt>
<dd><p>Подразумевает, что <var>fd</var> общается с сетевым интерфейсом tap/tun системы-хозяина и использует его. Примеры использования опции смотрите на сайте <a href="http://bellard.org/qemu/tetrinet.html">http://bellard.org/qemu/tetrinet.html</a>.
</p>
</dd>
<dt> <samp>`-user-net'</samp></dt>
<dd><p>Использование сетевого стека в режиме пользователя. Используется по умолчанию, если не найден скрипт инициализации сети tun/tap.
</p>
</dd>
<dt> <samp>`-tftp префикс'</samp></dt>
<dd><p>При использовании сетевого стека в режиме пользователя активирует встроенный сервер TFTP. Все файлы, начинающиеся с <var>префикса</var>,
могут быть загружены с системы-хозяина в гостевую систему с помощью
клиента TFTP. Клиент TFTP в гостевой системе должен быть настроен на
двоичный режим передачи данных (используйте команду <code>bin</code> для TFTP-клиента для Unix). IP-адресом системы-хозяина обычно выступает 10.0.2.2.
</p>
</dd>
<dt> <samp>`-smb каталог'</samp></dt>
<dd><p>При использовании сетевого стека в режиме пользователя
активирует встроенный сервер SMB, чтобы Windows-системы могли иметь
прозрачный доступ к файлам системы-хозяина, находящимся в указанном <tt>`каталоге'</tt>.
</p>
<p>В гостевой ОС Windows нужно добавить строку:
</p><table><tbody><tr><td>&nbsp;</td><td><pre class="example">10.0.2.4 smbserver
</pre></td></tr></tbody></table><p>в файл <tt>`C:\WINDOWS\LMHOSTS'</tt> (для Windows 9x/Me) или <tt>`C:\WINNT\SYSTEM32\DRIVERS\ETC\LMHOSTS'</tt> (Windows NT/2000).
</p>
<p>Тогда доступ к <tt>`каталогу'</tt> можно получить через <tt>`\\smbserver\qemu'</tt>.
</p>
<p>Учтите, что на системе-хозяине должен быть установлен сервер SAMBA как <tt>`/usr/sbin/smbd'</tt>. QEMU был успешно протестирован с smbd версии 2.2.7a из Red Hat 9 и версии 3.0.10-1.fc3 из Fedora Core 3.
</p>
</dd>
<dt> <samp>`-redir [tcp|udp]:порт_хозяина:[гость_хозяина]:порт_гостя'</samp></dt>
<dd>
<p>При использовании сетевого стека в режиме пользователя перенаправляет TCP- или UDP-подключения, входящие в <var>порт_хозяина</var>, на <var>гостя_хозяина</var> в <var>порт_гостя</var>. Если <var>гость_хозяина</var> не указан, используется 10.0.2.15 (адрес, выдаваемый по умолчанию встроенным сервером DHCP).
</p>
<p>Например, чтобы перенаправить подключение X11 хозяина с экрана 1 на экран 0 гостя, используйте следующие команды:
</p>
<table><tbody><tr><td>&nbsp;</td><td><pre class="example"># на хозяине
qemu -redir tcp:6001::6000 [...]
# теперь xterm хозяина должен открыться на гостевом сервере X11
xterm -display :1
</pre></td></tr></tbody></table>
<p>Чтобы перенаправить telnet-подключение к порту 5555 хозяина на telnet'овский порт гостя, используйте следующие команды:
</p>
<table><tbody><tr><td>&nbsp;</td><td><pre class="example"># на хозяине
qemu -redir tcp:5555::23 [...]
telnet localhost 5555
</pre></td></tr></tbody></table>
<p>Далее, если вы запустите <code>telnet localhost 5555</code>, вы подключитесь к telnet-серверу гостя.
</p>
</dd>
<dt> <samp>`-dummy-net'</samp></dt>
<dd><p>Использование фиктивного сетевого стека: сетевыми картами не будет получено ни одного пакета.
</p>
</dd>
</dl>

<p>Загрузка Linux. С помощью этих опций вы можете использовать заданное
ядро Linux, не устанавливая его на образ диска. Это может быть полезным
для раннего тестирования различных ядер.
</p>
<dl compact="compact">
<dt> <samp>`-kernel bzImage'</samp></dt>
<dd><p>Использование <var>bzImage</var> в качестве образа ядра.
</p>
</dd>
<dt> <samp>`-append cmdline'</samp></dt>
<dd><p>Использование <var>cmdline</var> в качестве командной строки ядра.
</p>
</dd>
<dt> <samp>`-initrd файл'</samp></dt>
<dd><p>Использование <var>файл</var> в качестве исходного ram-диска.
</p>
</dd>
</dl>

<p>Отладочные/экспертные опции:
</p><dl compact="compact">
<dt> <samp>`-serial dev'</samp></dt>
<dd><p>Перенаправление виртуального последовательного порта в устройство <var>dev</var> системы-хозяина. Доступные устройства:
</p><dl compact="compact">
<dt> <code>vc</code></dt>
<dd><p>виртуальная консоль
</p></dd>
<dt> <code>pty</code></dt>
<dd><p>[только для Linux] Pseudo TTY (новый PTY выделяется автоматически)
</p></dd>
<dt> <code>null</code></dt>
<dd><p>устройство void
</p></dd>
<dt> <code>stdio</code></dt>
<dd><p>[только для Unix] стандартный ввод/вывод
</p></dd>
</dl>
<p>Стандартным устройством в графическом режиме является <code>vc</code>, а в неграфическом - <code>stdio</code>.
</p>
<p>Эту опцию можно использовать многократно для эмуляции до четырёх последовательных портов.
</p>
</dd>
<dt> <samp>`-monitor dev'</samp></dt>
<dd><p>Перенаправление монитора в устройство <var>dev</var>
системы-хозяина (те же самые устройства, что и для последовательных
портов). Стандартным устройством в графическом режиме является <code>vc</code>, а в неграфическом - <code>stdio</code>.
</p>
</dd>
<dt> <samp>`-s'</samp></dt>
<dd><p>Ожидание подключения gdb к порту 1234 (See <a href="#SEC23">Использование GDB</a>.).
</p></dd>
<dt> <samp>`-p порт'</samp></dt>
<dd><p>Изменение порта подключения gdb.
</p></dd>
<dt> <samp>`-S'</samp></dt>
<dd><p>Не запускать процессор при запуске (вы должны ввести 'c' в мониторе).
</p></dd>
<dt> <samp>`-d'</samp></dt>
<dd><p>Выводить журнал событий в /tmp/qemu.log.
</p></dd>
<dt> <samp>`-hdachs c,h,s,[,t]'</samp></dt>
<dd><p>Принудительно использовать физическую геометрию жёсткого диска 0 (1 &lt;= <var>c</var> &lt;= 16383, 1 &lt;= <var>h</var> &lt;= 16, 1 &lt;= <var>s</var> &lt;= 63) и опционально устанавливать принудительный режим передачи данных BIOS (<var>t</var>=none, lba или auto). Обычно QEMU может сам определить все эти параметры. Эта опция полезна для образов дисков старого MS-DOS.
</p>
</dd>
<dt> <samp>`-isa'</samp></dt>
<dd><p>Эмуляция системы только с ISA (по умолчанию эмулируется система с PCI).
</p></dd>
<dt> <samp>`-std-vga'</samp></dt>
<dd><p>Эмуляция стандартной VGA-карты с VBE-расширениями Bochs (по умолчанию эмулируется PCI VGA Cirrus Logic GD5446)
</p></dd>
<dt> <samp>`-loadvm файл'</samp></dt>
<dd><p>Запуск из сохранённого ранее состояния (<code>loadvm</code> в мониторе)
</p></dd>
</dl>



<a name="SEC11"></a>
<h2 class="section"> <a href="#TOC11">3.4 Клавиши</a> </h2>


<p>Во время графической эмуляции вы можете использовать следующие клавиши:
</p><dl compact="compact">
<dt> <kbd>Ctrl-Alt-f</kbd></dt>
<dd><p>Переключение в полноэкранный режим.
</p>
</dd>
<dt> <kbd>Ctrl-Alt-n</kbd></dt>
<dd><p>Переключение в виртуальную. консоль 'n'. Стандартными консолями могут быть:
</p><dl compact="compact">
<dt> <em>1</em></dt>
<dd><p>дисплей системы назначения
</p></dd>
<dt> <em>2</em></dt>
<dd><p>монитор
</p></dd>
<dt> <em>3</em></dt>
<dd><p>последовательный порт
</p></dd>
</dl>

</dd>
<dt> <kbd>Ctrl-Alt</kbd></dt>
<dd><p>Переключение захвата клавиатуры и мыши.
</p></dd>
</dl>

<p>В виртуальных консолях вы можете использовать сочетания клавиш <kbd>Ctrl-Up</kbd>,
<kbd>Ctrl-Down</kbd>, <kbd>Ctrl-PageUp</kbd> и <kbd>Ctrl-PageDown</kbd> для перемещения по
журналу сообщений.
</p>
<p>Во время эмуляции, если вы используете опцию <samp>`-nographic'</samp>, нажмите
используйте <kbd>Ctrl-a h</kbd>, чтобы можно было вызвать в терминале следующие
команды:
</p>
<dl compact="compact">
<dt> <kbd>Ctrl-a h</kbd></dt>
<dd><p>Вывод этой справки.
</p></dd>
<dt> <kbd>Ctrl-a x</kbd></dt>
<dd><p>Выход из эмулятора.
</p></dd>
<dt> <kbd>Ctrl-a s</kbd></dt>
<dd><p>Сохранение данных диска в файл (если используется -snapshot).
</p></dd>
<dt> <kbd>Ctrl-a b</kbd></dt>
<dd><p>Отправка break (magic sysrq в Linux).
</p></dd>
<dt> <kbd>Ctrl-a c</kbd></dt>
<dd><p>Переключение между консолью и монитором.
</p></dd>
<dt> <kbd>Ctrl-a Ctrl-a</kbd></dt>
<dd><p>Отправка комбинации клавиш Ctrl-a.
</p></dd>
</dl>


<a name="SEC12"></a>
<h2 class="section"> <a href="#TOC12">3.5 Монитор QEMU</a> </h2>

<p>Монитор QEMU используется для выполнения сложных команд в эмуляторе QEMU. Вы
можете использовать его для:
</p>
<ul class="toc">
<li>-
извлечения или вставки образов съёмных накопителей (таких как CD-ROM или
дисководов);

</li><li>-
"замораживать"/"размораживать" виртуальную машину (ВМ) и сохранять или
восстанавливать её состояние из файла на диске;

</li><li>-
изучать состояние ВМ без необходимости использования внешнего отладчика.

</li></ul>


<a name="SEC13"></a>
<h3 class="subsection"> <a href="#TOC13">3.5.1 Команды</a> </h3>

<p>Доступны следующие команды:
</p>
<dl compact="compact">
<dt> <samp>`help или ? [cmd]'</samp></dt>
<dd><p>Вывод справки по всем командам или только по команде <var>cmd</var>.
</p>
</dd>
<dt> <samp>`commit'</samp></dt>
<dd><p>Запись изменений в образ диска (если используется -snapshot).
</p>
</dd>
<dt> <samp>`info суб-команда'</samp></dt>
<dd><p>показывает различную информацию о состоянии системы:
</p>
<dl compact="compact">
<dt> <samp>`info network'</samp></dt>
<dd><p>показывает состояние сети
</p></dd>
<dt> <samp>`info block'</samp></dt>
<dd><p>показывает блочные устройства
</p></dd>
<dt> <samp>`info registers'</samp></dt>
<dd><p>показывает регистры процессора
</p></dd>
<dt> <samp>`info history'</samp></dt>
<dd><p>показывает историю набранных команд
</p></dd>
</dl>

</dd>
<dt> <samp>`q или quit'</samp></dt>
<dd><p>Выход из эмулятора.
</p>
</dd>
<dt> <samp>`eject [-f] устройство'</samp></dt>
<dd><p>Извлечение съёмного носителя (используйте для принудительного извлечения -f).
</p>
</dd>
<dt> <samp>`change устройство файла'</samp></dt>
<dd><p>Смена съёмного носителя.
</p>
</dd>
<dt> <samp>`screendump файла'</samp></dt>
<dd><p>Сохранение содержимого экрана в виде PPM-изображения в <var>файл</var>.
</p>
</dd>
<dt> <samp>`log объект1[,...]'</samp></dt>
<dd><p>Включение журналирования указанных объектов в файл <tt>`/tmp/qemu.log'</tt>.
</p>
</dd>
<dt> <samp>`savevm файл'</samp></dt>
<dd><p>Сохранение состояния виртуальной машины в <var>файл</var>.
</p>
</dd>
<dt> <samp>`loadvm файл'</samp></dt>
<dd><p>Восстановление состояния виртуальной машины из <var>файла</var>.
</p>
</dd>
<dt> <samp>`stop'</samp></dt>
<dd><p>Остановка эмуляции.
</p>
</dd>
<dt> <samp>`c или cont'</samp></dt>
<dd><p>Возобновление эмуляции.
</p>
</dd>
<dt> <samp>`gdbserver [порт]'</samp></dt>
<dd><p>Запуск сеанса gdbserver (по умолчанию порт=1234).
</p>
</dd>
<dt> <samp>`x/fmt адрес'</samp></dt>
<dd><p>Дамп виртуальной памяти, начиная с указанного <var>адреса</var>.
</p>
</dd>
<dt> <samp>`xp /fmt адрес'</samp></dt>
<dd><p>Дамп физической памяти, начиная с указанного <var>адреса</var>.
</p>
<p><var>fmt</var> - это формат, сообщающий команде, как нужно форматировать данные. Его
синтаксис: <samp>`/{количество}{формат}{размер}'</samp>
</p>
<dl compact="compact">
<dt> <var>количество</var></dt>
<dd><p>это число объектов для дампа.
</p>
</dd>
<dt> <var>формат</var></dt>
<dd><p>может быть x (шестнадцатиричный), d (десятичный со знаком), u (десятичный без знака), o
(восьмеричный), c (символьный) или i (инструкции asm).
</p>
</dd>
<dt> <var>размер</var></dt>
<dd><p>может быть b (8 бит), h (16 бит), w (32 бит) или g (64 бит). На платформе x86
размеры <code>h</code> или <code>w</code> могут быть указаны с форматом <code>i</code> для выбора
размера инструкций для 16- или 32-битного кода соответственно.
</p>
</dd>
</dl>

<p>Примеры:
</p><ul class="toc">
<li>
Дамп 10 инструкций относительно текущего указателя:
<table><tbody><tr><td>&nbsp;</td><td><pre class="example">(qemu) x/10i $eip
0x90107063:  ret
0x90107064:  sti
0x90107065:  lea    0x0(%esi,1),%esi
0x90107069:  lea    0x0(%edi,1),%edi
0x90107070:  ret
0x90107071:  jmp    0x90107080
0x90107073:  nop
0x90107074:  nop
0x90107075:  nop
0x90107076:  nop
</pre></td></tr></tbody></table>
</li><li>
Дамп 80-ти 16-битных значений относительно начала видеопамяти:
<table><tbody><tr><td>&nbsp;</td><td><pre class="example">(qemu) xp/80hx 0xb8000
0x000b8000: 0x0b50 0x0b6c 0x0b65 0x0b78 0x0b38 0x0b36 0x0b2f 0x0b42
0x000b8010: 0x0b6f 0x0b63 0x0b68 0x0b73 0x0b20 0x0b56 0x0b47 0x0b41
0x000b8020: 0x0b42 0x0b69 0x0b6f 0x0b73 0x0b20 0x0b63 0x0b75 0x0b72
0x000b8030: 0x0b72 0x0b65 0x0b6e 0x0b74 0x0b2d 0x0b63 0x0b76 0x0b73
0x000b8040: 0x0b20 0x0b30 0x0b35 0x0b20 0x0b4e 0x0b6f 0x0b76 0x0b20
0x000b8050: 0x0b32 0x0b30 0x0b30 0x0b33 0x0720 0x0720 0x0720 0x0720
0x000b8060: 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720
0x000b8070: 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720
0x000b8080: 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720
0x000b8090: 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720
</pre></td></tr></tbody></table></li></ul>

</dd>
<dt> <samp>`p или print/fmt выражение'</samp></dt>
<dd>
<p>Вывод значения выражения. Используется только часть <var>format</var> из <var>fmt</var>.
</p>
</dd>
<dt> <samp>`sendkey клавиши'</samp></dt>
<dd>
<p>Отправляет <var>клавиши</var> в эмулятор. Используйте <code>-</code> для одновременного
нажатия нескольких клавиш. Пример:
</p><table><tbody><tr><td>&nbsp;</td><td><pre class="example">sendkey ctrl-alt-f1
</pre></td></tr></tbody></table>
<p>Эта команда полезна для отправки нажатий клавиш, которые ваш графический
интерфейс перехватывает на низком уровне, наподобие <code>ctrl-alt-f1</code> в X
Window.
</p>
</dd>
<dt> <samp>`system_reset'</samp></dt>
<dd>
<p>Сброс системы.
</p>
</dd>
</dl>


<a name="SEC14"></a>
<h3 class="subsection"> <a href="#TOC14">3.5.2 Целочисленные выражения</a> </h3>

<p>Монитор понимает целочисленные выражения, которые можно использовать вместо
любых целочисленных аргументов. Вы можете использовать названия регистров для
получения значений определённых регистров процессора, вставляя перед ними
знак <em>$</em>.
</p>

<a name="disk_005fimages"></a>
<a name="SEC15"></a>
<h2 class="section"> <a href="#TOC15">3.6 Образы дисков</a> </h2>

<p>QEMU, начиная с версии 0.6.1, поддерживает несколько форматов образов дисков,
включая образы растущего объёма (их размер увеличивается по мере записи
непустых секторов), а также сжатые и зашифрованные образы дисков.
</p>

<a name="SEC16"></a>
<h3 class="subsection"> <a href="#TOC16">3.6.1 Быстрое создание образа диска</a> </h3>

<p>Вы можете создать образ диска с помощью команды:
</p><table><tbody><tr><td>&nbsp;</td><td><pre class="example">qemu-img create образ.img размер
</pre></td></tr></tbody></table><p>где <var>образ.img</var> - это имя файла образа диска, а <var>размер</var> - его размер в
килобайтах. Вы можете добавить окончание <code>M</code>, чтобы указать размер в
мегабайтах, и <code>G</code> для размера в гигабайтах.
</p>
<p>Дополнительную информацию See <a href="#SEC18">Запуск qemu-img</a>.
</p>

<a name="SEC17"></a>
<h3 class="subsection"> <a href="#TOC17">3.6.2 Режим snapshot</a> </h3>

<p>Если вы используете опцию <samp>`-snapshot'</samp>, все образы дисков используются
только для чтения. При записи секторов они записываются во временный файл,
созданный в <tt>`/tmp'</tt>. Однако вы можете включить принудительную запись в
"сырой" образ диска с помощью команды <code>commit</code> в мониторе (или
клавиш <kbd>C-a s</kbd> в последовательной консоли).
</p>

<a name="qemu_005fimg_005finvocation"></a>
<a name="SEC18"></a>
<h3 class="subsection"> <a href="#TOC18">3.6.3 Запуск <code>qemu-img</code></a> </h3>


<table><tbody><tr><td>&nbsp;</td><td><pre class="example">usage: qemu-img команда [опции команды]
</pre></td></tr></tbody></table>

<p>Поддерживаются следующие команды:
</p><dl compact="compact">
<dt> <samp>`create [-e] [-b <var>базовый_образ</var>] [-f <var>формат</var>] <var>файл</var> [<var>размер</var>]'</samp></dt>
<dt> <samp>`commit [-f <var>формат</var>] <var>файл</var>'</samp></dt>
<dt> <samp>`convert [-c] [-e] [-f <var>формат</var>] <var>файл</var> [-O <var>выходной_формат</var>] <var>выходой_файл</var>'</samp></dt>
<dt> <samp>`info [-f <var>формат</var>] <var>файл</var>'</samp></dt>
</dl>

<p>Параметры команд:
</p><dl compact="compact">
<dt> <var>файл</var></dt>
<dd><p> имя файла с образом диска
</p>
</dd>
<dt> <var>базовый_образ</var></dt>
<dd><p> образ диска, доступный только для чтения, который используется
в качестве базы для образа т.н. copy-on-write; в этом образе
сохраняются только изменённые данные.
</p>
</dd>
<dt> <var>формат</var></dt>
<dd><p> это формат образа диска. В большинстве случаев он определяется автоматически. Поддерживаются следующие форматы:
</p>
<dl compact="compact">
<dt> <code>raw</code></dt>
<dd>
<p>"Сырой" формат (по умолчанию). Преимуществом этого формата является
то, что он прост и легко экспортируется в другие эмуляторы. Если ваша
файловая система поддерживает <em>дыры (holes)</em> (например, в ext2 или ext3 в Linux), тогда место на диске будут занимать только записанные секторы. Используйте <code>qemu-img info</code>, чтобы узнать реальный размер, занимаемый образом, или <code>ls -ls</code> в Unix/Linux (или <code>du -h</code> - прим. переводчика).
</p>
</dd>
<dt> <code>qcow</code></dt>
<dd><p>Формат QEMU - наиболее универсальный формат. Он позволяет
получить образы меньшего размера (полезно в том случае, если вы ваша
файловай система не поддерживает "дыры", например, в Windows),
опциональное шифрование AES и сжатие zlib.
</p></dd>
<dt> <code>cow</code></dt>
<dd><p>Формат User Mode Linux Copy On Write. Используется в QEMU для
образов с увеличивающимся объёмом. Поддерживается только для
совместимости с предыдущими версиями. Не работает в win32.
</p></dd>
<dt> <code>vmdk</code></dt>
<dd><p>Формат, совместимый с VMware 3 и 4.
</p></dd>
<dt> <code>cloop</code></dt>
<dd><p>Формат Linux Compressed Loop. Полезен только для повторного
использования сжатых образов CD-ROM, использующихся, например, на
LiveCD с Knoppix.
</p></dd>
</dl>

</dd>
<dt> <var>размер</var></dt>
<dd><p>размер образа диска в килобайтах. Возможно использование необязательных окончаний: <code>M</code> (мегабайт) и <code>G</code> (гигабайт).
</p>
</dd>
<dt> <var>выходной_файл</var></dt>
<dd><p>имя файла создаваемого образа диска.
</p>
</dd>
<dt> <var>выходной_формат</var></dt>
<dd><p>формат создаваемого диска.
</p>
</dd>
<dt> <var>-c</var></dt>
<dd><p>означает, что создаваемый образ должен быть сжат (только для формата qcow).
</p></dd>
<dt> <var>-e</var></dt>
<dd><p>означает, что создаваемый образ должен быть зашифрован (только для формата qcow).
</p></dd>
</dl>

<p>Описание команды:
</p>
<dl compact="compact">
<dt> <samp>`create [-e] [-b <var>базовый_образ</var>] [-f <var>формат</var>] <var>файл</var> [<var>размер</var>]'</samp></dt>
<dd>
<p>Создаёт образ нового диска в виде указанного <var>файла</var> указанного <var>размера</var> и <var>формата</var>.
</p>
<p>Если указан <var>базовый_образ</var>, тогда в образ будут записываться только изменения, относительно <var>базового_образа</var>. <var>Базовый_образ</var> не будет изменяться, только если вы не воспользуетесь в мониторе командой <code>commit</code>.
</p>
</dd>
<dt> <samp>`commit [-f <var>формат</var>] <var>файл</var>'</samp></dt>
<dd>
<p>Вносит в базовый образ изменения, записанные в <var>файл</var>.
</p>
</dd>
<dt> <samp>`convert [-c] [-e] [-f <var>формат</var>] <var>файл</var> [-O <var>выходной_формат</var>] <var>выходной_файл</var>'</samp></dt>
<dd>
<p>Преобразовывает образ диска <var>файл</var> в образ <var>выходной_файл</var> с использованием указанного <var>формата</var>. Опционально он может быть зашифрован (опция <code>-e</code>) или сжат (опция <code>-c</code>).
</p>
<p>Шифрование и сжатие поддерживаются только в формате <code>qcow</code>.
Сжатие работает в режиме "только для чтения", т.е. если
перезаписывается сжатый сектор, то данные в него пишутся в несжатом
виде.
</p>
<p>При шифровании используется довольно безопасный алгоритм AES (со
128-битными ключами). Для обеспечения максимальной защиты используйте
длинные пароли (порядка 16 символов).
</p>
<p>Преобразование образов также полезно для уменьшения их размеров при использовании формата увеличивающегося размера, такого как <code>qcow</code> или <code>cow</code>: при этом выявляются пустые секторы и в полученном образе они отсутвуют.
</p>
</dd>
<dt> <samp>`info [-f <var>формат</var>] <var>файл</var>'</samp></dt>
<dd>
<p>Выводит информацию об образе диска <var>filename</var>. Используйте
её для определения пространства, зарезервированного на жёстком диске
под этот образ, поскольку оно может отличаться от показываемого
размера.
</p></dd>
</dl>




<a name="SEC19"></a>
<h2 class="section"> <a href="#TOC19">3.7 Эмуляция сети</a> </h2>

<p>QEMU может эмулировать до 6-и сетевых карт (NE2000-типа). Каждая из
карт может быть подключена к определённому сетевому интерфейсу
системы-хозяина.
</p>

<a name="SEC20"></a>
<h3 class="subsection"> <a href="#TOC20">3.7.1 Использование сетевого интерфейса tun/tap</a> </h3>

<p>Это стандартный способ эмуляции сети. QEMU добавляет в систему-хозяина виртуальное сетевое устройство (под названием <code>tun0</code>), а затем вы можете настроить его так, как если бы это была настоящая ethernet-карта.
</p>
<p>В качестве примера вы можете загрузить архив <tt>`linux-test-xxx.tar.gz'</tt>, скопировать скрипт <tt>`qemu-ifup'</tt> в <tt>`/etc'</tt> и настроить соответствующим образом <code>sudo</code>, чтобы команда <code>ifconfig</code>, находящаяся в <tt>`qemu-ifup'</tt>,
могла быть выполнена с правами root'а. Сначала вы должны убедиться в
том, что ядро системы-хозяина поддерживает сетевые интерфейсы TUN/TAP:
должно существовать устройство <tt>`/dev/net/tun'</tt>.
</p>
<p>В <a href="#SEC22">direct_linux_boot</a> есть пример использования такой сети в дистрибутиве Linux.
</p>

<a name="SEC21"></a>
<h3 class="subsection"> <a href="#TOC21">3.7.2 Использование сетевого стека в режиме пользователя</a> </h3>

<p>При использовании опции <samp>`-user-net'</samp>, или если у вас нет
скрипта инициализации tun/tap, QEMU использует полностью
пользовательский сетевой стек (вам не нужны права root'а для
использования виртуальной сети). Конфигурация виртуальной сети
представляет собой следующее:
</p>
<table><tbody><tr><td>&nbsp;</td><td><pre class="example">Виртуальная машина QEMU  &lt;------&gt;  Файервол/DHCP-сервер &lt;-----&gt; Интернет
      (10.0.2.x)            |          (10.0.2.2)
                            |
                            ----&gt;  DNS-сервер (10.0.2.3)
                            |
                            ----&gt;  SMB-сервер (10.0.2.4)
</pre></td></tr></tbody></table>
<p>ВМ QEMU ведёт себя так, как если бы она находилась за файерволом,
блокирующим все входящие подключения. Вы можете использовать клиент
DHCP для автоматической настройки сети в ВМ QEMU.
</p>
<p>Чтобы проверить работу сети в режиме пользователя, пропингуйте адрес
10.0.2.2 и проверьте, получили ли вы адрес из диапазона 10.0.2.x от
виртуального DHCP-сервера QEMU.
</p>
<p>Обратите внимание, что <code>ping</code> не работает по отношению к
Интернет-адресам, поскольку для этого требуются привилегии root'а. Это
означает, что вы можете пропинговать только локальный маршрутизатор
(10.0.2.2).
</p>
<p>При использовании встроенного сервера TFTP, маршрутизатор также выступает в роли TFTP-сервера.
</p>
<p>При использовании опции <samp>`-redir'</samp>, TCP- или
UDP-подключения к системе-хозяину могут быть перенаправлены в гостевую
систему. Например, это позволяет перенаправлять X11-, telnet- или
SSH-подключения.
</p>

<a name="direct_005flinux_005fboot"></a>
<a name="SEC22"></a>
<h2 class="section"> <a href="#TOC22">3.8 Непосредственная загрузка Linux</a> </h2>

<p>В этом разделе рассказано о том, как запустить ядро Linux внутри
QEMU без необходимости создания целого загрузочного диска. Это очень
полезно для быстрого тестирования ядра Linux. Также разъяснена
настройка сети в QEMU.
</p>
<ol>
<li>
Загрузите архив <tt>`linux-test-xxx.tar.gz'</tt>, содержащий ядро Linux и образ диска.

</li><li> Необязательно: если вам нужна поддержка сети (например для запуска X11-приложений), вы можете скопировать скрипт <tt>`qemu-ifup'</tt> в <tt>`/etc'</tt> и настроить соответствующим образом <code>sudo</code>, чтобы команда <code>ifconfig</code>, находящаяся в <tt>`qemu-ifup'</tt>,
могла быть выполнена с правами root'а. Сначала вы должны убедиться в
том, что ядро системы-хозяина поддерживает сетевые интерфейсы TUN/TAP:
должно существовать устройство <tt>`/dev/net/tun'</tt>.

<p>Если сеть включена, между ядром системы-хозяина и эмулируемым ядром
устанавливается виртуальное сетевое соединение. Из ядра хозяина
эмулируемое ядро доступно по IP-адресу 172.20.0.2, а ядро хозяина
доступно в эмулируемом по IP-адресу 172.20.0.1.
</p>
</li><li> Запустите <code>qemu.sh</code>. Вы должны будете увидеть следующее:

<table><tbody><tr><td>&nbsp;</td><td><pre class="example">&gt; ./qemu.sh
Connected to host network interface: tun0
Linux version 2.4.21 (bellard@voyager.localdomain) (gcc version 3.2.2 20030222 (Red Hat Linux 3.2.2-5)) #5 Tue Nov 11 18:18:53 CET 2003
BIOS-provided physical RAM map:
 BIOS-e801: 0000000000000000 - 000000000009f000 (usable)
 BIOS-e801: 0000000000100000 - 0000000002000000 (usable)
32MB LOWMEM available.
On node 0 totalpages: 8192
zone(0): 4096 pages.
zone(1): 4096 pages.
zone(2): 0 pages.
Kernel command line: root=/dev/hda sb=0x220,5,1,5 ide2=noprobe ide3=noprobe ide4=noprobe ide5=noprobe console=ttyS0
ide_setup: ide2=noprobe
ide_setup: ide3=noprobe
ide_setup: ide4=noprobe
ide_setup: ide5=noprobe
Initializing CPU#0
Detected 2399.621 MHz processor.
Console: colour EGA 80x25
Calibrating delay loop... 4744.80 BogoMIPS
Memory: 28872k/32768k available (1210k kernel code, 3508k reserved, 266k data, 64k init, 0k highmem)
Dentry cache hash table entries: 4096 (order: 3, 32768 bytes)
Inode cache hash table entries: 2048 (order: 2, 16384 bytes)
Mount cache hash table entries: 512 (order: 0, 4096 bytes)
Buffer-cache hash table entries: 1024 (order: 0, 4096 bytes)
Page-cache hash table entries: 8192 (order: 3, 32768 bytes)
CPU: Intel Pentium Pro stepping 03
Checking 'hlt' instruction... OK.
POSIX conformance testing by UNIFIX
Linux NET4.0 for Linux 2.4
Based upon Swansea University Computer Society NET3.039
Initializing RT netlink socket
apm: BIOS not found.
Starting kswapd
Journalled Block Device driver loaded
Detected PS/2 Mouse Port.
pty: 256 Unix98 ptys configured
Serial driver version 5.05c (2001-07-08) with no serial options enabled
ttyS00 at 0x03f8 (irq = 4) is a 16450
ne.c:v1.10 9/23/94 Donald Becker (becker@scyld.com)
Last modified Nov 1, 2000 by Paul Gortmaker
NE*000 ethercard probe at 0x300: 52 54 00 12 34 56
eth0: NE2000 found at 0x300, using IRQ 9.
RAMDISK driver initialized: 16 RAM disks of 4096K size 1024 blocksize
Uniform Multi-Platform E-IDE driver Revision: 7.00beta4-2.4
ide: Assuming 50MHz system bus speed for PIO modes; override with idebus=xx
hda: QEMU HARDDISK, ATA DISK drive
ide0 at 0x1f0-0x1f7,0x3f6 on irq 14
hda: attached ide-disk driver.
hda: 20480 sectors (10 MB) w/256KiB Cache, CHS=20/16/63
Partition check:
 hda:
Soundblaster audio driver Copyright (C) by Hannu Savolainen 1993-1996
NET4: Linux TCP/IP 1.0 for NET4.0
IP Protocols: ICMP, UDP, TCP, IGMP
IP: routing cache hash table of 512 buckets, 4Kbytes
TCP: Hash tables configured (established 2048 bind 4096)
NET4: Unix domain sockets 1.0/SMP for Linux NET4.0.
EXT2-fs warning: mounting unchecked fs, running e2fsck is recommended
VFS: Mounted root (ext2 filesystem).
Freeing unused kernel memory: 64k freed

Linux version 2.4.21 (bellard@voyager.localdomain) (gcc version 3.2.2 20030222 (Red Hat Linux 3.2.2-5)) #5 Tue Nov 11 18:18:53 CET 2003

QEMU Linux test distribution (based on Redhat 9)

Type 'exit' to halt the system

sh-2.05b#
</pre></td></tr></tbody></table>
</li><li>
Затем вы можете поиграться с ядром, используя виртуальную последовательную консоль. Например, вы можете выполнить команду <code>ls</code>. Введите <kbd>Ctrl-a h</kbd>,
чтобы получить справку о клавишах, которые вы можете использовать в
виртуальной последовательной консоли. В частности используйте <kbd>Ctrl-a x</kbd> для выхода из QEMU и <kbd>Ctrl-a b</kbd> в качестве "магической" клавиши системного вызова (Magic SysRq).

</li><li>
Если сеть включена, запустите в эмуляторе скрипт <tt>`/etc/linuxrc'</tt> (не забудьте точку в начале):
<table><tbody><tr><td>&nbsp;</td><td><pre class="example">. /etc/linuxrc
</pre></td></tr></tbody></table>
<p>Затем разрешите X11-подключения к своему ПК из эмулируемого Linux'а:
</p><table><tbody><tr><td>&nbsp;</td><td><pre class="example">xhost +172.20.0.2
</pre></td></tr></tbody></table>
<p>Теперь вы можете запустить <tt>`xterm'</tt> или <tt>`xlogo'</tt>, чтобы убедится в том, что перед вами действительно виртуальная система Linux!
</p>
</li></ol>

<p>ЗАМЕЧАНИЯ:
</p><ol>
<li>
В состав архива также входит ядро версии 2.5.74. Чтобы попробовать его, просто замените им bzImage в qemu.sh.

</li><li>
Чтобы корректно завершить работу с qemu, вы можете выполнить в нём команду <em>shutdown</em>. qemu автоматически закроется по завершении работы Linux.

</li><li>
Вы можете немного увеличить скорость загрузки, отключив опрос
отсутствующих интерфейсов IDE. Для этого добавьте следующие параметры в
командную строку ядра:
<table><tbody><tr><td>&nbsp;</td><td><pre class="example">ide1=noprobe ide2=noprobe ide3=noprobe ide4=noprobe ide5=noprobe
</pre></td></tr></tbody></table>
</li><li>
Этот образ диска является изменённой версией образа, созданного Кевином Лоутоном (Kevin Lawton) для проекта plex86 (<a href="http://jack.kiev.ua/docs/www.plex86.org">www.plex86.org</a>).

</li></ol>


<a name="gdb_005fusage"></a>
<a name="SEC23"></a>
<h2 class="section"> <a href="#TOC23">3.9 Использование GDB</a> </h2>

<p>QEMU поддерживает упрощённую работу с gdb. Таким образом вы можете
нажать 'Ctrl-C' во время работы виртуальной машины и просмотреть её
состояние.
</p>
<p>Чтобы можно было использовать gdb, запустите qemu с опцией '-s'. При этом он будет ожидать подключения gdb:
</p><table><tbody><tr><td>&nbsp;</td><td><pre class="example">&gt; qemu -s -kernel arch/i386/boot/bzImage -hda root-2.4.20.img -append "root=/dev/hda"
Connected to host network interface: tun0
Waiting gdb connection on port 1234
</pre></td></tr></tbody></table>
<p>Затем запустите gdb, передав ему в качестве параметра исполняемый файл 'vmlinux':
</p><table><tbody><tr><td>&nbsp;</td><td><pre class="example">&gt; gdb vmlinux
</pre></td></tr></tbody></table>
<p>В gdb подключитесь к QEMU:
</p><table><tbody><tr><td>&nbsp;</td><td><pre class="example">(gdb) target remote localhost:1234
</pre></td></tr></tbody></table>
<p>Затем вы можете использовать gdb обычным образом. Например, введите 'c', чтобы запустить ядро:
</p><table><tbody><tr><td>&nbsp;</td><td><pre class="example">(gdb) c
</pre></td></tr></tbody></table>
<p>Вот несколько полезных подсказок по использованию gdb при работе с системным кодом:
</p>
<ol>
<li>
Используйте <code>info reg</code> для вывода всех регистров процессора.
</li><li>
Используйте <code>x/10i $eip</code> для вывода кода в разряде PC.
</li><li>
Используйте <code>set architecture i8086</code> дампа 16-битного кода. Затем воспользуйтесь <code>x/10i $cs*16+*eip</code> для получения дампа кода в разряде PC.
</li></ol>


<a name="SEC24"></a>
<h2 class="section"> <a href="#TOC24">3.10 Дополнительная информация по эмулируемой ОС</a> </h2>


<a name="SEC25"></a>
<h3 class="subsection"> <a href="#TOC25">3.10.1 Linux</a> </h3>

<p>Чтобы иметь доступ к графическим режимам SVGA в X11, используйте драйвер <code>vesa</code> или <code>cirrus</code>. Для получения оптимальной производительности используйте 16-битную глубину цвета и в гостевой системе, и в системе-хозяине.
</p>
<p>При использовании в гостевой системе ядра Linux версии 2.6 вам следует добавить параметр <code>clock=pit</code>
в командную строку ядра, потому что ядра Linux серии 2.6 по умолчанию
выполняют очень ограниченную проверку часов реального времени, которую
QEMU не может в точности сэмулировать.
</p>
<p>Так же при использовании в гостевой системе ядра Linux версии 2.6
убедитесь, что не задействован патч 4G/4G, потому что с этим патчем
QEMU работает медленнее. Модуль ускорения QEMU (QEMU Accelerator
Module) в этом случае также работает гораздо медленнее. Этот патч
использовался по умолчанию в ранних версиях ядер Linux в Fedora Core 3
(&lt; 2.6.9-1.724_FC3). В более новых версиях его нет.
</p>

<a name="SEC26"></a>
<h3 class="subsection"> <a href="#TOC26">3.10.2 Windows</a> </h3>

<p>Если ваша система довольно медленная, лучше эмулировать Windows 95,
поскольку она работает быстрее всех. Также неплохим вариантом будет
Windows 2000.
</p>

<a name="SEC27"></a>
<h4 class="subsubsection"> <a href="#TOC27">3.10.2.1 Поддержка графических режимов SVGA</a> </h4>

<p>QEMU эмулирует видеокарту Cirrus Logic GD5446. Все версии Windows,
начиная с Windows 95, должны нормально распознавать и работать с этой
видеокартой. Для получения оптимальной производительности используйте
16-битную глубину цвета и в гостевой системе, и в системе-хозяине.
</p>

<a name="SEC28"></a>
<h4 class="subsubsection"> <a href="#TOC28">3.10.2.2 Снижение загрузки процессора</a> </h4>

<p>Windows 9x некорректно использует инструкцию CPU HLT. В результате
процессор системы-хозяина продолжает использоваться даже при простое.
Для устранения этой проблемы вы можете установить специальную утилиту <a href="http://www.user.cityline.ru/%7Emaxamn/amnhltm.zip">http://www.user.cityline.ru/~maxamn/amnhltm.zip</a>. Обратите внимание, что для NT, 2000 и XP такая утилита не нужна.
</p>

<a name="SEC29"></a>
<h4 class="subsubsection"> <a href="#TOC29">3.10.2.3 Проблема с переполнением диска в Windows 2000</a> </h4>

<p>В Windows 2000 есть ошибка, приводящая к проблеме переполнения диска
во время установки. Поэтому при её установке используйте в QEMU опцию <samp>`-win2k-hack'</samp>,
чтобы устранить эту проблему. После установки Windows 2000 вам больше
не нужно использовать эту опцию (она замедляет передачу данных по IDE).
</p>

<a name="SEC30"></a>
<h4 class="subsubsection"> <a href="#TOC30">3.10.2.4 Завершение работы Windows 2000</a> </h4>

<p>Windows 2000 не может автоматически завершить свою работу в QEMU в
отличие от Windows 98. Это связано с тем, что Windows 2000 по умолчанию
не использует драйвер автоматического управления питанием (APM),
предоставляемого BIOS'ом.
</p>
<p>Чтобы исправить это, выполните следующее (спасибо Струану Барлетту
(Struan
Bartlett)): откройте Control Panel =&gt; Add/Remove Hardware &amp; Next
=&gt; Add/Troubleshoot a device =&gt; Add a new device &amp; Next =&gt;
No, select the hardware from a list &amp; Next =&gt; NT Apm/Legacy
Support &amp; Next =&gt; Next (снова) несколько раз. Теперь драйвер
установлен и Windows 2000 может корректно сообщать QEMU о завершении
своей работы в нужный момент.
</p>

<a name="SEC31"></a>
<h4 class="subsubsection"> <a href="#TOC31">3.10.2.5 Использование общих каталогов для Unix и Windows</a> </h4>

<p>Смотрите <a href="#SEC10">sec_invocation</a> об использовании опции <samp>`-smb'</samp>.
</p>

<a name="SEC32"></a>
<h4 class="subsubsection"> <a href="#TOC32">3.10.2.6 Проблемы с безопасностью в Windows XP</a> </h4>

<p>Некоторые сборки Windows XP нормально устанавливаются, однако во время загрузки выдают сообщение об ошибке безопасности:
</p><table><tbody><tr><td>&nbsp;</td><td><pre class="example">A problem is preventing Windows from accurately checking the
license for this computer. Error code: 0x800703e6.
</pre></td></tr></tbody></table><p>Единственным способом обойти эту проблемы является загрузка с безопасном режиме с отключенной поддержкой сети.
</p>
<p>В следующих релизах QEMU эта проблема скорее всего будет устранена.
</p>

<a name="SEC33"></a>
<h3 class="subsection"> <a href="#TOC33">3.10.3 MS-DOS и FreeDOS</a> </h3>


<a name="SEC34"></a>
<h4 class="subsubsection"> <a href="#TOC34">3.10.3.1 Снижение загрузки процессора</a> </h4>

<p>DOS некорректно использует инструкцию CPU HLT. В результате
процессор системы-хозяина продолжает использоваться даже при простое.
Для устранения этой проблемы вы можете установить специальную утилиту <a href="http://www.vmware.com/software/dosidle210.zip">http://www.vmware.com/software/dosidle210.zip</a>.
</p>

<a name="SEC35"></a>
<h1 class="chapter"> <a href="#TOC35">4. Запуск QEMU в качестве эмулятора системы типа PowerPC</a> </h1>

<p>Используйте исполняемый файл <tt>`qemu-system-ppc'</tt>, чтобы эмулировать целую систему типа PREP или PowerMac PowerPC.
</p>
<p>QEMU эмулирует следующее периферийное оборудование PowerMac:
</p>
<ul class="toc">
<li>-
UniNorth PCI Bridge
</li><li>-
PCI VGA-совместимую карту с VESA-расширениями Bochs
</li><li>-
2 PCI IDE-интерфейса с поддержкой жёстких и приводов CD-ROM
</li><li>-
сетевые PCI-адаптеры NE2000
</li><li>-
энергонезависимую оперативную память
</li><li>-
VIA-CUDA с клавиатурой и мышью ADB.
</li></ul>

<p>QEMU эмулирует следующее периферийное оборудование PREP:
</p>
<ul class="toc">
<li>-
PCI Bridge
</li><li>-
PCI VGA-совместимую карту с VESA-расширениями Bochs
</li><li>-
2 PCI IDE-интерфейса с поддержкой жёстких и приводов CD-ROM
</li><li>-
дисковод
</li><li>-
сетевые PCI-адаптеры NE2000
</li><li>-
последовательные порты
</li><li>-
энергонезависимую оперативную память PREP
</li><li>-
PC-совместимую клавиатуру и мышь
</li></ul>

<p>В QEMU используется Open Hack'Ware Open Firmware Compatible BIOS, доступный на сайте <a href="http://site.voila.fr/jmayer/OpenHackWare/index.htm">http://site.voila.fr/jmayer/OpenHackWare/index.htm</a>.
</p>
<p>Вы можете прочитать главу об эмуляции системы типа PC, чтобы получить большее представление об использовании QEMU.
</p>

<p>Следующие опции касаются только эмуляции PowerPC:
</p>
<dl compact="compact">
<dt> <samp>`-prep'</samp></dt>
<dd><p>Эмуляция системы PREP (по умолчанию это PowerMAC)
</p>
</dd>
<dt> <samp>`-g ШxВ[xГЛУБИНА]'</samp></dt>
<dd>
<p>Исходный графический режим VGA. По умолчанию используется 800x600x15.
</p>
</dd>
</dl>



<p>Дополнительная информация доступна по адресу <a href="http://jocelyn.mayer.free.fr/qemu-ppc/">http://jocelyn.mayer.free.fr/qemu-ppc/</a>.
</p>

<a name="SEC36"></a>
<h1 class="chapter"> <a href="#TOC36">5. Запуск QEMU в качестве эмулятора системы типа Sparc32</a> </h1>

<p>Используйте исполняемый файл <tt>`qemu-system-sparc'</tt>, чтобы эмулировать JavaStation (архитектура sun4m). Достигнута почти полная эмуляция.
</p>
<p>QEMU эмулирует следующее периферийное оборудование sun4m:
</p>
<ul class="toc">
<li>-
IOMMU
</li><li>-
видеобуфер TCX
</li><li>-
сетевую карту Lance (Am7990)
</li><li>-
энергонезависимую оперативную память M48T08
</li><li>-
Slave I/O: таймеры, контроллеры прерываний, последовательные порты Zilog, клавиатуру и логический power/reset
</li><li>-
ESP SCSI-контроллер с поддержкой жёстких и приводов CD-ROM
</li><li>-
дисковод
</li></ul>

<p>В этой архитектуре количество оборудования является фиксированным.
</p>
<p>В QEMU используется Proll - замена PROM, доступная на сайте <a href="http://people.redhat.com/zaitcev/linux/">http://people.redhat.com/zaitcev/linux/</a>. Необходимые патчи для QEMU включены в архив с исходными текстами.
</p>
<p>Образец ядра Linux серии 2.6 и образ ram-диска доступны на веб-сайте
QEMU. Обратите внимание, что в настоящий момент не работают ядра Linux
серии 2.4, NetBSD и OpenBSD.
</p>

<p>Следующие опции касаются только эмуляции Sparc:
</p>
<dl compact="compact">
<dt> <samp>`-g ШxВ'</samp></dt>
<dd>
<p>Исходный графический режим TCX. По умолчанию используется 1024x768.
</p>
</dd>
</dl>



<a name="SEC37"></a>
<h1 class="chapter"> <a href="#TOC37">6. Запуск QEMU в качестве эмулятора системы типа Sparc64</a> </h1>

<p>Используйте исполняемый файл <tt>`qemu-system-sparc64'</tt>, чтобы эмулировать vfibye Sun4u. Пока что эмулятор ни для чего другого не подходит.
</p>
<p>QEMU эмулирует следующее периферийное оборудование sun4u:
</p>
<ul class="toc">
<li>-
UltraSparc IIi APB PCI Bridge
</li><li>-
PCI VGA-совместимую карту с VESA-расширениями Bochs
</li><li>-
энергонезависимую оперативную память M48T59
</li><li>-
PC-совместимые последовательные порты
</li></ul>


<a name="SEC38"></a>
<h1 class="chapter"> <a href="#TOC38">7. Запуск QEMU в качестве эмулятора системы типа MIPS</a> </h1>

<p>Используйте исполняемый файл <tt>`qemu-system-mips'</tt>, чтобы эмулировать машину MIPS. Эмулятор начинает запускать ядро Linux.
</p>

<a name="SEC39"></a>
<h1 class="chapter"> <a href="#TOC39">8. Запуск QEMU в качестве эмулятора пользовательского пространства</a> </h1>


<a name="SEC40"></a>
<h2 class="section"> <a href="#TOC40">8.1 Быстрый запуск</a> </h2>

<p>Чтобы запустить процесс Linux, QEMU нужен сам исполняемый файл процесса и все используемые им динамические библиотеки (x86).
</p>
<ul class="toc">
<li> Для архитектуры x86 вы можете просто попробовать запустить любой процесс, используя родные библиотеки:

<table><tbody><tr><td>&nbsp;</td><td><pre class="example">qemu-i386 -L / /bin/ls
</pre></td></tr></tbody></table>
<p>Опция <code>-L /</code> означает, что динамический компоновщик x86 необходимо искать с префиксом <tt>`/'</tt>.
</p>
</li><li> Поскольку QEMU также является процессом linux, вы моете
запустить qemu с помощью qemu (ЗАМЕЧАНИЕ: вы сможете сделать это только
в том случае, если вы сами скомпилировали QEMU из исходных кодов):
<table><tbody><tr><td>&nbsp;</td><td><pre class="example">qemu-i386 -L / qemu-i386 -L / /bin/ls
</pre></td></tr></tbody></table>
</li><li> На не x86 процессорах вам нужно сначала загрузить как минимум glibc для x86 (<tt>`qemu-runtime-i386-XXX-.tar.gz'</tt> на веб-сайте QEMU). Убедитесь, что не установлена переменная окружения <code>LD_LIBRARY_PATH</code>:

<table><tbody><tr><td>&nbsp;</td><td><pre class="example">unset LD_LIBRARY_PATH
</pre></td></tr></tbody></table>
<p>Затем вы можете запустить исполняемый файл <tt>`ls'</tt>, скомпилированный под x86:
</p>
<table><tbody><tr><td>&nbsp;</td><td><pre class="example">qemu-i386 tests/i386/ls
</pre></td></tr></tbody></table><p>Вы можете взглянуть на <tt>`qemu-binfmt-conf.sh'</tt>,
чтобы узнать, как QEMU автоматически запускается ядром Linux, когда вы
пытаетесь запустить исполняемые файлы x86. Для этого в ядро Linux
должен быть загружен модуль <code>binfmt_misc</code>.
</p>
</li><li> Версия QEMU для x86 также присутствует. Вы можете попробовать следующие вещи:
<table><tbody><tr><td>&nbsp;</td><td><pre class="example">qemu-i386 /usr/local/qemu-i386/bin/qemu-i386 /usr/local/qemu-i386/bin/ls-i386
</pre></td></tr></tbody></table>
</li></ul>


<a name="SEC41"></a>
<h2 class="section"> <a href="#TOC41">8.2 Запуск Wine</a> </h2>

<ul class="toc">
<li> Убедитесь, что у вас есть работающий QEMU и дистрибутив glibc для
x86 (см. предыдущий раздел). Чтобы проверить это, выполните следующее:
<table><tbody><tr><td>&nbsp;</td><td><pre class="example">qemu-i386 /usr/local/qemu-i386/bin/ls-i386
</pre></td></tr></tbody></table>
</li><li> Загрузите бинарный инсталлятор Wine для x86
(<tt>`qemu-XXX-i386-wine.tar.gz'</tt> на веб-сайте QEMU).

</li><li> Настройте свою учётную запись. Для этого взгляните на скрипт <tt>`/usr/local/qemu-i386/bin/wine-conf.sh'</tt>. Ваш старый каталог <code>${HOME}/.wine</code> будет сохранён в <code>${HOME}/.wine.org</code>.

</li><li> Теперь попробуйте запустить, например, <tt>`putty.exe'</tt>:

<table><tbody><tr><td>&nbsp;</td><td><pre class="example">qemu-i386 /usr/local/qemu-i386/wine/bin/wine /usr/local/qemu-i386/wine/c/Program\ Files/putty.exe
</pre></td></tr></tbody></table>
</li></ul>


<a name="SEC42"></a>
<h2 class="section"> <a href="#TOC42">8.3 Опции командной строки</a> </h2>

<table><tbody><tr><td>&nbsp;</td><td><pre class="example">использование: qemu-i386 [-h] [-d] [-L путь] [-s размер] программа [аргументы...]
</pre></td></tr></tbody></table>
<dl compact="compact">
<dt> <samp>`-h'</samp></dt>
<dd><p>Вывод справки.
</p></dd>
<dt> <samp>`-L path'</samp></dt>
<dd><p>Префикс интерпретатора x86 elf (по умолчанию используется /usr/local/qemu-i386)
</p></dd>
<dt> <samp>`-s размер'</samp></dt>
<dd><p>Размер стека x86 в байтах (по умолчанию 524288)
</p></dd>
</dl>

<p>Опции отладки:
</p>
<dl compact="compact">
<dt> <samp>`-d'</samp></dt>
<dd><p>Включить журналирование (logfile=/tmp/qemu.log)
</p></dd>
<dt> <samp>`-p размер_страницы'</samp></dt>
<dd><p>Работает так, как если бы размер страницы системы-хозяина составлял указанное значение.
</p></dd>
</dl>


<a name="compilation"></a>
<a name="SEC43"></a>
<h1 class="chapter"> <a href="#TOC43">9. Компиляция из исходного кода</a> </h1>


<a name="SEC44"></a>
<h2 class="section"> <a href="#TOC44">9.1 Linux/Unix</a> </h2>


<a name="SEC45"></a>
<h3 class="subsection"> <a href="#TOC45">9.1.1 Компиляция</a> </h3>

<p>Сначала распакуйте архив с исходными текстами:
</p><table><tbody><tr><td>&nbsp;</td><td><pre class="example">cd /tmp
tar zxvf qemu-x.y.z.tar.gz
cd qemu-x.y.z
</pre></td></tr></tbody></table>
<p>Затем настройте QEMU и соберите его (обычно никакие опции не нужны):
</p><table><tbody><tr><td>&nbsp;</td><td><pre class="example">./configure
make
</pre></td></tr></tbody></table>
<p>Затем выполните под root'ом:
</p><table><tbody><tr><td>&nbsp;</td><td><pre class="example">make install
</pre></td></tr></tbody></table><p>чтобы установить QEMU в <tt>`/usr/local'</tt>.
</p>

<a name="SEC46"></a>
<h3 class="subsection"> <a href="#TOC46">9.1.2 Версии проверенных утилит</a> </h3>

<p>Чтобы успешно скомпилировать QEMU, очень важно, чтобы у вас были
правильные версии утилит. Самым важным является gcc. Я не могу
гарантировать работу QEMU, если вы не используете проверенную версию
gcc. Взгляните на содержимое файлов 'configure' и 'Makefile', если вы
хотите заставить работать другую версию gcc.
</p>
<table><tbody><tr><td>&nbsp;</td><td><pre class="example">хост      gcc      binutils      glibc    linux       дистрибутив
----------------------------------------------------------------------
x86       3.2      2.13.2        2.1.3    2.4.18
          2.96     2.11.93.0.2   2.2.5    2.4.18      Red Hat 7.3
          3.2.2    2.13.90.0.18  2.3.2    2.4.20      Red Hat 9

PowerPC   3.3 [4]  2.13.90.0.18  2.3.1    2.4.20briq
          3.2

Alpha     3.3 [1]  2.14.90.0.4   2.2.5    2.2.20 [2]  Debian 3.0

Sparc32   2.95.4   2.12.90.0.1   2.2.5    2.4.18      Debian 3.0

ARM       2.95.4   2.12.90.0.1   2.2.5    2.4.9 [3]   Debian 3.0

[1] На Alpha для QEMU нужен атрибут 'видимости' gcc, доступный только
    для gcc версии &gt;= 3.3.
[2] Нужен Linux &gt;= 2.4.20 для поддержки исключения точности
    (не проверено).
[3] 2.4.9-ac10-rmk2-np1-cerf2

[4] gcc 2.95.x создаёт неверный код при использовании слишком большого числа
    переменных регистров. На PowerPC вам необходимо использовать gcc 3.x.
</pre></td></tr></tbody></table>

<a name="SEC47"></a>
<h2 class="section"> <a href="#TOC47">9.2 Windows</a> </h2>

<ul class="toc">
<li> Установите последние версии MSYS и MinGW с сайта <a href="http://www.mingw.org/">http://www.mingw.org/</a>. Вы можете найти подробные инструкции по установке в разделе загрузки и в FAQ'е.

</li><li> Загрузите devel-библиотеку MinGW для SDL 1.2.x (<tt>`SDL-devel-1.2.x-mingw32.tar.gz'</tt>) с сайта <a href="http://www.libsdl.org/">http://www.libsdl.org</a>. Распакуйте её во временный каталог и распакуйте архив <tt>`i386-mingw32msvc.tar.gz'</tt> в каталог MinGW. Отредактируйте скрипт <tt>`sdl-config'</tt>, чтобы при запуске в нём использовался правильный каталог SDL.

</li><li> Распакуйте архив с последней версией QEMU.

</li><li> Запустите командный процессор MSYS (файл <tt>`msys.bat'</tt>).

</li><li> Перейдите в каталог QEMU. Запустите <tt>`./configure'</tt> и <tt>`make'</tt>. Если у вас возникли проблемы с SDL, проверьте, можно ли запустить <tt>`sdl-config'</tt> из командной строки MSYS.

</li><li> вы можете установить QEMU в <tt>`Program Files/Qemu'</tt>, выполнив команду <tt>`make install'</tt>. Не забудьте скопировать <tt>`SDL.dll'</tt> в <tt>`Program Files/Qemu'</tt>.

</li></ul>


<a name="SEC48"></a>
<h2 class="section"> <a href="#TOC48">9.3 Кросс-компиляция в Linux для Windows</a> </h2>

<ul class="toc">
<li>
Установите утилиты кросс-компиляции MinGW, доступные на сайте <a href="http://www.mingw.org/">http://www.mingw.org/</a>.

</li><li>
Установите версию SDL для Win32 (<a href="http://www.libsdl.org/">http://www.libsdl.org</a>), распаковав <tt>`i386-mingw32msvc.tar.gz'</tt>. Настройте переменную окружения PATH, чтобы <tt>`i386-mingw32msvc-sdl-config'</tt> мог быть запущен скриптом настройки QEMU.

</li><li>
Настройте QEMU для кросс-компиляции под Windows:
<table><tbody><tr><td>&nbsp;</td><td><pre class="example">./configure --enable-mingw32
</pre></td></tr></tbody></table><p>Если необходимо, вы можете изменить
кросс-префикс согласно префиксу, выбранному для утилит MinGW, с помощью
опции -cross-prefix. Вы также можете использовать -prefix для указания
пути установки Win32.
</p>
</li><li> Вы можете установить QEMU в каталог установки, выполнив <tt>`make install'</tt>. Не забудьте скопировать <tt>`SDL.dll'</tt> в каталог установки.

</li></ul>

<p>Замечание: в настоящий момент похоже, что Wine не может запустить QEMU для Win32.
</p>

<a name="SEC49"></a>
<h2 class="section"> <a href="#TOC49">9.4 Mac OS X</a> </h2>

<p>Патчи Mac OS X не полностью интегрированы в QEMU, поэтому всю
необходимую информацию следует искать в архиве почтовой рассылки QEMU.
</p>
<a name="SEC_Contents"></a>
<table border="0" cellpadding="1" cellspacing="1">
<tbody><tr><td align="left" valign="middle">[<a href="#SEC1" title="Cover (top) of document">Top</a>]</td>
<td align="left" valign="middle">[<a href="#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td align="left" valign="middle">[Index]</td>
<td align="left" valign="middle">[<a href="#SEC_About" title="About (help)"> ? </a>]</td>
</tr></tbody></table>
<h1>About This Document</h1>
<p>
  This document was generated by <em>Acid Jack</em> on <em>March, 19 2006</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
</p>
<p>
  The buttons in the navigation panels have the following meaning:
</p>
<table border="1">
  <tbody><tr>
    <th> Button </th>
    <th> Name </th>
    <th> Go to </th>
    <th> From 1.2.3 go to</th>
  </tr>
  <tr>
    <td align="center"> [ &lt; ] </td>
    <td align="center">Back</td>
    <td>previous section in reading order</td>
    <td>1.2.2</td>
  </tr>
  <tr>
    <td align="center"> [ &gt; ] </td>
    <td align="center">Forward</td>
    <td>next section in reading order</td>
    <td>1.2.4</td>
  </tr>
  <tr>
    <td align="center"> [ &lt;&lt; ] </td>
    <td align="center">FastBack</td>
    <td>beginning of this chapter or previous chapter</td>
    <td>1</td>
  </tr>
  <tr>
    <td align="center"> [ Up ] </td>
    <td align="center">Up</td>
    <td>up section</td>
    <td>1.2</td>
  </tr>
  <tr>
    <td align="center"> [ &gt;&gt; ] </td>
    <td align="center">FastForward</td>
    <td>next chapter</td>
    <td>2</td>
  </tr>
  <tr>
    <td align="center"> [Top] </td>
    <td align="center">Top</td>
    <td>cover (top) of document</td>
    <td> &nbsp; </td>
  </tr>
  <tr>
    <td align="center"> [Contents] </td>
    <td align="center">Contents</td>
    <td>table of contents</td>
    <td> &nbsp; </td>
  </tr>
  <tr>
    <td align="center"> [Index] </td>
    <td align="center">Index</td>
    <td>index</td>
    <td> &nbsp; </td>
  </tr>
  <tr>
    <td align="center"> [ ? ] </td>
    <td align="center">About</td>
    <td>about (help)</td>
    <td> &nbsp; </td>
  </tr>
</tbody></table>

<p>
  where the <strong> Example </strong> assumes that the current position is at <strong> Subsubsection One-Two-Three </strong> of a document of the following structure:
</p>

<ul>
  <li> 1. Section One
    <ul>
      <li>1.1 Subsection One-One
        <ul>
          <li>...</li>
        </ul>
      </li>
      <li>1.2 Subsection One-Two
        <ul>
          <li>1.2.1 Subsubsection One-Two-One</li>
          <li>1.2.2 Subsubsection One-Two-Two</li>
          <li>1.2.3 Subsubsection One-Two-Three &nbsp; &nbsp;
            <strong>&lt;== Current Position </strong></li>
          <li>1.2.4 Subsubsection One-Two-Four</li>
        </ul>
      </li>
      <li>1.3 Subsection One-Three
        <ul>
          <li>...</li>
        </ul>
      </li>
      <li>1.4 Subsection One-Four</li>
    </ul>
  </li>
</ul>

<hr size="1">
<p>
 <font size="-1">
  This document was generated by <em>Acid Jack</em> on <em>March, 19 2006</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.<br>
  Плюс небольшая правка готового HTML-кода до удобоваримого состояния :)
 </font>
 <br>

</p>

</body></html>