<html>

<head>
<title>Деревья классификации</title>
</head>

<body BACKGROUND="../tile1.gif">
<font SIZE="5" COLOR="AA0000"><b>

<p align="center">Деревья классификации</b></font></p>

<hr SIZE="1">

<p><a NAME="index"></a> 

<ul>
  <li><a href="stclatre.html#basic">Основные идеи</a></li>
  <li><a href="stclatre.html#character">Характеристики деревьев
    классификации</a> <ul>
      <li><a HREF="stclatre.html#character1">Иерархическая природа
        деревьев классификации</a> </li>
      <li><a HREF="stclatre.html#character2">Гибкость метода деревьев
        классификации</a> </li>
      <li><a HREF="stclatre.html#character3">Сила и слабости метода
        деревьев классификации</a></li>
    </ul>
  </li>
  <li><a href="stclatre.html#computation">Вычислительные методы </a><ul>
      <li><a HREF="stclatre.html#computation1">Выбор критерия точности
        прогноза</a> </li>
      <li><a HREF="stclatre.html#computation2">Выбор типа ветвления</a> </li>
      <li><a HREF="stclatre.html#computation3">Определение момента
        прекращения ветвлений</a> </li>
      <li><a HREF="stclatre.html#computation4">Определение
        &quot;подходящих&quot; размеров дерева</a> </li>
    </ul>
  </li>
  <li><a href="stclatre.html#comparison">Сравнение с другими
    программами построения деревьев классификации</a></li>
</ul>

<hr SIZE="1">

<p><a name="basic"></a><br>
<font size="5" color="#000080">Основные идеи</font></p>

<p><em><a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees">Деревья
классификации</a> </em>- это метод, позволяющий
предсказывать принадлежность наблюдений или
объектов к тому или иному классу категориальной
зависимой переменной в зависимости от
соответствующих значений одной или нескольких
предикторных переменных. Построение <em>деревьев
классификации</em> - один из наиболее важных
методов, используемых при проведении <em><a href="http://proxy/home/textbook/glossary/gloss_d.html#Data Mining">&quot;добычи
данных&quot;</a></em>.</p>

<p>Цель построения деревьев классификации
заключается в предсказании (или объяснении)
значений категориальной зависимой переменной, и
поэтому используемые методы тесно связаны с
более традиционными методами <em><a href="stdiscan.html">Дискриминантного
анализа</a></em>, <a href="stcluan.html"><em>Кластерного анализа</em></a>,
<em><a href="stnonpar.html">Непараметрической статистики</a></em>
и <a href="stnonlin.html"><em>Нелинейного оценивания</em></a>.
Широкая сфера применимости деревьев
классификации делает их весьма привлекательным
инструментом анализа данных, но не следует
поэтому полагать, что его рекомендуется
использовать вместо традиционных методов
статистики. Напротив, если выполнены более
строгие теоретические предположения, налагаемые
традиционными методами, и выборочное
распределение обладает некоторыми специальными
свойствами, то более результативным будет
использование именно традиционных методов.
Однако, как метод разведочного анализа, или как
последнее средство, когда отказывают все
традиционные методы, деревья классификации, по
мнению многих исследователей, не знают себе
равных. </p>

<p>Что же такое <a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees"><em>деревья
классификации</em></a>? Представьте, что вам нужно
придумать устройство, которое отсортирует
коллекцию монет по их достоинству (например, 1, 2, 3
и 5 копеек). Предположим, что какое-то из измерений
монет, например - диаметр, известен и, поэтому,
может быть использован для построения
иерархического устройства сортировки монет.
Заставим монеты катиться по узкому желобу, в
котором прорезана щель размером с однокопеечную
монету. Если монета провалилась в щель, то это 1
копейка; в противном случае она продолжает
катиться дальше по желобу и натыкается на щель
для двухкопеечной монеты; если она туда
провалится, то это 2 копейки, если нет (значит это 3
или 5 копеек) - покатится дальше, и так далее. Таким
образом, мы построили дерево классификации.
Решающее правило, реализованное в этом дереве
классификации , позволяет эффективно
рассортировать горсть монет, а в общем случае
применимо к широкому спектру задач
классификации. </p>

<p>Изучение <a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees"><em>деревьев
классификации</em></a> не слишком распространено в
вероятностно-статистическом распознавании
образов (см. работу Ripley, 1996), однако они широко
используются в таких прикладных областях, как
медицина (диагностика), программирование (анализ
структуры данных), ботаника (классификация) и
психология (теория принятия решений). Деревья
классификации идеально приспособлены для
графического представления, и поэтому сделанные
на их основе выводы гораздо легче
интерпретировать, чем если бы они были
представлены только в числовой форме. </p>

<p><img SRC="../popups/popup136.gif" WIDTH="375" HEIGHT="236"></p>

<p><em><a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees">Деревья
классификации</a></em> могут быть, а иногда и бывают
очень сложным. Однако использование специальных
графических процедур, позволяет упростить
интерпретацию результатов даже для очень
сложных деревьев. Если пользователя интересуют
прежде всего условия попадания объекта в один
определенный класс, например, в класс с <em>высоким</em>
уровнем отклика, он может обратиться к
специальной дискретной <em><a href="../glossary/gloss_3m.html#Contour Plot">Карте линий уровня</a></em>
, показывающей, к какой из терминальных вершин
дерева классификации отнесены большинство
наблюдений с высоким уровнем отклика. </p>

<p><img SRC="../popups/popup143.gif" WIDTH="263" HEIGHT="193"></p>

<p>В примере, показанном на этой <a href="../glossary/gloss_3m.html#Contour Plot"><em>Карте линий уровня</em></a>
, мы можем мысленно &quot;пройти&quot; по ветвям
дерева, ведущим к терминальной вершине 8, чтобы
понять, при каких условиях достигается <em>высокий</em>
уровень отклика. </p>

<p>Возможность графического представления
результатов и простота интерпретации во многом
объясняют большую популярность <em><a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees">деревьев
классификации</a></em> в прикладных областях, однако
наиболее важными отличительными свойствами
деревьев классификации является их
иерархичность и широкая применимость.</p>

<p>Вычислительные аспекты методов деревьев
классификации описаны в разделе <a href="stclatre.html#computation"><em>Вычислительные методы</em></a>.
См. также раздел <a href="stdatmin.html#eda">Методы
разведочного анализа данных</a>. </p>

<table ALIGN="RIGHT">
  <tr>
    <td><font size="1"><a HREF="stclatre.html#index">В начало</a></font> </td>
  </tr>
</table>

<p><br CLEAR="RIGHT">
<a NAME="character"></a> </p>

<p><font size="5" color="#000080">Характеристики деревьев
классификации</font></p>

<p><a name="character1"></a><font size="4" color="#000080">Иерархическая
природа деревьев классификации</font></p>

<p>В книге Breiman et al. (1984) приводится ряд примеров
применения <em><a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees">деревьев
классификации</a></em>. Один из них посвящен
диагностике больных, поступающих в стационар с
сердечным приступом. В приемном отделении у них
измеряют несколько десятков показателей
(частоту пульса, кровяное давление и т.д.).
Одновременно в базу данных заносится много
другой информации о больном (возраст,
перенесенные болезни и др.). Из последующей
истории пациента можно, в частности, выделить
такой показатель: прожил ли он 30 дней (или более)
после приступа. Для разработки методов лечения
больных с сердечной недостаточностью, а также
для развития разделов медицинской науки,
касающихся болезней сердца, было бы весьма
полезно научиться по данным первичного
обследования выявлять пациентов с высокой
степенью риска (тех, кто, вероятнее всего, не
сможет прожить больше 30 дней). Одно из деревьев
классификации , построенных авторами для этой
задачи, представляло собой довольно простое
дерево решений с тремя вопросами. На словах это
бинарное <em><a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees">дерево
классификации</a></em> можно описать следующей
фразой: &quot;Если нижнее давление у пациента в
течение первых суток не опускается ниже 91, то,
если его возраст превосходит 62.5 года, то, если у
него наблюдается синусоидальная тахикардия, то в
этом и только в этом случае следует ожидать, что
пациент не сможет прожить 30 дней.&quot; Из этого
предложения несложно представить себе
соответствующее &quot;дерево&quot; решений. Вопросы
задаются последовательно (иерархически), и
окончательное решение зависит от ответов на все
предыдущие вопросы. Это похоже на то, как
положение листа на дереве можно задать, указав
ведущую к нему последовательность ветвей
(начиная со ствола и кончая самой последней
веточкой, на которой лист растет). Иерархическое
строение <em><a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees">дерева
классификации</a></em> - одно из наиболее важных его
свойств (не следует, однако, чересчур буквально
принимать аналогию между ним и настоящим
деревом; деревья решений чаще всего рисуются на
бумаге вверх ногами, так что если уж искать
аналогии в живой природе, то придется обратиться
к такому мало поэтичному образу, как корневая
система растения).</p>

<p>Иерархическую структуру <em><a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees">дерева
классификации</a></em> легко себе уяснить, сравнив
используемую там процедуру принятия решения с
тем, что происходит при проведении <em><a href="stdiscan.html">Дискриминантного анализа</a></em>.
Классический линейный дискриминантный анализ
данных по сердечной недостаточности выдал бы
набор коэффициентов, задающих одну, вполне
определенную линейную комбинацию показателей
кровяного давления, возраста и данных о
синусовой тахикардии, которая наилучшим образом
отделяет пациентов с высоким уровнем риска от
остальных. Значение дискриминантной функции для
каждого пациента будет вычисляться как
комбинация результатов измерений трех
предикторных переменных с весами, которые
задаются соответствующими коэффициентами
дискриминантной функции. При классификации
данного пациента как имеющего высокий (низкий)
уровень риска принимаются в расчет одновременно
значения всех трех предикторных переменных.
Пусть, например, предикторные переменные
обозначаются через P (минимальное за последние
сутки систолическое кровяное давление), A
(возраст) и T (наличие синусоидальной тахикардии: 0
= нет; 1 = есть), p, a и t - соответствующие им весовые
коэффициенты в дискриминантной функции, а c -
&quot;пороговое значение&quot; дискриминантной
функции, разделяющее пациентов на два класса.
Решающее правило будет тогда иметь вид &quot;если
для данного пациента pP + aA + tT - c меньше или равно
нулю, то у него низкий уровень риска, иначе -
высокий уровень риска.&quot; </p>

<p>В случае же с решающим деревом, построенным в
Breiman et al. (1984), процедура будет иметь следующий,
иерархический, вид: пусть значения p, a и t равны
соответственно -91, -62.5 и 0, тогда правило
формулируется так: &quot;Если p + P меньше или равно
нулю, то у пациента низкий уровень риска, иначе
если a + A меньше или равно нулю, то у пациента
низкий уровень риска, иначе если t + T меньше или
равно нулю, то у пациента низкий уровень риска,
иначе у пациента высокий уровень риска.&quot; На
первый взгляд, процедуры принятия решения <a href="stdiscan.html"><em>Дискриминантного анализа</em></a> и <a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees"><em>деревьев
классификации</em></a> выглядят похожими, так в
обеих участвуют решающие уравнения и
коэффициенты. Однако имеется принципиальное
различие между одновременным принятием решения
в <a href="stdiscan.html"><em>Дискриминантном анализе</em></a> и
последовательным (иерархическим) в <a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees"><em>деревьях
классификации</em></a>. </p>

<p>Различие между этими двумя подходами станет
яснее, если посмотреть, как в том и другом случае
выполняется <em><a href="stmulreg.html">Регрессия</a></em>. В
рассматриваемом примере риск представляет собой
дихотомическую зависимую переменную, и
прогнозирование с помощью <a href="stdiscan.html"><em>Дискриминантного
анализа</em></a> осуществляется путем <em>одновременной</em>
множественной регрессии риска на три
предикторных переменных для всех пациентов. С
другой стороны, прогнозирование методом <a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees"><em>деревьев
классификации</em></a> состоит из трех отдельных
этапов простого регрессионного анализа: сначала
берется регрессия риска на переменную P для всех
пациентов, затем - на переменную A для тех
пациентов, которые не были классифицированы как
низкорисковые на первом шаге регрессии, и,
наконец - на переменную T для пациентов, не
отнесенных к низкорисковым на втором шаге. Здесь
отчетливо проявляются различие одновременного
принятия решения в <a href="stdiscan.html"><em>Дискриминантном
анализе</em></a> и последовательного (<em>рекурсивного,
иерархического</em>) -- в <em>деревьях классификации</em>.
Эта характеристика <a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees"><em>деревьев
классификации</em></a> имеет далеко идущие
последствия. </p>

<p><a name="character2"></a><font size="4" color="#000080">Гибкость метода
деревьев классификации</font></p>

<p>Другая отличительная черта метода <a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees"><em>деревьев
классификации</em></a> - это присущая ему гибкость.
Мы уже сказали о способности деревьев
классификации последовательно изучать эффект
влияния отдельных переменных. Есть еще целый ряд
причин, делающих <em>деревья классификации</em>
более гибким средством, чем традиционные методы
анализа. Способность <em>деревьев классификации</em>
выполнять <em>одномерное ветвление</em> для анализа
вклада отдельных переменных дает возможность
работать с предикторными переменными различных
типов. В примере с сердечными приступами,
рассмотренном в работе Breiman et al. (1984), давление и
возраст являются непрерывными, а
наличие/отсутствие синусоидальной тахикардии -
категориальной (двухуровневой) предикторной
переменной. Простое разветвление предиктора
можно было бы выполнить, даже если бы тахикардия
измерялась по трехуровневой категориальной
шкале (например: 0 = отсутствует; 1 = присутствует; 3
= неизвестно или показания неясны). Если новая
категория содержит какую-то дополнительную
информацию о риске, то к дереву решений можно
добавить новые узлы, учитывающие и использующие
эту информацию. Таким образом, при построении
одномерных ветвлений деревья классификации
позволяют использовать для ветвления как
непрерывные, так и категориальные переменные. </p>

<p>В классическом <a href="stdiscan.html"><em>линейном
дискриминантном анализе</em></a> требуется, чтобы
предикторные переменные были измерены как
минимум в <a href="../glossary/gloss_i.html#Interval Scale"><em>интервальной
шкале</em></a>. В случае же <em><a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees">деревьев
классификации</a></em> с одномерным ветвлением по
переменным, измеренным в <em><a href="../glossary/gloss_p.html#Ordinal Scale">порядковой шкале</a></em>,
любое монотонное преобразование предикторной
переменной (т.е. любое преобразование,
сохраняющее порядок в значениях переменной)
создаст ветвление на те же самые предсказываемые
классы объектов (наблюдений) (если используется
Одномерное ветвление по методу CART, смотрите Breimen
и др., 1984). Поэтому дерево классификации на основе
одномерного ветвления можно строить независимо
от того, соответствует ли единичное изменение
непрерывного предиктора единичному изменению
лежащей в его основе величины или нет,
достаточно, чтобы предикторы были измерены в <a href="../glossary/gloss_p.html#Ordinal Scale"><em>порядковой шкале</em></a>.
Иными словами, на способ измерения предикторной
переменной накладываются гораздо более слабые
ограничения. </p>

<p><em><a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees">Деревья
классификации</a></em> не ограничены использованием
только <em>одномерных ветвлений</em> по
предикторным переменным. Если непрерывные
предикторы измерены хотя бы в <a href="../glossary/gloss_i.html#Interval Scale"><em>интервальной шкале</em></a>,
то деревья классификации могут использовать <em>ветвления
по линейным комбинациям</em>, подобно тому, как это
делается в <em><a href="stdiscan.html">линейном
дискриминантном анализе</a></em>. При этом ветвления
по линейным комбинациям, применяемые для
построения <em>деревьев классификации</em>, имеют
ряд важных отличий от своих аналогов из <em><a href="stdiscan.html">дискриминантного анализа</a></em>. В
линейном дискриминантном анализе максимальное
количество <em>линейных дискриминантных функций</em>
равно минимуму из числа предикторных переменных
и числа классов зависимой переменной минус один.
При <em>рекурсивном</em> подходе, который
используется в модуле <em>Деревья классификации</em>,
мы не связаны этим ограничением. Например, для
десяти предикторных переменных и всего двух
классов зависимой переменной мы можем
использовать десятки <em>последовательных
ветвлений по линейным комбинациям</em>. Это
выгодно отличается от единственного ветвления
по линейной комбинации, предлагаемого в данном
случае традиционным нерекурсивным линейным
дискриминантным анализом. При этом значительная
часть информации, содержащейся в предикторных
переменных, может остаться неиспользованной.</p>

<p>Рассмотрим теперь ситуацию, когда имеется
много категорий, но мало предикторов.
Предположим, например, что мы хотим
рассортировать монеты различных достоинств,
имея только данные измерений их толщины и
диаметра. В обычном линейном дискриминантном
анализе можно получить самое большее две
дискриминантных функции, и монеты могут быть
успешно рассортированы только в том случае, если
они различаются не более чем двумя параметрами,
представимыми в виде линейных комбинаций
толщины и диаметра монеты. Напротив, в подходе,
который используется в модуле <em>Деревья
классификации</em>, мы не связаны ограничениями в
количестве ветвлений по линейным комбинациям,
которое можно проделать.</p>

<p>Аппарат ветвления по линейным комбинациям,
реализованный в модуле <a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees"><em>Деревья
классификации</em></a>, может быть использован также
как метод анализа при построении деревьев
классификации с одномерным ветвлением. На самом
деле одномерное ветвление есть частный случай
ветвления по линейной комбинации. Представьте
себе такое ветвление по линейной комбинации, при
котором весовые коэффициенты при всех
предикторных переменных, кроме какой-то одной,
равны нулю. Поскольку значение комбинации
фактически зависит от значений только одной
предикторной переменной (коэффициент при
которой отличен от нуля), полученное в результате
этого ветвление будет одномерным. </p>

<p>Реализованные в модуле Деревья классификации
методы дискриминантного <em>Одномерного
ветвления по категориальным и порядковым
предикторам</em> и дискриминантного <em>Многомерного
ветвления по линейным комбинациям порядковых
предикторов</em> представляют собой адаптацию
соответствующих <a href="../glossary/gloss_a.html#Algorithm">алгоритмов</a>
пакета QUEST (Quick, Unbiased, Efficient Statistical Trees). <a href="../glossary/gloss_p.html#Quest">QUEST</a> - это программа
деревьев классификации, разработанная Loh и Shih
(1997), в которой используются улучшенные варианты
метода рекурсивного квадратичного
дискриминантного анализа и которая содержит ряд
новых средств для повышения надежности и
эффективности деревьев классификации, которые
она строит. </p>

<p>Алгоритмы пакета <a href="../glossary/gloss_p.html#Quest">QUEST</a>
довольно сложны (ссылки на источники, где имеются
описания алгоритмов, см. в разделе Замечания о
вычислительных алгоритмах), однако в модуле
Деревья классификации имеется опция Тип
ветвления, предоставляющая пользователю другой,
концептуально более простой подход.
Реализованный здесь алгоритм <em>Одномерного
ветвления по методу CART</em> является адаптацией
алгоритмов пакета <a href="../glossary/gloss_p.html#Cart">CART</a>, см.
Breiman и др. (1984). <a href="../glossary/gloss_p.html#Cart">CART</a> (Classification
And Regression Trees) - это программа <em><a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees">деревьев
классификации</a></em>, которая при построении
дерева осуществляет полный перебор всех
возможных вариантов <em>одномерного ветвления</em>.</p>

<p>Опции анализа <a href="../glossary/gloss_p.html#Quest">QUEST</a> и <a href="../glossary/gloss_p.html#Cart">CART</a> естественно дополняют
друг друга. В случаях, когда имеется много
предикторных переменных с большим числом
уровней, поиск методом <a href="../glossary/gloss_p.html#Cart">CART</a>
может оказаться довольно продолжительным. Кроме
того, этот метод имеет склонность выбирать для
ветвления те предикторные переменные, у которых
больше уровней. Однако поскольку здесь
производится полный перебор вариантов, есть
гарантия, что будет найден вариант ветвления,
дающий наилучшую классификацию (по отношению к
обучающей выборке; вообще говоря, это
необязательно будет так для <em><a href="../glossary/gloss_k.html#Cross-Validation">кросс-проверочных
выборок</a></em>). </p>

<p>Метод <a href="../glossary/gloss_p.html#Quest">QUEST</a> - быстрый и
несмещенный. Его преимущество в скорости перед
методом <a href="../glossary/gloss_p.html#Cart">CART</a> становится
особенно заметным, когда предикторные
переменные имеют десятки уровней (см. Loh &amp; Shih, 1997,
где приводится пример, когда метод <a href="../glossary/gloss_p.html#Quest">QUEST</a> потребовал 1 секунды
времени процессора, а <a href="../glossary/gloss_p.html#Cart">CART</a> -
30.5 часов). Отсутствие у метода <a href="../glossary/gloss_p.html#Quest">QUEST</a> смещения в выборе
переменных для ветвления также является его
существенным преимуществом в случаях, когда одни
предикторные переменные имеют мало уровней, а
другие - много (предикторы со многими уровнями
часто порождают &quot;методы тыка&quot;, которые
хорошо согласуются с данными, но дают плохую
точность прогноза, см. Doyle, 1973, и Quinlan &amp; Cameron-Jones,
1995). Наконец, метод <a href="../glossary/gloss_p.html#Quest">QUEST</a> не
жертвует точностью прогноза ради скорости
вычислений (Lim, Loh, &amp; Shih, 1997). Сочетание опций <a href="../glossary/gloss_p.html#Quest">QUEST</a> и <a href="../glossary/gloss_p.html#Cart">CART</a>
позволяет полностью использовать всю гибкость
аппарата <em><a href="../glossary/gloss_k.html#Cross-Validation">деревьев
классификации</a></em>. </p>

<p><a name="character3"></a><font size="4" color="#000080">Сила и слабости
метода деревьев классификации</font></p>

<p>Преимущества (по крайней мере, для некоторых
областей применения) метода <em><a href="../glossary/gloss_k.html#Cross-Validation">деревьев
классификации</a></em> перед такими традиционными
методами, как <a href="stdiscan.html">линейный
дискриминантный анализ</a>, можно
проиллюстрировать на простом условном примере.
Чтобы соблюсти объективность, мы затем
рассмотрим примеры с другим набором данных, где
методы <em>линейного дискриминантного анализа</em>
превосходят метод <em>деревьев классификации</em>.</p>

<p>Предположим, что у Вас имеются данные о
координатах - Долготе - Longitude и Широте - Latitude - для 37
циклонов, достигающих силы урагана, по двум
классификациям циклонов - Baro и Trop. Приведенный
ниже модельный набор данных использовался для
целей иллюстрации в работе Elsner, Lehmiller, и Kimberlain (1996),
авторы которой исследовали различия между
бароклинными и тропическими циклонами в
Северной Атлантике. </p>

<table Border="1">
  <tr>
    <th COLSPAN="3" ALIGN="LEFT"><font SIZE="2" COLOR="BLUE">ДАННЫЕ: Barotrop.sta 3v</font></th>
  </tr>
  <tr>
    <th><font SIZE="2" COLOR="BLUE">LONGITUD</font></th>
    <th><font SIZE="2" COLOR="BLUE">LATITUDE</font></th>
    <th><font SIZE="2" COLOR="BLUE">CLASS</font></th>
  </tr>
  <tr>
    <td ALIGN="RIGHT"><font SIZE="2" COLOR="BLUE">59.00<br>
    59.50<br>
    60.00<br>
    60.50<br>
    61.00<br>
    61.00<br>
    61.50<br>
    61.50<br>
    62.00<br>
    63.00<br>
    63.50<br>
    64.00<br>
    64.50<br>
    65.00<br>
    65.00<br>
    65.00<br>
    65.50<br>
    65.50<br>
    65.50<br>
    66.00<br>
    66.00<br>
    66.00<br>
    66.50<br>
    66.50<br>
    66.50<br>
    67.00<br>
    67.50<br>
    68.00<br>
    68.50<br>
    69.00<br>
    69.00<br>
    69.50<br>
    69.50<br>
    70.00<br>
    70.50<br>
    71.00<br>
    71.50</font></td>
    <td ALIGN="RIGHT"><font SIZE="2" COLOR="BLUE">17.00<br>
    21.00<br>
    12.00<br>
    16.00<br>
    13.00<br>
    15.00<br>
    17.00<br>
    19.00<br>
    14.00<br>
    15.00<br>
    19.00<br>
    12.00<br>
    16.00<br>
    12.00<br>
    15.00<br>
    17.00<br>
    16.00<br>
    19.00<br>
    21.00<br>
    13.00<br>
    14.00<br>
    17.00<br>
    17.00<br>
    18.00<br>
    21.00<br>
    14.00<br>
    18.00<br>
    14.00<br>
    18.00<br>
    13.00<br>
    15.00<br>
    17.00<br>
    19.00<br>
    12.00<br>
    16.00<br>
    17.00<br>
    21.00</font></td>
    <td ALIGN="RIGHT"><font SIZE="2" COLOR="BLUE">BARO<br>
    BARO<br>
    BARO<br>
    BARO<br>
    BARO<br>
    BARO<br>
    BARO<br>
    BARO<br>
    BARO<br>
    TROP<br>
    TROP<br>
    TROP<br>
    TROP<br>
    TROP<br>
    TROP<br>
    TROP<br>
    TROP<br>
    TROP<br>
    TROP<br>
    TROP<br>
    TROP<br>
    TROP<br>
    TROP<br>
    TROP<br>
    TROP<br>
    TROP<br>
    TROP<br>
    BARO<br>
    BARO<br>
    BARO<br>
    BARO<br>
    BARO<br>
    BARO<br>
    BARO<br>
    BARO<br>
    BARO<br>
    BARO</font></td>
  </tr>
</table>

<p>Линейный дискриминантный анализ циклонов на
предмет их принадлежности к Классу - Baro или Trop на
основе данных о Долготе и Широте в качестве
предикторов позволил правильно
классифицировать только 20 наблюдений из 37 (54%). <em><a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees">Дерево
классификации</a></em> для переменной Class,
использующее опцию Полный перебор деревьев с
одномерным ветвлением по методу CART сумело
правильно классифицировать все 37 циклонов. Граф
дерева для этого дерева классификации показан
ниже.</p>

<p><img SRC="../popups/popup136.gif" WIDTH="375" HEIGHT="236"></p>

<p>В заголовке графа приведена общая информация,
согласно которой полученное дерево
классификации имеет 2 ветвления и 3 терминальные
вершины. Терминальные вершины (или, как их иногда
называют, листья) это узлы дерева, начиная с
которых никакие решения больше не принимаются.
На рисунке терминальные вершины показаны
красными пунктирными линиями, а остальные - так
называемые решающие вершины или вершины
ветвления - сплошными черными линиями. Началом
дерева считается самая верхняя решающая вершина,
которую иногда также называют корнем дерева. На
рисунке она расположена в левом верхнем углу и
помечена цифрой 1. Первоначально все 37 циклонов
приписываются к этой корневой вершине и
предварительно классифицируются как <em>Baro</em> - на
это указывает надпись <em>Baro</em> в правом верхнем
углу вершины. Класс <em>Baro</em> был выбран для
начальной классификации потому, что число
циклонов <em>Baro</em> немного больше, чем циклонов <em>Trop</em>
(см. <a href="../glossary/gloss_2m.html#Histograms, 2D">гистограмму</a>,
изображенную внутри корневой вершины). В левом
верхнем углу графа имеется надпись - легенда ,
указывающая, какие столбики гистограммы вершины
соответствуют циклонам <em>Baro</em> и <em>Trop</em>.</p>

<p>Корневая вершина разветвляется на две новых
вершины. Под корневой вершиной имеется текст,
описывающий схему данного ветвления. Из него
следует, что циклоны, имеющие значение Долготы
меньшее или равное 67.75, отнесены к вершине номер 2
и предположительно классифицированы как Trop, а
циклоны с Долготой, большей 67.75 приписаны к
вершине 3 и классифицированы как <em>Baro</em>. Числа 27
и 10 над вершинами 2 и 3 соответственно обозначают
число наблюдений, попавших в эти две дочерние
вершины из родительской корневой вершины. Затем
точно так же разветвляется вершина 2. В
результате 9 циклонов со значениями Долготы
меньшими или равными 62.5 приписываются к вершине 4
и классифицируются как <em>Baro</em>, а остальные 18
циклонов с Долготой, большей 62.5, - к вершине 5 и
классифицируются как <em>Trop</em>.</p>

<p>На <em>Графе дерева</em> вся эта информация
представлена в простом, удобном для восприятия
виде, так что для ее понимания требуется гораздо
меньше времени, чем его ушло у Вас на чтение двух
последних абзацев. Если теперь мы посмотрим на
гистограммы терминальных вершин дерева,
расположенных в нижней строке, то увидим, что <em><a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees">дерево
классификации</a></em> сумело абсолютно правильно
расклассифицировать циклоны. Каждая из
терминальных вершин &quot;чистая&quot;, то есть не
содержит неправильно классифицированных
наблюдений. Вся информация, содержащаяся в Графе
дерева, продублирована в таблице результатов <em>Структура
дерева</em>, которая приведена ниже. </p>

<table BORDER="1">
  <tr>
    <th COLSPAN="8" ALIGN="LEFT"><font SIZE="2" COLOR="BLUE">Структура дерева
    &nbsp; (barotrop.sta)</font></th>
  </tr>
  <tr>
    <th><font SIZE="2" COLOR="BLUE">ДЕРЕВЬЯ<br>
    КЛАССИФИКАЦИИ</font></th>
    <th COLSPAN="7" ALIGN="LEFT"><font SIZE="2" COLOR="BLUE">Дочерние вершины,
    наблюдаемые,<br>
    предсказанный класс, условия ветвления</font></th>
  </tr>
  <tr>
    <th ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">&nbsp;<br>
    Вершина</font></th>
    <th ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">Левая<br>
    вершина</font></th>
    <th ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">Правая<br>
    вершина</font></th>
    <th ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">Класс<br>
    BARO</font></th>
    <th ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">Класс<br>
    TROP</font></th>
    <th ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">Предсказ.<br>
    класс</font></th>
    <th ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">Ветвл. по<br>
    констант.</font></th>
    <th ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">Ветвл. по<br>
    перемен.</font></th>
  </tr>
  <tr>
    <th ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">1<br>
    2<br>
    3<br>
    4<br>
    5</font></th>
    <td ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">2<br>
    4<br>
    &nbsp;<br>
    &nbsp;<br>
    &nbsp;</font></td>
    <td ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">3<br>
    5<br>
    &nbsp;<br>
    &nbsp;<br>
    &nbsp;</font></td>
    <td ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">19<br>
    &nbsp;&nbsp;9<br>
    10<br>
    &nbsp;&nbsp;9<br>
    &nbsp;&nbsp;0</font></td>
    <td ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">18<br>
    18<br>
    &nbsp;&nbsp;0<br>
    &nbsp;&nbsp;0<br>
    18</font></td>
    <td ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">BARO<br>
    TROP<br>
    BARO<br>
    BARO<br>
    TROP</font></td>
    <td ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">-67.75<br>
    -62.50<br>
    &nbsp;<br>
    &nbsp;<br>
    &nbsp;</font></td>
    <td ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">LONGITUD<br>
    LONGITUD<br>
    &nbsp;<br>
    &nbsp;<br>
    &nbsp;</font></td>
  </tr>
</table>

<p>Обратите внимание на то, что в этой таблице
результатов вершины с 3-й по 5-ю помечены как
терминальные, так как в них не происходит
ветвления. Обратите также внимание на знаки
Постоянных ветвления - например -67.75 для вершины 1.
В Графе дерева условие ветвления в вершине 1
записано как <em>LONGITUD&nbsp; 67.75</em> вместо
эквивалентного <em>-67.75 + LONGITUD 0</em>. Это сделано
просто для экономии места на рисунке. </p>

<p>Если делаются одномерные ветвления, то каждой
предикторной переменной можно приписать ранг по
шкале от 0 до 100 в зависимости от степени ее
влияния на отклик зависимой переменной. В нашем
примере очевидно, что <em>Долгота </em>- Longitude имеет
большую важность, а <em>Широта </em>- Latitude -
относительно небольшую.</p>

<p><img SRC="../popups/popup140.gif" WIDTH="231" HEIGHT="170"></p>

<p><a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees">Дерево
классификации</a> для переменной <em>Класс - Class</em>,
построенное с использованием <em>Дискриминантных
одномерных ветвлений</em>, дает почти такие же
результаты. В приведенной ниже таблице
результатов Структура дерева для этого варианта
анализа константы ветвления равны -63.4716 и -67.7516 -
то есть почти те же, что получились в варианте
Полного перебора деревьев с одномерным
ветвлением по методу <a href="../glossary/gloss_p.html#Cart">CART</a> .
Здесь, однако, один циклон класса <em>Trop</em> в
терминальной вершине 2 неправильно
классифицирован как <em>Baro</em>. </p>

<table BORDER="1">
  <tr>
    <th COLSPAN="8" ALIGN="LEFT"><font SIZE="2" COLOR="BLUE">Структура дерева
    (barotrop.sta)</font></th>
  </tr>
  <tr>
    <th><font SIZE="2" COLOR="BLUE">ДЕРЕВЬЯ<br>
    КЛАССИФИКАЦИИ</font></th>
    <th COLSPAN="7" ALIGN="LEFT"><font SIZE="2" COLOR="BLUE">Дочерние вершины,
    наблюдаемые,<br>
    предсказанный класс, условия ветвления</font></th>
  </tr>
  <tr>
    <th ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">&nbsp;<br>
    Node</font></th>
    <th ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">Левая<br>
    вершина</font></th>
    <th ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">Правая<br>
    вершина</font></th>
    <th ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">Класс<br>
    BARO</font></th>
    <th ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">Класс<br>
    TROP</font></th>
    <th ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">Предсказ.<br>
    класс</font></th>
    <th ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">Ветвл. по<br>
    констант.</font></th>
    <th ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">Ветвл. по<br>
    перемен.</font></th>
  </tr>
  <tr>
    <th ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">1<br>
    2<br>
    3<br>
    4<br>
    5</font></th>
    <td ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">2<br>
    &nbsp;<br>
    4<br>
    &nbsp;<br>
    &nbsp;</font></td>
    <td ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">3<br>
    &nbsp;<br>
    5<br>
    &nbsp;<br>
    &nbsp;</font></td>
    <td ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">19<br>
    &nbsp;&nbsp;9<br>
    10<br>
    &nbsp;&nbsp;0<br>
    10</font></td>
    <td ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">18<br>
    &nbsp;&nbsp;1<br>
    17<br>
    17<br>
    0</font></td>
    <td ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">BARO<br>
    BARO<br>
    TROP<br>
    TROP<br>
    BARO</font></td>
    <td ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">-63.4716<br>
    &nbsp;<br>
    -67.7516<br>
    &nbsp;<br>
    &nbsp;</font></td>
    <td ALIGN="CENTER"><font SIZE="2" COLOR="BLUE">LONGITUD<br>
    &nbsp;<br>
    LONGITUD<br>
    &nbsp;<br>
    &nbsp;</font></td>
  </tr>
</table>

<p>Категоризованный точечный график для
переменных Долгота - Longitude и Широта - Latitude ясно
показывает, почему линейный дискриминантный
анализ так позорно провалился в задаче
предсказания переменной <em>Class</em> и почему <em><a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees">дерево
классификации</a></em> дает такие хорошие
результаты. </p>

<p>&nbsp;<img SRC="../popups/popup137.gif" WIDTH="284" HEIGHT="224"></p>

<p>График ясно показывает, что нет отчетливой
линейной связи между переменными широты, долготы
или какой-либо их линейной комбинацией с одной
стороны, и переменной <em>Class</em> - с другой.
Переменная <em>Class</em> функционально не связана с
долготой и широтой, по крайней мере, в линейном
смысле. На графике показана попытка ветвления
посредством LDF (линейной дискриминантной
функции): циклоны, относительно которых делается
прогноз <em>Trop</em>, находятся над линией ветвления,
а прогнозируемые как <em>Baro</em> - под этой линией.
Хорошо видно, что получился почти что &quot;выстрел
наугад&quot;. Возможности одномерного ветвления <a href="../glossary/gloss_p.html#Cart">CART</a> не ограничены
вычислением единственной линейной комбинации
широты и долготы, и этот метод находит
&quot;критические значения&quot; переменной Longitude ,
позволяющие получить наилучшую возможную (а в
данном случае - идеальную) классификацию для
переменной <em>Class</em>. </p>

<p>Рассмотрим теперь ситуацию, в которой
проявляются слабые стороны <em><a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees">деревьев
классификации</a></em>. Рассмотрим другой набор
данных о циклонах. Их можно найти в
демонстрационном файле данных Barotro2.sta. </p>

<table BORDER="1">
  <tr>
    <th COLSPAN="3" ALIGN="LEFT"><font SIZE="2" COLOR="BLUE">ДАННЫЕ: Barotro2.sta 3v</font></th>
  </tr>
  <tr>
    <th><font SIZE="2" COLOR="BLUE">LONGITUD</font></th>
    <th><font SIZE="2" COLOR="BLUE">LATITUDE</font></th>
    <th><font SIZE="2" COLOR="BLUE">CLASS</font></th>
  </tr>
  <tr>
    <td ALIGN="RIGHT"><font SIZE="2" COLOR="BLUE">59.00<br>
    59.50<br>
    60.00<br>
    60.50<br>
    61.00<br>
    61.00<br>
    61.50<br>
    61.50<br>
    62.00<br>
    63.00<br>
    63.50<br>
    64.00<br>
    64.50<br>
    65.00<br>
    65.00<br>
    65.00<br>
    65.50<br>
    65.50<br>
    65.50<br>
    66.00<br>
    66.00<br>
    66.00<br>
    66.50<br>
    66.50<br>
    66.50<br>
    67.00<br>
    67.50<br>
    68.00<br>
    68.50<br>
    69.00<br>
    69.00<br>
    69.50<br>
    69.50<br>
    70.00<br>
    70.50<br>
    71.00<br>
    71.50</font></td>
    <td ALIGN="RIGHT"><font SIZE="2" COLOR="BLUE">17.00<br>
    21.00<br>
    12.00<br>
    16.00<br>
    13.00<br>
    15.00<br>
    17.00<br>
    19.00<br>
    14.00<br>
    15.00<br>
    19.00<br>
    12.00<br>
    16.00<br>
    12.00<br>
    15.00<br>
    17.00<br>
    16.00<br>
    19.00<br>
    21.00<br>
    13.00<br>
    14.00<br>
    17.00<br>
    17.00<br>
    18.00<br>
    21.00<br>
    14.00<br>
    18.00<br>
    14.00<br>
    18.00<br>
    13.00<br>
    15.00<br>
    17.00<br>
    19.00<br>
    12.00<br>
    16.00<br>
    17.00<br>
    21.00</font></td>
    <td ALIGN="RIGHT"><font SIZE="2" COLOR="BLUE">BARO<br>
    BARO<br>
    TROP<br>
    BARO<br>
    TROP<br>
    TROP<br>
    BARO<br>
    BARO<br>
    TROP<br>
    TROP<br>
    BARO<br>
    TROP<br>
    TROP<br>
    TROP<br>
    TROP<br>
    BARO<br>
    TROP<br>
    BARO<br>
    BARO<br>
    TROP<br>
    TROP<br>
    BARO<br>
    BARO<br>
    BARO<br>
    BARO<br>
    TROP<br>
    BARO<br>
    TROP<br>
    BARO<br>
    TROP<br>
    TROP<br>
    TROP<br>
    BARO<br>
    TROP<br>
    TROP<br>
    TROP<br>
    BARO</font></td>
  </tr>
</table>

<p>&nbsp;</p>

<p>Линейный дискриминантный анализ для
переменной Класс - Class (<em>Baro</em> или <em>Trop</em>) с
переменными Долгота - Longitude и Широта - Latitude в
качестве предикторов правильно классифицирует
все 37 наблюдений. Анализ посредством дерева
классификации по переменной Класс - Class в случае <em><a href="stclatre.html#split3">Полного перебора деревьев с
одномерным ветвлением по методу CART</a> </em>также
дает правильную классификацию для всех 37
циклонов, но для этого требуется дерево с 5
ветвлениями и 6 терминальными вершинами. Какой
результат проще интерпретировать? В линейном
дискриминантном анализе коэффициенты
канонической дискриминантной функции при
переменных Долгота - Longitude и Широта - Latitude равны
соответственно 0.122073 и -0.633124, так что чем больше
долгота и чем меньше широта, тем вероятнее данный
циклон будет классифицирован как Trop.
Интерпретация может быть такой: циклоны в южных
широтах западной Атлантики вероятнее всего
будут циклонами Trop, а циклоны в северных широтах
восточной Атлантики - Baro. </p>

<p>Ниже показан Граф дерева для дерева
классификации в варианте анализа, в котором
используется Полный перебор деревьев с
одномерным ветвлением по методу <a href="../glossary/gloss_p.html#Cart">CART</a>. </p>

<p><img SRC="../popups/popup138.gif" WIDTH="415" HEIGHT="297"></p>

<p>Можно было бы последовательно описать все
ветвления дерева классификации, как это было
проделано в предыдущем примере, но поскольку
ветвлений много, интерпретировать результаты
было бы труднее, чем в случае одной
дискриминантной функции, получающейся при
линейном дискриминантном анализе. <br>
Вспомним, однако, про опцию <em>Многомерное
ветвление по линейным комбинациям порядковых
предикторов</em>, о которой мы говорили в разделе,
посвященном гибким возможностям модуля Деревья
классификации, и которая использует алгоритмы <a href="../glossary/gloss_p.html#Quest">QUEST</a>. <em>Граф дерева </em>для <em><a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees">дерева
классификации</a></em> , построенного путем
ветвления по линейным комбинациям, показан ниже.</p>

<p><img SRC="../popups/popup139.gif" WIDTH="202" HEIGHT="189"></p>

<p>Обратите внимание на то, что уже одно ветвление
дерева дает идеальный прогноз. Каждая из
терминальных вершин - &quot;чистая&quot;, то есть не
содержит наблюдений неправильно
классифицированных циклонов. Ветвление по
линейной комбинации в корневой вершине, ведущее
к <em>левой дочерней вершине</em> и <em>правой
дочерней вершине</em>, имеет вид &quot;<em>F(0)</em> -.2342&quot;.
Это означает, что если значение функции
ветвления (обозначено через F(0) ) для данного
циклона меньше или равно -0.2342 , то он попадет в
левую дочернюю вершину и будет классифицирован
как <em>Baro</em>, в противном случае он попадет в
правую дочернюю вершину и будет классифицирован
как <em>Trop</em>. Коэффициенты функции ветвления (0.011741
для Долготы и -0.060896 для Широты) имеют одинаковый
знак и по относительной величине близки к
соответствующим коэффициентам линейной
дискриминантной функции из линейного
дискриминантного анализа, так что оба метода в
этом примере с прогнозированием переменной Class
являются функционально эквивалентными.</p>

<p>Мораль всей этой истории об успехах и неудачах
метода <em><a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees">деревьев
классификации</a></em> можно сформулировать так:
метод деревьев классификации хорош настолько,
насколько удачным окажется выбор варианта
анализа. Чтобы построить модель, дающую хороший
прогноз, в любом случае нужно хорошо понимать
природу взаимосвязей между предикторными и
зависимыми переменными.<br>
Итак, мы увидели, что методы анализа с помощью
деревьев классификации можно охарактеризовать
как набор иерархических, чрезвычайно гибких
средств предсказания принадлежности наблюдений
(объектов) к определенному классу значений
категориальной зависимой переменной по
значениям одной или нескольких предикторных
переменных. Теперь мы готовы к тому, чтобы
рассмотреть методы построения деревьев
классификации более детально. </p>

<p>Информацию о том, для чего нужны деревья
классификации, см. в разделе <a href="stclatre.html#basic"><em>Основные
идеи</em></a>. См. также раздел <a href="stdatmin.html#eda">Методы
разведочного анализа данных</a>.</p>
<a HREF="stdatmin.html#eda">

<table ALIGN="RIGHT">
  <tr>
    <td></a><a HREF="stclatre.html#index"><font size="1">В начало</font></a> </td>
  </tr>
</table>

<p><a NAME="computation"></a><br CLEAR="RIGHT">
</p>

<p><br>
</p>

<p><font size="5" color="#000080">Вычислительные методы</font></p>

<p>Процесс построения <em><a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees">дерева
классификации</a></em> состоит из четырех основных
шагов: 

<ol>
  <li><a HREF="stclatre.html#computation1">Выбор критерия точности
    прогноза</a> </li>
  <li><a HREF="stclatre.html#computation2">Выбор типа ветвления</a> </li>
  <li><a HREF="stclatre.html#computation3">Определение момента
    прекращения ветвлений</a> </li>
  <li><a HREF="stclatre.html#computation4">Определение
    &quot;подходящих&quot; размеров дерева</a> </li>
</ol>

<p><a NAME="computation1"></a>&nbsp;</p>

<p><font size="4" color="#000080">Выбор критерия точности
прогноза</font></p>

<p>В конечном счете, цель анализа с помощью
деревьев классификации состоит в том, чтобы
получить максимально точный прогноз. К
сожалению, очень сложно четко сформулировать,
что такое точный прогноз. Эта проблема решается
&quot;переворачиванием с ног на голову&quot;: наиболее
точным прогнозом считается такой, который связан
с наименьшей ценой. Термин цена не содержит в
себе ничего загадочного. В большинстве
приложений цена - это просто доля неправильно
классифицированных наблюдений. Понятие цена
вводится для того, чтобы распространить на более
широкий класс ситуаций ту идею, что самый лучший
прогноз - такой, который дает наименьший процент
неправильных классификаций.</p>

<p>Необходимость минимизировать не просто долю
неправильно классифицированных наблюдений, а
именно потери, возникает тогда, когда некоторые
ошибки прогноза ведут к более катастрофическим
последствиям, чем другие, или же когда ошибки
некоторого типа встречаются чаще других. <em>Цена
ошибки классификации</em> для игрока, поставившего
все свое состояние на одну ставку, несоизмеримо
больше, чем от проигрыша нескольких ставок, на
которые были поставлены мелкие суммы. Может
случиться и наоборот, что потери от проигрыша
большого количества мелких ставок будут больше,
чем от проигрыша небольшого числа крупных.
Усилия, которые следует уделять для минимизации
убытков от ошибок прогноза, должны быть тем
больше, чем больше возможный размер этих убытков.
</p>

<p><strong>Априорные вероятности.</strong> Заметим,
однако, что если <em>Априорные вероятности </em>выбраны
пропорциональными размерам классов, а <a href="stclatre.html#misclasscosts"><em>Цена ошибки классификации</em></a>
- одинаковая для всех классов, то минимизация
потерь в точности эквивалентна минимизации доли
неправильно классифицированных наблюдений.
Рассмотрим априорные вероятности подробнее. Эти
величины выражают то, как мы, не располагая
никакой <em>априорной</em> информацией о значениях
предикторных переменных модели, оцениваем
вероятность попадания объекта в тот или иной
класс. Например, изучая данные об учащихся,
исключенных из школ, мы обнаружим, что в целом их
количество существенно меньше, чем тех, кто
продолжает учебу (т.е. различны исходные частоты);
поэтому <em>априорная</em> вероятность того, что
учащийся покинет школу, меньше, чем вероятность
того, что он продолжит учебу.</p>

<p>Выбор априорных вероятностей, используемых для
минимизации потерь, очень сильно влияет на
результаты классификации. Если различия между
исходными частотами в данной задаче не считаются
существенными или если мы знаем заранее, что
классы содержат примерно одинаковое количество
наблюдений, то тогда можно взять одинаковые
априорные вероятности. В случаях, когда исходные
частоты связаны с размерами классов (так будет,
например, когда мы работаем со случайной
выборкой), следует в качестве <em>оценок для
априорных вероятностей</em> взять <em>относительные
размеры классов</em> в выборке. Наконец, если Вы
(например, на основании данных предыдущих
исследований) располагаете какой-то информацией
об исходных частотах, то априорные вероятности
нужно выбирать с учетом этой информации.
Например, <em>априорная вероятность</em> человека
быть носителем рецессивного гена вдвое выше
вероятности того, что этот ген имеет проявления.
В любом случае, приписывая классу ту или иную <em>априорную
вероятность</em>, мы &quot;учитываем&quot; степень
важности ошибки классификации объектов этого
класса. Минимизация потерь - это минимизация
общего числа неправильно классифицированных
наблюдений с <em>Априорными вероятностями,
пропорциональными размерам классов</em> (и <em>Ценами
ошибки классификации</em>, одинаковыми для всех
классов), поскольку прогноз, чтобы давать меньший
итоговый процент ошибок классификации, должен
быть более точным на больших классах. </p>

<p><a NAME="misclasscosts"></a><strong>Цена ошибки классификации.</strong>
Бывает так, что по причинам, не связанным с
размерами классов, для одних классов требуется
более точный прогноз, чем для других. Гораздо
важнее выявить переносчиков инфекционного
заболевания, постоянно контактирующих с другими
людьми, чем тех же переносчиков, не имеющих
постоянных контактов, - и это независимо от
относительной численности тех и других. Если мы
примем, что избежать контактов с
&quot;контактирующим переносчиком&quot; гораздо
важнее, чем с &quot;неконтактирующим&quot;, то следует
приписать <em>ошибочной классификации</em>
&quot;контактирующего&quot; как
&quot;неконтактирующего&quot; большую цену, чем
ошибочной классификации
&quot;неконтактирующего&quot; как
&quot;контактирующего&quot;. Как уже говорилось,
минимизация потерь - это минимизация общей доли
неправильно классифицированных наблюдений с <em>Априорными
вероятностями</em>, пропорциональными размерам
классов, и <em>Ценами ошибки классификации</em>,
одинаковыми для всех классов. </p>

<p><strong>Веса наблюдений.</strong> На менее
концептуальном уровне, использование весов для <em>весовой
переменной</em> в качестве множителей наблюдений
для <em>агрегированных данных</em> также имеет
отношение к минимизации потерь. Любопытно, что
вместо того, чтобы использовать веса наблюдений
для агрегированных данных, можно ввести
подходящие <em>априорные вероятности</em> и/или <em>цены
ошибки классификации</em> и получить те же самые
результаты, не тратя времени на обработку
множества наблюдений, имеющих одинаковые
значения всех переменных. Предположим, например,
что в агрегированном множестве данных с двумя
равновеликими классами веса наблюдений из
первого класса равны 2, а наблюдений из второго
класса - 3. Если положить априорные вероятности
равными соответственно 0.4 и 0.6, цены ошибки
классификации взять одинаковыми и
проанализировать данные без весов наблюдений, то
доля неправильных классификаций получится такой
же, как если бы мы оценили априорные вероятности
по размерам классов, цены ошибки классификации
взяли бы одинаковыми и анализировали
агрегированные данные с использованием весов
наблюдений. Точно такая же доля ошибок
классификации получилась бы и в том случае, если
бы мы положили все априорные вероятности
одинаковыми, цену ошибочной классификации
объекта из 1-го класса как принадлежащего ко 2-му
классу взяли равной 2/3 от цены неправильной
классификации объекта 2-го класса как
принадлежащего 1-му классу, и анализировали бы
данные без весов наблюдений.</p>

<p>За исключением простейших случаев, взаимосвязи
между <em>априорными вероятностями</em>, <em>ценами
ошибок классификации</em> и <em>весами наблюдений</em>
являются довольно сложными (см. Breiman и др., 1984; Ripley,
1996). Однако если минимизация цены соответствует
минимизации доли неправильных классификаций,
все эти обстоятельства можно не принимать во
внимание. Априорные вероятности, цена ошибок
классификации и веса наблюдений были
рассмотрены здесь для того, чтобы показать, как
самые разнообразные ситуации в прогнозировании
можно охватить единой концепцией минимизации
цены, - в противоположность достаточно узкому
(хотя, возможно, часто встречающемуся) классу
задач прогнозирования, для которых подходит
более ограниченная (хотя и простая) идея
минимизации доли неправильных классификаций.
Далее, минимизация цены есть истинная цель
классификации посредством деревьев
классификации, и это отчетливо проявляется на
четвертом (заключительном) этапе анализа:
стремясь выбрать дерево &quot;нужного размера&quot;,
мы в действительности выбираем дерево с
минимальной оценкой для цены. Для многих видов
задач прогнозирования понять смысл уменьшения
оценки для цены бывает очень важно для лучшего
понимания окончательных результатов всего
анализа. </p>

<p><a name="computation2"></a></p>

<p><font size="4" color="#000080">Выбор типа ветвления</font></p>

<p>Второй шаг анализа с помощью деревьев
классификации заключается в том, чтобы выбрать
способ ветвления по значениям предикторных
переменных, которые используются для
предсказания принадлежности анализируемых
объектов к определенным классам значений
зависимой переменной. В соответствии с
иерархической природой <em><a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees">деревьев
классификации</a></em>, такие ветвления
производятся последовательно, начиная с
корневой вершины, переходя к вершинам-потомкам,
пока дальнейшее ветвление не прекратится и
&quot;неразветвленные&quot; вершины-потомки окажутся
терминальными. Ниже описаны три метода <em>типа
ветвления</em>. </p>

<p><strong>Дискриминантное одномерное ветвление.</strong>
Если выбрано <em>Одномерное ветвление</em>, прежде
всего нужно решить вопрос, какую из терминальных
вершин дерева, построенного к данному моменту,
следует расщепить на данном шаге и какую из
предикторных переменных при этом использовать.
Для каждой терминальной вершины вычисляются
p-уровни для проверки значимости зависимостей
между принадлежностью объектов к классам и
уровнями каждой из предикторных переменных. В
случае категориальных предикторов p-уровни
вычисляются для проверки критерия <a href="../glossary/gloss_r.html#Chi-square Distribution"><em>Хи-квадрат</em></a>
для гипотезы независимости принадлежности
классам от уровня категориального предиктора в
данном узле дерева. В случае порядковых
предикторов p-уровни вычисляются для анализа ANOVA
взаимосвязи классовой принадлежности и значений
порядкового предиктора в данном узле. Если
наименьший из вычисленных p-уровней оказался
меньше p-уровня Бонферони для множественных
0.05-сравнений, принимаемого по умолчанию, или
иного порогового значения, установленного
пользователем, то для разветвления этого узла
выбирается та предикторная переменная, которая и
дала этот наименьший. Если среди p-уровней не
оказалось ни одного, меньшего чем заданное
пороговое значение, то p-уровни вычисляются по
статистическим критериям, устойчивым к виду
распределения, например F Левена. Более подробно
процедура выбора узла и предикторной переменной
для ветвления в случае, когда ни один из p-уровней
не опустился ниже заданного порога, описана в Loh и
Shih (1997). </p>

<p>Следующий шаг - собственно ветвление. В случае
порядковых предикторов для построения двух
относящихся к данной вершине &quot;суперклассов&quot;
применяется <a href="../glossary/gloss_a.html#Algorithm">алгоритм</a>
кластеризации 2-средних, описанный в Hartigan , Wong (1979,
см. также <a href="stcluan.html"><em>Кластерный анализ</em></a>).
При этом находятся корни квадратного уравнения,
характеризующего различие средних значений по
&quot;суперклассам&quot; порядкового предиктора, и
для каждого из корней вычисляются значения
порога ветвления. Выбирается вариант ветвления,
для которого значение ближе к среднему по
&quot;суперклассу&quot;. В случае категориального
предиктора создаются фиктивные переменные,
представляющие уровни этого предиктора, а затем
с помощью метода сингулярного разложения
фиктивные переменные преобразуются в
совокупность неизбыточных порядковых
предикторов. Затем применяется описанный выше
алгоритм для порядковых предикторов, после чего
полученное ветвление &quot;проецируется
обратно&quot; в уровни исходной категоризующей
переменной и трактуется как различие между двумя
множествами уровней этой переменной. Как и в
предыдущем случае, за подробностями мы отсылаем
читателя к книге Loh , Shih (1997). Описанные процедуры
довольно сложны, однако они позволяют уменьшить
смещение при выборе ветвления, которое
характерно для <a href="stclatre.html#split3"><em>Полного
перебора деревьев с одномерным ветвлением по
методу CART</em></a>. Смещение имеет место в сторону
выбора переменных с большим числом уровней
ветвления, и при интерпретации результатов оно
может исказить относительную значимость влияния
предикторов на значения зависимой переменной
(см. Breiman и др., 1984). </p>

<p><strong>Дискриминантное многомерное ветвление по
линейным комбинациям.</strong> Другим типом
ветвления является <em>многомерное ветвление по
линейным комбинациям</em> для порядковых
предикторных переменных (при этом требуется,
чтобы предикторы были измерены как минимум по <em><a href="../glossary/gloss_i.html#Interval Scale">интервальной шкале</a></em>).
Любопытно, что в этом методе способ
использования непрерывных предикторных
переменных, участвующих в линейной комбинации,
очень похож на тот, который применялся в
предыдущем методе для категоризующих
переменных. С помощью сингулярного разложения
непрерывные предикторы преобразуются в новый
набор неизбыточных предикторов. Затем
применяются процедуры создания
&quot;суперклассов&quot; и поиска ветвления,
ближайшего к среднему по &quot;суперклассу&quot;,
после чего результаты &quot;проецируются назад&quot;
в исходные непрерывные предикторы и
представляются как одномерное ветвление
линейной комбинации предикторных переменных. </p>

<p><a name="split3"></a><strong>Полный перебор деревьев с
одномерным ветвлением по методу CART.</strong> Третий
метод выбора варианта ветвления, реализованный в
данном модуле - <em>Полный перебор деревьев с
одномерным ветвлением по методу</em> <a href="../glossary/gloss_p.html#Cart">CART</a> для категоризующих и
порядковых предикторных переменных. В этом
методе перебираются все возможные варианты
ветвления по каждой предикторной переменной, и
находится тот из них, который дает наибольший
рост для критерия согласия (или, что то же самое,
наибольшее уменьшение отсутствия согласия). Что
определяет набор возможных ветвлений в
некотором узле? Для категоризующей предикторной
переменной, принимающей в данном узле k значений,
имеется ровно 2<sup>(k-1)</sup> - 1 вариантов разбиения
множества ее значений на две части. Для
порядкового предиктора, имеющего в данном узле k
различных уровней, имеется k -1 точек, разделяющих
разные уровни. Мы видим, что количество различных
вариантов ветвления, которые необходимо
просмотреть, будет очень большим, если в задаче
много предикторов, у них много уровней значений и
в дереве много терминальных вершин. </p>

<p>Каким образом определяется улучшение <em>критерия
согласия</em>? В модуле Деревья классификации
доступны три способа измерения критерия
согласия. <em>Мера Джини однородности вершины</em>
принимает нулевое значение, когда в данной
вершине имеется всего один класс (если
используются априорные вероятности, оцененные
по размерам классов или исходя из одинаковой <em>цены
ошибок классификации</em>, то <em>мера Джини</em>
вычисляется как сумма всех попарных
произведений относительных размеров классов,
представленных в данной вершине; ее значение
будет максимальным, когда размеры всех классов
одинаковы). <em>Меру Джини</em> в качестве критерия
согласия использовали разработчики пакета <a href="../glossary/gloss_p.html#Cart">CART</a> (Breiman и. др., 1984). В модуле
Деревья классификации имеются еще две
возможности: мера Хи-квадрат Бартлетта (Bartlett, 1948)
и мера G-квадрат measure, совпадающая с мерой
максимума правдоподобия <a href="../glossary/gloss_r.html#Chi-square Distribution"><em>Хи-квадрат</em></a>,
которая применяется в моделировании
структурными уравнениями (см., например,
документацию по модулю <em><a href="stsepath.html">Моделирование
структурными уравнениями</a></em>). При <em>Полном
переборе деревьев с одномерным ветвлением по
методу </em><a href="../glossary/gloss_p.html#Cart">CART</a> ищется
вариант ветвления, при котором максимально
уменьшается значение выбранного критерия
согласия. Классификация будет абсолютно точной,
если согласие окажется полным. </p>

<p><a name="computation3"></a><font size="4" color="#000080">Определение
момента прекращения ветвлений</font></p>

<p>Третий этап анализа с помощью <a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees">деревьев
классификации</a> заключается в выборе момента,
когда следует прекратить дальнейшие ветвления. <em>Деревья
классификации</em> обладают тем свойством, что
если не установлено ограничение на число
ветвлений, то можно прийти к &quot;чистой&quot;
классификации, когда каждая терминальная
вершина содержит только один класс наблюдений
(объектов). Однако обычно такая &quot;чистая&quot;
классификация нереальна. Даже в простом дереве
классификации из примера с сортировкой монет
будут происходить ошибки классификации из-за
того, что некоторые монеты имеют неправильный
размер и/или размеры прорезей для них меняются со
временем от износа. В принципе, такие ошибки
можно было бы устранить, подвергая дальнейшей
классификации монеты, провалившиеся в каждую
прорезь, однако на практике всегда приходится в
какой-то момент прекращать сортировку и
удовлетворяться полученными к этому времени
результатами.</p>

<p>Аналогично, если при анализе с помощью дерева
классификации данные о классификации зависимой
переменной или уровни значений предикторных
переменных содержат ошибки измерений или
составляющую шума, то было бы нереально пытаться
продолжать сортировку до тех пор, пока каждая
терминальная вершина не станет &quot;чистой&quot;. В
модуле <em>Деревья классификации</em> имеются две
опции для управления остановкой ветвлений. Их
выбор прямо связан с выбором для данной задачи <em><a href="../glossary/gloss_p.html#Stopping Rule">Правила остановки</a></em>. </p>

<p><strong>Число неклассифицированных.</strong> В этом
варианте ветвления продолжаются до тех пор, пока
все терминальные вершины не окажутся чистыми или
будут содержать не более чем заданное число
объектов (наблюдений). Эта опция доступна в
качестве Правила остановки в двух вариантах: По
ошибке классификации или По вариации. Нужное
минимальное число наблюдений задается как Число
неклассифицированных, и ветвление прекращается,
когда все терминальные вершины, содержащие более
одного класса, содержат не более чем заданное
число объектов (наблюдений). </p>

<p><strong>Доля неклассифицированных.</strong> При выборе
этого варианта ветвления продолжаются до тех
пор, пока все терминальные вершины не окажутся
чистыми или будут содержать количество объектов,
не превышающее заданную долю численности одного
или нескольких классов. Требуемую минимальную
долю следует задать как Долю
неклассифицированных и тогда, если априорные
вероятности взяты одинаковыми и размеры классов
также одинаковы, ветвление прекратится, когда
все терминальные вершины, содержащие более
одного класса, будут содержать количество
наблюдений, не превышающее заданную долю объема
одного или нескольких классов. Если же априорные
вероятности выбирались не одинаковыми, то
ветвление прекратится, когда все терминальные
вершины, содержащие более одного класса, будут
содержать количество наблюдений, не превышающее
заданную долю объема одного или нескольких
классов. </p>

<p><a name="computation4"></a><font size="4" color="#000080">Определение
&quot;подходящих&quot; размеров дерева</font></p>

<p>Некий дотошный любитель играть на скачках,
тщательно изучив все результаты очередного дня,
конструирует огромное <em><a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees">дерево
классификации</a></em> с множеством ветвлений,
полностью учитывающее все данные по каждой
лошади и каждому заезду. Предвкушая финансовый
успех, он берет точную копию своего Графа дерева,
с помощью дерева классификации сортирует
лошадей, участвующих в заездах на следующий день,
строит свой прогноз, делает ставки в
соответствии с ним и ... уходит с ипподрома
несколько менее богатым человеком, чем
рассчитывал. Наш игрок наивно полагал, что дерево
классификации, построенное по обучающей выборке
с заранее известными результатами будет так же
хорошо предсказывать результат и для другой -
независимой тестовой выборки. Его дерево
классификации не выдержало <em><a href="../glossary/gloss_k.html#Cross-Validation">кросс-проверки</a></em>.
Вполне вероятно, что денежный выигрыш нашего
игрока был бы гораздо значительнее, если бы он
использовал небольшое дерево классификации , не
вполне идеально классифицирующее обучающую
выборку, но обладающее способностью столь же
хорошо прогнозировать результат для <em>тестовой
выборки</em>.</p>

<p>Можно высказать ряд общих соображений о том,
что следует считать &quot;подходящими размерами&quot;
для <a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees"><em>дерева
классификации</em></a>. Оно должно быть достаточно
сложным для того, чтобы учитывать имеющуюся
информацию, и в то же время оно должно быть как
можно более простым. Дерево должно уметь
использовать ту информацию, которая улучшает
точность прогноза, и игнорировать ту информацию,
которая прогноза не улучшает. По возможности оно
должно углублять наше понимание того явления,
которое мы пытаемся описать посредством этого
дерева. Очевидно, однако, что сказанное можно
отнести вообще к любой научной теории, так что мы
должны более конкретно определить, что же такое
дерево классификации &quot;подходящего размера&quot;.
Одна из возможных стратегий состоит в том, чтобы
наращивать дерево до нужного размера, каковой
определяется самим пользователем на основе уже
имеющихся данных, диагностических сообщений
системы, выданных на предыдущих этапах анализа,
или, на крайний случай, интуиции. Другая
стратегия связана с использованием хорошо
структурированного и документированного набора
процедур для выбора &quot;подходящего размера&quot;
дерева, разработанных Бриманом (Breiman) и др. (1984).
Нельзя сказать (и авторы это явно отмечают), чтобы
эти процедуры были доступны новичку, но они
позволяют получить из процесса поиска дерева
&quot;подходящего размера&quot; некоторые
субъективные суждения. </p>

<p><strong>Прямая остановка по методу FACT.</strong> Начнем
с описания первой стратегии, в которой
пользователь сам устанавливает размеры <em><a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees">дерева
классификации</a></em>, до которых оно может расти. В
этом варианте мы в качестве Правила остановки
выбираем опцию <em>Прямая остановка по методу FACT</em>,
а затем задаем <a href="stclatre.html#fraction"><em>Долю
неклассифицированных</em></a>, которая позволяет
дереву расти до нужного размера. Ниже описаны три
возможных способа определения, удачно ли выбран
размер дерева, три варианта <a href="../glossary/gloss_k.html#Cross-Validation"><em>кросс-проверки</em></a>
для построенного <em>дерева классификации</em>. </p>

<p><strong>Кросс-проверка на тестовой выборке.</strong>
Первый, наиболее предпочтительный вариант <em><a href="../glossary/gloss_k.html#Cross-Validation">кросс-проверки</a></em> - <em>кросс-проверка</em>
на тестовой выборке. В этом варианте
кросс-проверки <a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees"><em>дерево
классификации</em></a> строится по обучающей
выборке, а его способность к прогнозированию
проверяется путем предсказания классовой
принадлежности элементов тестовой выборки. Если
значение цены на тестовой выборке окажется
больше, чем на обучающей выборке (напомним Вам,
что <em>цена </em>- это доля неправильно
классифицированных наблюдений при условии, что
были использованы <em>оцениваемые априорные
вероятности</em>, а <em>цены ошибок классификации</em>
были взяты <em>одинаковыми</em>), то это
свидетельствует о плохом результате <a href="../glossary/gloss_k.html#Cross-Validation"><em>кросс-проверки</em></a>,
и, возможно, в этом случае следует поискать
дерево другого размера, которое бы лучше
выдерживало кросс-проверку. Тестовая и обучающая
выборки могут быть образованы из двух
независимых наборов данных, или, если в нашем
распоряжении имеется большая обучающая выборка,
мы можем случайным образом отобрать часть
(например, треть или половину) наблюдений и
использовать ее в качестве тестовой выборки. </p>

<p><strong>V-кратная кросс-проверка.</strong> Второй тип <em><a href="../glossary/gloss_k.html#Cross-Validation">кросс-проверки</a></em>,
реализованный в модуле <em>Деревья классификации</em>,
- так называемая V-кратная кросс-проверка. Этот
вид кросс-проверки разумно использовать в
случаях, когда в нашем распоряжении нет
отдельной тестовой выборки, а обучающее
множество слишком мало для того, чтобы из него
выделять тестовую выборку. Задаваемое
пользователем значение V (значение по умолчанию
равно 3) определяет число случайных подвыборок -
по возможности одинакового объема, - которые
формируются из обучающей выборки. Дерево
классификации нужного размера строится V раз,
причем каждый раз поочередно одна из подвыборок
не используется в его построении, но затем
используется как тестовая выборка для <em><a href="../glossary/gloss_k.html#Cross-Validation">кросс-проверки</a></em>.
Таким образом, каждая подвыборка V - 1 раз
участвует в обучающей выборке и ровно один раз
служит тестовой выборкой. Цены кросс-проверки,
вычисленные для всех V тестовых выборок, затем
усредняются, и в результате получается V-кратная
оценка для цены кросс-проверки, которая, вместе
со своей стандартной ошибкой, доступна в таблице
результатов Последовательность деревьев. </p>

<p><strong>Глобальная кросс-проверка.</strong> Третий тип <em>кросс-проверки</em>,
реализованный в модуле <em>Деревья классификации</em>
- глобальная кросс-проверка. В этом варианте
производится заданное число итераций (по
умолчанию - 3), причем всякий раз часть обучающей
выборки (равная единице, деленной на заданное
целое число) оставляется в стороне, а затем по
очереди каждая из отложенных частей
используется как тестовая выборка для
кросс-проверки построенного <em>дерева
классификации</em>. Этот вариант кросс-проверки,
вероятно, уступает методу V-кратной <em><a href="../glossary/gloss_k.html#Cross-Validation">кросс-проверки</a></em> в
случае, если была выбрана опция <em>Прямая
остановка по методу FACT</em>, однако он может
оказаться очень полезным для проверки методов
автоматического построения дерева (обсуждение
этих вопросов см. в Breiman и др., 1984). В результате мы
естественно приходим ко второй из возможных
стратегий выбора &quot;подходящего размера&quot; для
дерева - методу автоматического построения
дерева, который основывается на результатах Breiman
и др. (1984) и называется &quot;кросс-проверочным
отсечением по минимальной цене-сложности&quot;. </p>

<p><strong>Кросс-проверочное отсечение по
минимальной цене-сложности.</strong> Для того чтобы в
<em>Деревья классификации</em> выполнить <em><a href="../glossary/gloss_k.html#Cross-Validation">кросс-проверочное</a></em>
отсечение по минимальной цене-сложности, нужно
выбрать опцию <em>По ошибке классификации</em> в
качестве <em><a href="../glossary/gloss_p.html#Stopping Rule">Правила
остановки</a></em>, а кросс-проверочное отсечение по
минимальному отклонению-сложности выполняется,
если в качестве <em>Правила остановки</em> выбрано
отсечение По вариации. Единственное различие
между этими двумя опциями - способ измерения
ошибки прогноза. При отсечении <em>По ошибке
классификации</em> используется неоднократно
упоминавшаяся функция потерь (равная доли
неправильно классифицированных объектов при
оцениваемых априорных вероятностях и одинаковых
ценах ошибок классификации). При отсечении <em>По
вариации</em> используется мера, основанная на
принципе максимума правдоподобия и называемая
отклонением (см. Ripley, 1996). Мы сосредоточимся на
кросс-проверочном отсечении по минимальной
цене-сложности (предложенном Breiman и др., 1984),
поскольку отсечение по отклонению-сложности
отличается от него только способом измерения
ошибки прогноза.<br>
<br>
Функция цены, которая требуется для
кросс-проверочного отсечения по минимальной <em>цене-сложности</em>,
вычисляется по мере построения дерева, начиная с
ветвления в корневой вершине, пока дерево не
достигнет максимально допустимого размера,
определяемого величиной Число
неклассифицированных. Цена для обучающей
выборки пересчитывается при каждом новом
ветвлении дерева, так что в результате
получается, вообще говоря, убывающая
последовательность цен (это отражает улучшение
качества классификации). Цена обучающей выборки
называется ценой обучения, чтобы отличать ее от
цены кросс-проверки, - это необходимо делать,
поскольку V-кратная кросс-проверка также
производится при каждом новом ветвлении дерева.
В качестве значения цены для корневой вершины
следует использовать оценку цены кросс-проверки
из V-кратной кросс-проверки. Размер дерева можно
определить как число терминальных вершин, потому
что для бинарных деревьев при каждом новом
ветвлении размер дерева увеличивается на
единицу. Введем теперь так называемый параметр
сложности. Положим его сначала равным нулю, и для
каждого дерева (начиная с исходного, состоящего
из одной вершины) будем вычислять функцию, равную
цене дерева плюс значение параметра сложности,
умноженное на размер дерева. Станем теперь
постепенно увеличивать значение параметра
сложности, пока значение этой функции для
максимального дерева не превысит ее значения для
какого-либо из деревьев меньшего размера,
построенных на предыдущих шагах. Примем это
меньшее дерево за новое максимальное дерево и
будем дальше увеличивать значение параметра
сложности, пока значение функции для этого
дерева не станет больше ее значения для какого-то
еще меньшего дерева. Будем продолжать этот
процесс до тех пор, пока дерево, состоящее из
единственной корневой вершины, не станет
максимальным. (Читатели, знакомые с численными
методами, заметили, что в этом <a href="../glossary/gloss_a.html#Algorithm">алгоритме</a>
мы использовали так называемую штрафную функцию.
Она представляет собой линейную комбинацию цены,
которая в общем случае убывает с ростом дерева, и
размера дерева, который линейно растет. По мере
того, как значение параметра сложности
увеличивается, большие по размеру деревья
получают все больший штраф за свою сложность,
пока не будет достигнуто пороговое значение, при
котором более высокая цена меньшего дерева будет
перевешиваться сложностью большего дерева. </p>

<p>Последовательность максимальных деревьев,
которая получается в процессе выполнения этого
алгоритма, обладает рядом замечательных свойств.
Они являются вложенными, поскольку при
последовательном усечении каждое дерево
содержит все вершины следующего (меньшего)
дерева в последовательности. Поначалу при
переходе от очередного дерева к последующему
отсекается, как правило, большое число вершин,
однако по мере приближения к корневой вершине на
каждом шаге будет отсекаться все меньше вершин.
Деревья последовательности усекаются
оптимально в том смысле, что каждое дерево в
последовательности имеет наименьшую цену среди
всех деревьев такого же размера. Доказательства
и подробные пояснения можно найти в Breiman и др. (1984).</p>

<p><strong>Выбор дерева по результатам усечений.</strong>
Выберем теперь из последовательности оптимально
усеченных деревьев дерево &quot;подходящего
размера&quot;. Естественным критерием здесь
является Цена кросс-проверки. Не будет никакой
ошибки, если мы в качестве дерева &quot;подходящего
размера&quot; выберем то, которое дает наименьшую <em>цену
кросс-проверки</em>, однако часто оказывается, что
есть еще несколько деревьев с <em>ценой
кросс-проверки</em>, близкой к минимальной. Breiman и
др. (1984) высказывают разумное предложение, что в
качестве дерева &quot;подходящего размера&quot; нужно
брать наименьшее (наименее сложное) из тех, чьи
цены кросс-проверки несущественно отличаются от
минимальной. Авторы предложили правило &quot;1 SE&quot;:
в качестве дерева &quot;подходящего размера&quot;
нужно брать наименьшее дерево из тех, чьи цены
кросс-проверки не превосходят минимальной цены
кросс-проверки плюс умноженная на единицу
стандартная ошибка <em>цены кросс-проверки</em> для
дерева с минимальной <em>Ценой кросс-проверки</em>. <br>
<br>
Существенное преимущество
&quot;автоматического&quot; выбора дерева состоит в
том, что оно позволяет избежать как &quot;недо-&quot;,
так и &quot;пересогласованности&quot; с данными. На
следующем рисунке изображены типичные графики <em>цены
обучения</em> и <em>цены кросс-проверки</em> для
цепочки последовательно усекаемых деревьев.</p>

<p><img SRC="../popups/popup142.gif" WIDTH="239" HEIGHT="205"></p>

<p>Как видно из графика, цена обучения (например,
доля неправильных классификаций в обучающей
выборке) заметно уменьшается с увеличением
размера дерева. В то же время, цена кросс-проверки
с ростом размера дерева быстро достигает
минимума, а затем - для очень больших размеров
дерева - начинает расти. Обратите внимание на то,
что выбранное дерево &quot;подходящего размера&quot;
располагается близко к точке перегиба этой
кривой, то есть близко к той точке, где
первоначальное резкое уменьшение цены
кросс-проверки начинает сходить на нет.
Процедура &quot;автоматического&quot; выбора дерева
направлена на то, чтобы выбирать наиболее
простое (наименьшее по размеру) дерево с ценой
кросс-проверки, близкой к минимальной, и тем
самым избегать потери точности прогноза,
происходящей от &quot;недо-&quot; или &quot;
пересогласованности &quot; с данными (похожая
логика используется в <a href="../glossary/gloss_g.html#Scree Plot, Scree Test">графике каменистой
осыпи</a> для определения числа факторов в <a href="stfacan.html">факторном анализе</a>, см. также <a HREF="stfacan.html#results">Просмотр результатов анализа
главных компонент</a>)</p>

<p>Итак, мы видим, что <em><a href="../glossary/gloss_k.html#Cross-Validation">кросс-проверочное</a>
отсечение по минимальной цене-сложности</em> и
последующий выбор дерева &quot;подходящего
размера&quot; - действительно &quot;автоматические&quot;
процедуры. <a href="../glossary/gloss_a.html#Algorithm">Алгоритм</a>
самостоятельно принимает все решения,
необходимые для выбора дерева &quot;подходящего
размера&quot;, за исключением разве что выбора
множителя в SE-правиле. В связи с этим возникает
вопрос о том, насколько хорошо воспроизводятся
результаты, то есть, не может ли получиться так,
что при повторении этого процесса
&quot;автоматического выбора&quot; будут строиться
деревья, сильно отличающиеся друг от друга по
размеру. Именно здесь очень полезной может
оказаться <em><a href="stclatre.html#global">глобальная
кросс-проверка</a></em>. Как уже говорилось выше, при
глобальной кросс-проверке все этапы анализа
повторяются заданное число раз (по умолчанию - 3),
и при этом часть наблюдений используется как
тестовая выборка для <em>кросс-проверки </em>полученного
дерева классификации. Если средняя цена тестовых
выборок, которая называется ценой глобальной <em>кросс-проверки</em>,
превышает цену <em>кросс-проверки</em> выбранного
дерева, или если стандартная ошибка <em>цены
глобальной кросс-проверки</em> превышает
стандартную ошибку<em> цены кросс-проверки</em> для
выбранного дерева, то это свидетельствует о том,
что процедура &quot;автоматического&quot; выбора
дерева вместо устойчивого выбора дерева с
минимальным оцененным значением <em>цены </em>дает
недопустимо большой разброс результатов.</p>

<p><strong>Деревья классификации в сравнении с
традиционными методами.</strong> Как видно из
описания методов построения <em>деревьев
классификации</em>, в целом ряде аспектов метод
деревьев классификации существенно отличается
от традиционных статистических методов
предсказания принадлежности объекта к
определенному классу значений категориальной
зависимой переменной. Для сортировки объектов по
классам здесь применяется иерархия
(последовательность) прогнозов, при этом для
одного и того же объекта прогноз может делаться
много раз. В отличие от этого, в традиционных
методах используется техника, при которой
отнесение каждого объекта к тому или иному
классу производится один раз и окончательно. В
других отношениях, например по своей конечной
цели - достижению точного прогноза, - анализ
методом деревьев классификации не отличается от
классических методов. Время покажет, достаточно
ли у этого метода достоинств, чтобы встать в один
ряд с традиционными методами.</p>

<p>Об основных целях анализа с помощью <em>деревьев
классификации</em> см. раздел <a href="stclatre.html#basic"><em>Основные
идеи</em></a>. Об <em>иерархической природе</em> и <em>гибкости
деревьев классификации</em> см. раздел <em><a href="stclatre.html#character">Характеристики деревьев
классификации</a></em>. <br>
См. также <a href="stdatmin.html#eda">Методы разведочного
анализа данных</a>. </p>

<table ALIGN="RIGHT">
  <tr>
    <td><a HREF="stclatre.html#index"><font size="1">В начало</font></a> </td>
  </tr>
</table>

<p><br CLEAR="RIGHT">
</p>

<p><a NAME="comparison"></a> </p>

<p><font size="5" color="#000080">Сравнение с другими пакетами,
в которых реализован метод деревьев
классификации</font></p>

<p>Для решения задачи прогнозирования
принадлежности объекта (случая) к определенному
классу значений зависимой категориальной
переменной по данным измерений одной или
нескольких предикторных переменных было
разработано большое число программ, реализующих
метод деревьев классификации. В предыдущем
разделе <a HREF="stclatre.html#computation">Вычислительные
методы</a> мы рассмотрели методы программ <a href="../glossary/gloss_p.html#Quest">QUEST</a> (Loh &amp; Shih, 1997) и <a href="../glossary/gloss_p.html#Cart">CART</a> (Breiman и др., 1984),
предназначенные для построения бинарного дерева
классификации с помощью одномерных ветвлений
для категориальных, порядковых (т.е. измеренных
как минимум в порядковой шкале) или смеси обоих
типов предикторных переменных. Кроме того, в
данном модуле имеется возможность строить
дерево классификации с помощью ветвлений по
линейным комбинациям для интервальных
предикторных переменных. </p>

<p>Некоторые из программ <a href="http://proxy/home/textbook/glossary/gloss_d.html#Classification Trees">деревьев
классификации</a>, в частности <a href="../glossary/gloss_p.html#Fact">FACT</a> (Loh &amp; Vanichestakul, 1988) и <a href="../glossary/gloss_p.html#Thaid">THAID</a> (Morgan &amp; Messenger, 1973, сюда
же относятся пакеты <a href="../glossary/gloss_p.html#Aid">AID</a> -
Automatic Interaction Detection, Morgan &amp; Sonquist, 1963, и <a href="../glossary/gloss_p.html#Chaid">CHAID</a> - <a href="../glossary/gloss_r.html#Chi-square Distribution">Chi-Square</a> Automatic
Interaction Detection, Kass, 1980) при построении дерева
классификации выполняют не бинарные, а
многоуровневые ветвления. При многоуровневом
ветвлении от одной родительской вершины идут
ветви в более чем две дочерние вершины, тогда как
при бинарном (двоичном) ветвлении мы всегда
получаем ровно две дочерние вершины (независимо
от числа уровней переменной ветвления и числа
классов зависимой переменной). Необходимо
отметить, что многоуровневое ветвление на самом
деле не имеет никаких преимуществ (потому что
любое многоуровневое ветвление может быть
представлено в виде нескольких последовательных
двоичных ветвлений), но может иметь определенные
недостатки. В некоторых пакетах фиксированная
предикторная переменная может быть использована
для многоуровневого ветвления лишь один раз, так
что получающееся в результате дерево
классификации оказывается слишком коротким и
неинтересным (Loh &amp; Shih, 1997). Более серьезная
трудность связана со смещением при выборе
переменной для ветвления. Такое смещение
возможно в любой программе типа <a href="../glossary/gloss_p.html#Thaid">THAID</a> (Morgan &amp; Sonquist, 1973), где
применяется полный перебор вариантов ветвления
(обсуждение этого вопроса см. в Loh &amp; Shih, 1997).
Смещение в выборе переменной проявляется в том,
что преимущественно выбираются переменные,
имеющие много уровней значений, и такое смещение
может исказить относительную важность разных
предикторных переменных в смысле их влияния на
отклик зависимой переменной (см. Breiman и др., 1984).</p>

<p>Смещения в выборе переменной можно избежать,
выбрав опцию дискриминантного <a href="stclatre.html#split1">одномерного</a>
или <a href="stclatre.html#split2">многомерного</a> ветвления
модуля Деревья классификации. При этом
используются <a href="../glossary/gloss_a.html#Algorithm">алгоритмы</a>
<a href="../glossary/gloss_p.html#Quest">QUEST</a> (Loh &amp; Shih, 1997),
предотвращающие смещение в выборе переменной.
Опция <a href="stclatre.html#split3">Полный перебор деревьев с
одномерным ветвлением по методу CART</a> модуля
Деревья классификации предназначена для тех
ситуаций, когда целью анализа является отыскание
системы ветвлений, дающей наилучшую
классификацию обучающей выборки (которая
необязательно окажется лучшей на независимом
кросс-проверочной выборке). Для построения
надежных вариантов ветвления, а также для
большей скорости вычислений мы рекомендуем
опцию <em>дискриминантного одномерного ветвления</em>.
О построении дерева классификации см. в разделе <a href="stclatre.html#computation">Вычислительные методы</a>. <br>
<br>
</p>

<p>Дополнительная информация по методам анализа данных, добычи данных, 
визуализации и прогнозированию содержится на 
<a href="http://www.statsoft.ru/home/portal/default.asp" target="_blank">Портале StatSoft</a> (http://www.statsoft.ru/home/portal/default.asp) 
и в <a href="http://www.statsoft.ru/home/portal/textbook2/default.htm" target="_blank">Углубленном Учебнике StatSoft (Учебник с формулами)</a>.</p>

<hr SIZE="1">

<p align="center"><br>
<img SRC="../stathoms.jpg" ALIGN="LEFT" WIDTH="151" HEIGHT="41"> <br CLEAR="ALL">
<font size="1">(c) Copyright StatSoft, Inc., 1984-2001<br>
STATISTICA является торговой маркой StatSoft, Inc. </font></p>

<hr SIZE="1">
</body>
</html>
