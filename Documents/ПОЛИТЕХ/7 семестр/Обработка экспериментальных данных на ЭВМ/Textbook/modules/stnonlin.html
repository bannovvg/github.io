<html>

<head>
<title>Нелинейное оценивание</title>
</head>

<body BACKGROUND="../tile1.gif">
<font SIZE="5" COLOR="AA0000"><b>

<p align="center">Нелинейное оценивание</b></font> </p>

<hr SIZE="1">

<p><a NAME="index">&nbsp; 

<ul>
  <li></a><a HREF="stnonlin.html#general">Общее назначение</a> </li>
  <li><a HREF="stnonlin.html#estimating">Оценивание линейных и
    нелинейных моделей</a> </li>
  <li><a HREF="stnonlin.html#common">Основные типы нелинейных
    моделей</a> <ul>
      <li><a HREF="stnonlin.html#clinear">Регрессионные модели с
        линейной структурой</a> </li>
      <li><a HREF="stnonlin.html#cnonlinear">Существенно нелинейные
        регрессионные модели</a> </li>
    </ul>
  </li>
  <li><a HREF="stnonlin.html#nonlinear">Методы нелинейного
    оценивания</a> <ul>
      <li><a HREF="stnonlin.html#nleast">Метод наименьших квадратов</a> </li>
      <li><a HREF="stnonlin.html#nloss">Функция потерь</a> </li>
      <li><a HREF="stnonlin.html#nweighted">Метод взвешенных наименьших
        квадратов</a> </li>
      <li><a HREF="stnonlin.html#nmaximum">Метод максимума
        правдоподобия</a> </li>
      <li><a HREF="stnonlin.html#n2">Максимум правдоподобия и
        логит/пробит модели</a> </li>
      <li><a HREF="stnonlin.html#nfunction">Алгоритмы минимизации
        функций</a> </li>
      <li><a HREF="stnonlin.html#nstart">Начальные значения, размеры
        шагов и критерий сходимости</a> </li>
      <li><a HREF="stnonlin.html#npenalty">Штрафные функции, ограничение
        параметров</a> </li>
      <li><a HREF="stnonlin.html#nlocal">Локальные минимумы</a> </li>
      <li><a HREF="stnonlin.html#nquasi">Квази-ньютоновский метод</a> </li>
      <li><a HREF="stnonlin.html#nsimplex">Симплекс-метод</a> </li>
      <li><a HREF="stnonlin.html#nhooke">Метод Хука-Дживиса</a> </li>
      <li><a HREF="stnonlin.html#nrosenbrock">Метод Розенброка</a> </li>
      <li><a HREF="stnonlin.html#nhessian">Матрица Гессе и стандартные
        ошибки</a> </li>
    </ul>
  </li>
  <li><a HREF="stnonlin.html#evaluating">Оценивание пригодности
    модели</a> <ul>
      <li><a HREF="stnonlin.html#eproportion">Объясненная доля дисперсии</a>
      </li>
      <li><a HREF="stnonlin.html#egoodness">Критерий согласия хи-квадрат</a>
      </li>
      <li><a HREF="stnonlin.html#eplot">График наблюдаемых и
        предсказанных значений</a> </li>
      <li><a HREF="stnonlin.html#enormal">Нормальный и полунормальный
        график остатков</a> </li>
      <li><a HREF="stnonlin.html#eplotf">График функции подгонки</a> </li>
      <li><a HREF="stnonlin.html#evariance">Ковариационная матрица
        оценок параметров</a> </li>
    </ul>
  </li>
</ul>

<hr SIZE="1">

<p>&nbsp;<a NAME="general"></a></p>

<p><font SIZE="4" COLOR="navy">Общее назначение </font></p>

<p>Иногда, при проведении анализа линейной модели,
исследователь получает данные о ее
неадекватности. В этом случае, его по-прежнему
интересует зависимость между предикторными
переменными и откликом, но для уточнения модели в
ее уравнение добавляются некоторые нелинейные
члены. Самым удобным способом оценивания
параметров полученной регрессии является <i>Нелинейное
оценивание</i>. Например, его можно использовать
для уточнения зависимости между дозой и
эффективностью лекарства, стажем работы и
производительностью труда, стоимостью дома и
временем, необходимым для его продажи и т.д.
Наверное, вы заметили, что ситуации,
рассматриваемые в этих примерах, часто
интересовали нас и в таких методах как
множественная регрессия (см. <a href="stmulreg.html"><i>Множественная
регрессия</i></a>) и дисперсионный анализ (см. <a href="stanman.html"><i>Дисперсионный анализ</i></a>). На самом
деле, можно считать <i>Нелинейное оценивание</i>
обобщением этих двух методов. Так, в методе
множественной регрессии (и в дисперсионном
анализе) предполагается, что зависимость отклика
от предикторных переменных <i>линейна</i>. <i>Нелинейное
оценивание</i> оставляет выбор характера
зависимости за вами. Например, вы можете
определить зависимую переменную как
логарифмическую функцию от предикторной
переменной, как степенную функцию, или как любую
другую композицию элементарных функций от
предикторов (однако, если все изучаемые
переменные категориальны по своей природе, вы
можете также воспользоваться модулем <a href="stcoran.html"><i>Анализ соответствий</i></a>).</p>

<p>Если позволить рассмотрение любого типа
зависимости между предикторами и переменной
отклика, возникают два вопроса. Во-первых, как
истолковать найденную зависимость в виде
простых практических рекомендаций. С этой точки
зрения линейная зависимость очень удобна, так
как позволяет дать простое пояснение: “чем
больше <i>x </i>(т.е., чем больше цена дома), тем больше
<i>y</i> (тем больше времени нужно, чтобы его
продать); и, задавая конкретные приращения <i>x</i>,
можно ожидать пропорциональное приращение <i>y</i>”.
Нелинейные соотношения обычно нельзя так просто
проинтерпретировать и выразить словами. Второй
вопрос - как проверить, имеется ли на самом деле
предсказанная нелинейная зависимость.</p>

<p>Далее мы рассмотрим проблему нелинейной
регрессии более формально и введем стандартную
терминологию, позволяющую рассмотреть сущность
этого метода более пристально. Мы также покажем
примеры его использования в различных областях
исследований: медицине, социологии, физике,
химии, фармакологии, проектировании и т.д. </p>

<table ALIGN="RIGHT">
  <tr>
    <td><font SIZE="1"><a HREF="stnonlin.html#index">В начало</a></font> </td>
  </tr>
</table>

<p><br CLEAR="RIGHT">
&nbsp;<a NAME="estimating"></a> </p>

<p><font SIZE="4" COLOR="navy">Оценивание линейных и
нелинейных моделей </font></p>

<p>Формально говоря, модуль <i>Нелинейное
оценивание</i> является универсальной
аппроксимирующей процедурой, оценивающей любой
вид зависимости между переменной отклика и
набором независимых переменных. В общем случае,
все регрессионные модели могут быть записаны в
виде формулы:</p>

<p><font color="blue">y = F(x<sub>1</sub>, x<sub>2</sub>, ... , x<sub>n</sub>) </font></p>

<p>При проведении регрессионного, а в частности
нелинейного регрессионного анализа,
исследователя интересует, связана ли и если да,
то как, зависимая переменная и набор независимых
переменных. Выражение <font color="blue"><i>F(x...)</i></font> в
выписанном выше выражении означает, что
переменная отклика <i><font color="blue">y</font> </i>является <i>функцией</i>
от независимой переменной<i> <font color="blue">x</font></i>. </p>

<p>Примером модели такого типа может быть модель
множественной линейной регрессии, описанная в
разделе <a href="stmulreg.html"><i>Множественная регрессия</i></a>.
В этой модели предполагается, что зависимая
переменная является <i>линейной </i>функцией
независимых переменных, т.е.: </p>

<p><font color="blue">y = a + b<sub>1</sub>*x<sub>1</sub> + b<sub>2</sub>*x<sub>2</sub> +
... + b<sub>n</sub>*x<sub>n</sub> </font></p>

<p>Если вы не знакомы с множественной линейной
регрессией, вы можете прямо сейчас перечитать
вводный обзор<i> <a href="stmulreg.html">Множественной
регрессии</a></i> (но вам вовсе не обязательно
понимать все нюансы множественной линейной
регрессии, для того чтобы разобраться в
обсуждаемом здесь методе). </p>

<p><i>Нелинейное оценивание</i> позволяет задать
практически любой тип непрерывной или разрывной
регрессионной модели. Некоторые из наиболее
общих нелинейных моделей (такие как <i>пробит</i> и <i>логит</i>
модели, <i>модель экспоненциального роста</i> и <i>регрессия
с точками разрыва</i>) уже имеются в <i>Нелинейном
оценивании</i>. Однако, при необходимости, вы
можете также самостоятельно ввести
регрессионное уравнение любого типа, поручив
программе его подгонку в соответствии с вашими
данными. Более того, для оценивания модели вы
можете использовать <i>метод наименьших
квадратов</i>, <i>метод максимума правдоподобия</i>
(если это допускается выбранной моделью), или,
опять же, определить вашу собственную <i>функцию
потерь</i> (см. ниже) задав соответствующее
уравнение. </p>

<p>В общем случае, каждый раз, когда простая модель
линейной регрессии неадекватно отражает
зависимость переменных, используется модель
нелинейной регрессии. Выберите один из следующих
разделов для получения более полного
представления об основных типах нелинейных
моделей, процедурах нелинейного оценивания и
оценивании пригодности модели. </p>

<p>&nbsp;<a NAME="common"></a> </p>

<p><font SIZE="4" COLOR="navy">Основные типы нелинейных
моделей </font>

<ul>
  <li><a HREF="stnonlin.html#clinear">Регрессионные модели с
    линейной структурой</a> </li>
  <li><a HREF="stnonlin.html#cnonlinear">Существенно нелинейные
    регрессионные модели</a> </li>
</ul>

<p>&nbsp;<a NAME="clinear"></a></p>
<font COLOR="navy"><b>

<p>Регрессионные модели с линейной структурой</b></font></p>

<p><strong>Полиномиальная регрессия.</strong>
Распространенной “нелинейной” моделью
является модель полиномиальной регрессии.
Термин <i>нелинейная</i> заключен в кавычки,
поскольку эта модель линейна по своей природе.
Например, предположим, что вы измеряете в
обучающем эксперименте связь физиологического
возбуждения объектов и их производительности в
задаче слежения за целями. На основании хорошо
известного закона Йеркса-Додсона, можно ожидать
нелинейной зависимости между уровнем
возбуждения и производительностью. Это
предположение можно выразить следующим
уравнением регрессии:</p>

<p><font color="blue">Производительность = a + b<sub>1</sub>*Возбуждение
+ b<sub>2</sub>*Возбуждение<sup>2</sup> </font></p>

<p>В этом уравнении, <font color="blue"><i>a</i></font>
представляет свободный член, а <font color="blue"><i>b<sub>1</sub></i></font>
и <font color="blue"><i>b<sub>2</sub></i></font> коэффициенты
регрессии. Нелинейность этой модели выражается
членом <font color="blue"><em>Возбуждение</em><i><sup>2</sup></i></font>.
Однако, в сущности, модель по-прежнему линейна, за
исключением того, что при ее оценивании нам
придется возводить наблюдаемый уровень
возбуждения в квадрат. Для оценивания
коэффициентов регрессии этой модели можно
использовать <i>фиксированное нелинейное </i>оценивание.
Такие модели, где мы составляем линейное
уравнение из некоторых преобразований
независимых переменных, относятся к моделям <i>нелинейным
по переменным.</p>
</i>

<p><strong>Модели, нелинейные по параметрам.</strong> Для
сравнения с предыдущим примером рассмотрим
зависимость между возрастом человека
(переменная<i> x</i>) и его скоростью роста
(переменная<i> y</i>). Очевидно, что соотношение
между этими двумя переменными на первом году
человеческой жизни (когда происходит наибольший
рост) сильно отличается от соотношения во
взрослом возрасте (когда человек почти не
растет). Поэтому, эту зависимость лучше
представить в виде какой-нибудь
экспоненциальной функции с отрицательным
показателем степени:</p>

<p><font color="blue">Рост = exp(-b<sub>1</sub>*Возраст) </font></p>

<p>Если вы построите на графике оценку для
коэффициента регрессии, то вы получите кривую
следующего вида:</p>

<p><img BORDER="0" SRC="../popups/popup9.gif" alt="График" WIDTH="306" HEIGHT="218"></p>

<p>Отметим, что эта модель по своей природе больше
не является линейной, т.е. выражение, написанное
сверху, не представимо в виде простой
регрессионной модели с некоторыми
преобразованиями независимых переменных. Такие
модели называются <i>нелинейными по параметрам</i>.</p>

<p><strong>Сведение нелинейных моделей к линейным.</strong>
В общем случае, всегда, когда регрессионная
модель может быть сведена к линейной модели,
этому способу отдается предпочтение (при
оценивании соответствующей модели). Модель
линейной множественной регрессии (см. <a href="stmulreg.html"><i>Множественная регрессия</i></a>)
наиболее просто понимаема с точки зрения
математики и, с практической точки зрения,
наиболее проста для толкования. Поэтому,
возвращаясь к простой экспоненциальной
регрессионной модели <i>Скорости роста </i>как
функции <i>Возраста</i>, описанной раньше, мы можем
преобразовать это нелинейное уравнение в
линейное, прологарифмировав обе части уравнения,
получив:</p>

<p><font color="blue">log(Рост) = -b<sub>1</sub>*Возраст </font></p>

<p>Если теперь заменить <i><font color="blue">log(Рост)</font>)</i>
на <font color="blue"><i>y</i></font>, мы получим стандартную
модель линейной регрессии, как уже было показано
раньше (без свободного члена, который был опущен
для простоты изложения). Таким образом, для
оценивания взаимоотношения возраста и скорости
роста вы можете прологарифмировать данные о <i>скорости
роста</i> (например, воспользовавшись
преобразованиями таблиц данных с помощью
формул), а затем использовать <i>Множественную
регрессию</i>, получив при этом интересующий нас
коэффициент регрессии <i><font color="blue">b<sub>1</sub></font></i>.</p>

<p><strong>Адекватность модели.</strong> Конечно,
используя “неправильное” преобразование, можно
прийти к неадекватной модели. Поэтому, после
”линеаризации” модели, наподобие только что
показанной, очень важно провести подробное
изучение статистик остатков, вычисляемых с
помощью <i>Множественной регрессии</i>. </p>

<p>&nbsp;<a NAME="cnonlinear"></a> </p>

<p><font COLOR="navy"><b>Существенно нелинейные
регрессионные модели</b></font></p>

<p>Для некоторых регрессионных моделей, которые
не могут быть сведены к линейным, единственным
способом для исследования остается <i>Нелинейное
оценивание</i>. В приведенном выше примере для
скорости роста, мы специально “забыли ” о
случайной ошибке в зависимой переменной.
Конечно, на скорость роста влияют множество
других факторов (кроме возраста), и нам следует
ожидать значительных случайных отклонений (<i>остатков</i>)
от предложенной нами кривой. Если добавить эту <i>ошибку</i>
или остаточную изменчивость, нашу модель можно
переписать следующим образом: </p>

<p><font color="blue">Рост = exp(-b<sub>1</sub>*Возраст) + ошибка </font></p>

<p><strong>Аддитивная ошибка.</strong> В этой модели
предполагается, что случайная ошибка не зависит
от возраста, т.е., остаточная изменчивость
одинакова для всех возрастов. Поскольку ошибка в
этой модели аддитивна, т.е. просто прибавляется к
точному значению скорости роста, мы больше не
можем линеаризовать эту модель простым
логарифмированием обеих частей. Если бы мы снова
прологарифмировали входные данные о <i>скорости
роста </i>и подобрали простую линейную модель, мы
заметили бы, что остатки больше не являются
равномерно распределенными вокруг значений
переменной <i>возраст</i>; и поэтому, стандартный
линейный регрессионный анализ (с помощью <a href="stmulreg.html"><i>Множественной регрессии</i></a>)
больше не применим. Единственным способом
оценивания параметров модели остается
использование <i>Нелинейного оценивания</i>.</p>

<p><strong>Мультипликативная ошибка.</strong> В
“оправдание” предыдущего примера заметим, что в
данном случае постоянство вариации случайной
ошибки в любом возрасте мало вероятно, т.е.,
предположение об аддитивности ошибки не слишком
реалистично. Правдоподобнее, что изменения
скорости роста более случайны и непредсказуемы в
раннем возрасте, чем в позднем, когда рост
практически останавливается. Поэтому, более
реалистичной моделью, включающей ошибку, будет: </p>

<p><font color="blue">Рост = exp(-b<sub>1</sub>*Возраст) * ошибка </font></p>

<p>На словах это означает, что чем больше возраст,
тем меньше множитель <font color="#0000FF"><i>exp(-b1*Возраст)</i></font>,
и, следовательно, тем меньше будет разброс
результирующей ошибки. Если же вы теперь
прологарифмируете обе части нашего уравнения, то
остаточная ошибка перейдет в свободный член
линейного уравнения, т.е., аддитивный фактор, и вы
сможете продолжить и оценить <i>b1</i> пользуясь
стандартную множественную регрессию. </p>

<p><font color="blue">Log (Рост) = -b<sub>1</sub>*Возраст + ошибка </font></p>

<p>Теперь мы рассмотрим некоторые регрессионные
модели (нелинейные по параметрам), которые не
могут быть сведены к линейным простым
преобразованием начальных данных. </p>

<p><strong>Общая модель роста.</strong> Общая модель роста
похожа на рассмотренный ранее пример:</p>

<p><font color="blue">y = b<sub>0</sub> + b<sub>1</sub>*exp(b<sub>2</sub>*x) +
ошибка </font></p>

<p>Эта модель обычно используется при изучении
различных видов роста (<font color="#0000FF"><i>y</i></font>),
когда скорость роста в любой момент времени (<font color="#0000FF"><i>x</i></font>) пропорциональна оставшемуся
приросту. Параметр <font color="blue"><i>b<sub>0</sub></i></font> в
этой модели представляет максимальное значение
скорости роста. Типичным примером ее адекватного
использования служит описание концентрации
вещества (например, в воде) в виде функции
времени. </p>

<p><strong>Модели бинарных откликов: пробит и логит.</strong>
Нередко зависимая переменная - переменная
отклика бинарна по своей природе, т.е. может
принимать только два значения. Например, пациент
может выздороветь, а может и нет, кандидат на
должность может пройти, а может провалить тест
при приеме на работу, подписчики журнала могут
продлить, а могут не продлевать подписку, купоны
скидок могут быть использованы, а могут быть и не
использованы и т.п. Во всех этих случаях нас может
заинтересовать поиск зависимости между одной
или несколькими “непрерывными” переменными и
одной, зависящей от них бинарной переменной.</p>

<p><em><strong>Использование линейной регрессии. </strong></em>Конечно,
можно использовать <i>стандартную <a href="stmulreg.html">множественную
регрессию</a></i> и вычислить стандартные
коэффициенты регрессии. Например, если
рассматривается продление журнальной подписки,
можно задать переменную <i>y</i> со значениями <i>1</i>’
и <i>0</i>’, где <i>1</i> означает, что соответствующий
подписчик продлил подписку, а <i>0</i>, что он
отказался от продления. Однако здесь возникает
проблема: <i>Множественная регрессия</i> не
“знает”, что переменная отклика бинарна по
своей природе. Поэтому, это неизбежно приведет к
модели с предсказываемыми значениями большими <i>1</i>
и меньшими <i>0</i>. Но такие значения вообще не
допустимы для первоначальной задачи, таким
образом, множественная регрессия просто
игнорирует ограничения на диапазон значений для <i>y</i>.
</p>

<p><em><strong>Непрерывные функции отклика.</strong></em>
Задача регрессии может быть сформулирована
иначе: вместо предсказания бинарной переменной,
мы предсказываем <i>непрерывную</i> переменную со
значениями на отрезке [0,1]. Наибольшее
распространение в этой области получили
регрессионные модели <i>логит </i>и <i>пробит</i>. </p>

<blockquote>
  <b><p></b><strong>Логит регрессия.</strong> В этой модели
  предсказываемые значения для зависимой
  переменной больше или равны 0 и меньше или равны 1
  при любых значениях независимых переменных. Это
  достигается применением следующего
  регрессионного уравнения, которое в
  действительности имеет также некоторый глубокий
  смысл, как вы вскоре увидите (термин <i>логит </i>впервые
  был использован в работе Berkson, 1944):</p>
  <p><font color="blue">y = exp(b<sub>0</sub> + b<sub>1</sub>*x<sub>1</sub> + ... + b<sub>n</sub>*x<sub>n</sub>)/{1
  + exp(b<sub>0</sub> + b<sub>1</sub>*x<sub>1</sub> + ... + b<sub>n</sub>*x<sub>n</sub>)} </font></p>
  <p>Легко заметить, что вне зависимости от
  коэффициентов регрессии и значений <font color="blue"><i>x</i></font>,
  значения <i><font color="blue">y</font></i>, предсказанные этой
  моделью всегда будут принадлежать отрезку [0,1].</p>
  <p>Название <i>логит</i> этой модели происходит от
  названия простого способа сведения этой модели к
  линейной с помощью <i>логит</i> преобразования.
  Предположим, что мы рассуждаем о нашей зависимой
  переменной в терминах нашей основной
  вероятности <font color="blue"><i>p</i></font>, лежащей между <i>0</i>
  и <i>1</i>. Тогда мы можем преобразовать эту
  вероятность <font color="blue"><i>p</i></font>: </p>
  <p><font color="blue">p' = log<sub>e</sub>{p/(1-p)} </font></p>
  <p>Это преобразование обычно называют <i>логистическим</i>
  или <i>логит</i> - преобразованием. Отметим, что
  теоретически <i>p’</i> может принимать любое
  значение от минус до плюс бесконечности.
  Поскольку логистическое преобразование решает
  проблему об ограничении на 0-1 границы для
  первоначальной зависимой переменной
  (вероятности), вы можете использовать эти
  (преобразованные) значения в обычном линейном
  регрессионном уравнении. А именно, если
  произвести логистическое преобразование обеих
  частей описанного выше уравнения, мы получим
  стандартную модель линейной регрессии:</p>
  <p><font color="blue">p' = b<sub>0</sub> + b<sub>1</sub>*x<sub>1</sub> + b<sub>2</sub>*x<sub>2</sub>
  + ... + b<sub>n</sub>*x<sub>n</sub> </font></p>
  <p><strong>Пробит регрессия.</strong> Можно рассматривать
  бинарную зависимую переменную как отклик на
  изменения некоторой “основной”, нормально
  распределенной переменной, в действительности
  имеющую диапазон изменений от минус до плюс
  бесконечности. Например, подписчик журнала может
  быть решительно против продления подписки,
  находится в нерешительности или испытывать
  расположение к журналу и стремиться продлить
  подписку. В любом случае, все, что мы (как издатели
  журнала) увидим, будет бинарный отклик,
  означающий продление или отказ от продления
  подписки. Однако если мы запишем стандартное
  уравнение линейной регрессии, основанное на
  “отношении людей к журналу”, мы получим:</p>
  <p><font color="blue">отношение... = b<sub>0</sub> + b<sub>1</sub>*x<sub>1</sub>
  + ... </font></p>
  <p>что, конечно, соответствует стандартной
  регрессионной модели. Логично предположить, что
  это “отношение людей к журналу” нормально
  распределено, и что вероятность продления
  подписки <i>p</i> равна соответствующей “отношению
  к журналу ” площади под графиком плотности
  нормального распределения. Поэтому, если мы
  преобразуем обе части уравнения в
  соответствующие нормальные вероятности, мы
  получим:</p>
  <p><font color="blue">NP(отношение...) = NP(b<sub>0</sub> + b<sub>1</sub>*x<sub>1</sub>
  + ...) </font></p>
  <p>Здесь <i>NP</i> означает <i>нормальную вероятность</i>
  (площадь под графиком плотности нормального
  распределения), таблицы которой имеются
  практически в любом статистическом справочнике.
  Выписанное выше уравнение называется также
  регрессионной моделью <i>пробит</i>. (Термит <i>пробит</i>
  был впервые использован в работе Bliss, 1934.) </p>
</blockquote>

<p><strong>Обобщенная логит регрессия.</strong>
Обобщенная логит регрессия может быть выражена
уравнением: </p>

<p><font color="blue">y = b<sub>0</sub>/{1 + b<sub>1</sub>*exp(b<sub>2</sub>*x)} </font></p>

<p>Вы можете представлять себе эту модель как
обобщение обычной логит модели для бинарных
зависимых переменных. Однако если логит модель
ограничивает значения зависимой переменной
только двумя возможными значениями, то общая
модель позволяет отклику произвольно меняться
внутри фиксированного интервала. Например,
предположим, что вас интересует прирост
популяции вида, перенесенного на новое место
обитания, рассмотренный в виде функции времени.
Тогда зависимая переменная будет равна числу
особей данного вида в соответствующей среде
обитания. Очевидно, что ее значение ограничено
снизу, так как число особей не может быть меньше
нуля; вероятно, что также существует какой-то
верхний предел для численности популяции,
который будет достигнут в некоторый момент
времени. </p>

<p><strong>Восприимчивость к лекарству и
полумаксимальный отклик</strong><b>. </b>В
фармакологии, для описания эффективности
различных доз лекарственных средств, часто
используется следующая модель: </p>

<p><font color="blue">y = b<sub>0</sub> - b<sub>0</sub>/{1 + (x/b<sub>2</sub>)<sup>b<sub>1</sub></sup>}
</font></p>

<p>В этой модели, <font color="blue"><i>x</i></font> означает
размер дозы (обычно в некоторой закодированной
форме, так что <font color="blue"><i>x</i></font> <img src="../graphics/gteblue.gif" align="absmiddle" WIDTH="12" HEIGHT="16"> <font color="blue"><i>1</i></font>), а <font color="blue"><i>y</i></font> соответствует восприимчивости,
измеренной в процентах по отношению к
максимально возможной. Параметр <font color="blue"><i>b<sub>0</sub></i></font>
тогда означает ожидаемый отклик при насыщающем
уровне дозы, а <font color="blue"><i>b<sub>2</sub></i></font> равен
концентрации, вызывающей полумаксимальный
отклик; параметр <font color="blue"><i>b<sub>1</sub></i></font> &nbsp;
определяет наклон графика предсказываемой
функции. </p>

<p><strong>Регрессионные модели сточками разрыва<br>
<em>Кусочно - линейная регрессия.</em></strong> Нередко
вид зависимости между предикторами и переменной
отклика различается в разных областях значений
независимых переменных. Например, вы
рассматриваете себестоимость единицы
некоторого продукта как функцию от объема
произведенной продукции за месяц. Обычно, чем
больше единиц товара вы производите, тем ниже
себестоимость каждой единицы, и эта линейная
зависимость существует в широких пределах
изменения объема произведенной продукции.
Однако при прохождении кривой выпуска через
некоторые значения себестоимость может меняться
скачкообразно. Например, себестоимость может
увеличиваться при увеличении объема
производства из-за того, что для производства
дополнительных единиц используются другие
(устаревшие) станки. Допустим, что устаревшие
машины используются в производстве при
достижении объемом производства уровня 500 единиц
в месяц; этой ситуации соответствует следующая
регрессионную модель для себестоимости: </p>

<p><font color="blue">y = b<sub>0</sub> + b<sub>1</sub>*x*(x <img src="../graphics/lteblue.gif" align="absmiddle" WIDTH="12" HEIGHT="16"> 500) + b<sub>2</sub>*x*(x &gt; 500) </font></p>

<p>В этой формуле: <font color="blue"><i>y</i></font> означает
оцениваемую себестоимость, а <font color="blue"><i>x</i></font>
равен объему продукции, произведенной за месяц.
Выражения (<font color="blue">x</font> <img SRC="../graphics/lteblue.gif" ALIGN="ABSMIDDLE" WIDTH="12" HEIGHT="16"> <font color="blue">500</font>) и (<font color="blue">x &gt; 500</font>)
обозначают логические условия, принимающие
значения <i>1</i> если они истинны, и <i>0</i> иначе.
Таким образом, эта модель определяется общим
свободным членом (<font color="blue"><i>b<sub>0</sub></i></font>) и
угловым коэффициентом, соответствующим <font color="blue"><i>b<sub>1</sub></i></font> (если выражение <font color="blue"><i>x</i></font>
<img SRC="../graphics/lteblue.gif" ALIGN="ABSMIDDLE" WIDTH="12" HEIGHT="16"> <font color="blue">500</font>
истинно, т.е., равно<i> </i>1) или <font color="blue"><i>b<sub>2</sub></i></font>
(если выражение <font color="blue"><i>x</i> &gt; 500</font> истинно,
т.е., равно 1). </p>

<p>Вместо явного<i> задания</i> точки разрыва
регрессионной кривой (<i>500</i> единиц в месяц в
последнем примере), можно также <i>оценить</i>
положение этой точки. Например, мы могли заметить
и предположить, что кривая себестоимости имеет
разрыв в некоторой точке; однако не всегда
очевидно, в какой именно точке происходит разрыв.
В этом случае, достаточно просто заменить <i>500</i> в
выписанном выше уравнении на дополнительный
параметр (например,<i> b<sub>3</sub></i>).</p>

<p><em><strong>Регрессия с точками разрыва.</strong></em>
Выписанное выше уравнение можно легко
преобразовать к регрессии с точками разрыва, т.е.
добавить скачкообразные изменения в некоторых
точках кривой. Например, предположим, что после
запуска устаревших станков, себестоимость
“подпрыгнула” до более высокого уровня и затем
продолжила медленно уменьшаться при увеличении
объема производства. В этом случае, достаточно
просто добавить (<i>b<sub>3</sub></i>), тогда: </p>

<p><font color="blue">y = (b<sub>0</sub> + b<sub>1</sub>*x)*(x <img src="../graphics/lteblue.gif" align="absmiddle" WIDTH="12" HEIGHT="16"> 500) + (b<sub>3</sub> + b<sub>2</sub>*x)*(x
&gt; 500) </font></p>

<p><em><strong>Сравнение групп.</strong></em> Описанный здесь
метод для оценивания различных регрессионных
уравнений в разных областях значений
независимых переменных может также быть
использован для распознавания принадлежности
элементов различным группам. Например, пусть в
рассмотренном выше примере имеется три
различных завода. Для простоты изложения
“забудем” пока про возможные точки разрыва.
Если сгруппировать переменные по принадлежности
к соответствующему заводу, присвоив <a href="../glossary/gloss_g.html%20#Grouping Variable">группирующей
переменной</a> значения <i>1,2</i> и <i>3</i>,
соответственно, мы сможем одновременно записать
три различных регрессионных уравнения: </p>

<p><font color="blue">y = (x<sub>p</sub>=1)*(b<sub>10</sub> + b<sub>11</sub>*x) + (x<sub>p</sub>=2)*(b<sub>20</sub>
+ b<sub>21</sub>*x) + (x<sub>p</sub>=3)*(b<sub>30</sub> + b<sub>31</sub>*x) </font></p>

<p>В этом уравнении, <font color="blue"><i>x<sub>p</sub></i></font>
обозначает <a href="../glossary/gloss_g.html%20#Grouping Variable">группирующую
переменную</a>, содержащую коды, определяющие
завод, <font color="blue"><i>b<sub>10</sub></i></font>, <font color="blue"><i>b<sub>20</sub></i></font>
и <font color="blue"><i>b<sub>30</sub></i></font> соответствуют
свободным членам, а <font color="blue"><i>b<sub>11</sub></i></font>, <font color="blue"><i>b<sub>21</sub></i></font> и <font color="blue"><i>b<sub>31</sub></i></font>
определяют угловые коэффициенты графика
себестоимости (коэффициенты регрессии) для
каждого завода. Вы можете сравнить правдоподобие
этой и обычной регрессионной модели (без
рассмотрения различных заводов) для того, чтобы
определить более подходящую. </p>

<table ALIGN="RIGHT">
  <tr>
    <td><font SIZE="1"><a HREF="stnonlin.html#index">В начало</a></font> </td>
  </tr>
</table>

<p><br CLEAR="RIGHT">
&nbsp;<a NAME="nonlinear"></a> </p>

<p><font SIZE="4" COLOR="navy">Методы нелинейного оценивания</font>

<ul>
  <li><a HREF="stnonlin.html#nleast">Метод наименьших квадратов</a> </li>
  <li><a HREF="stnonlin.html#nloss">Функция потерь</a> </li>
  <li><a HREF="stnonlin.html#nweighted">Метод взвешенных наименьших
    квадратов</a> </li>
  <li><a HREF="stnonlin.html#nmaximum">Метод максимума
    правдоподобия</a> </li>
  <li><a HREF="stnonlin.html#n2">Максимум правдоподобия и
    логит/пробит модели</a> </li>
  <li><a HREF="stnonlin.html#nfunction">Алгоритмы минимизации
    функций</a> </li>
  <li><a HREF="stnonlin.html#nstart">Начальные значения, размеры
    шагов и критерий сходимости</a> </li>
  <li><a HREF="stnonlin.html#npenalty">Штрафные функции, ограничение
    параметров</a> </li>
  <li><a HREF="stnonlin.html#nlocal">Локальные минимумы</a> </li>
  <li><a HREF="stnonlin.html#nquasi">Квази-ньютоновский метод</a> </li>
  <li><a HREF="stnonlin.html#nsimplex">Симплекс-метод</a> </li>
  <li><a HREF="stnonlin.html#nhooke">Метод Хука-Дживиса</a> </li>
  <li><a HREF="stnonlin.html#nrosenbrock">Метод Розенброка</a> </li>
  <li><a HREF="stnonlin.html#nhessian">Матрица Гессе и стандартные
    ошибки</a> </li>
</ul>

<p>&nbsp;<a NAME="nleast"></a></p>

<p><strong>Метод наименьших квадратов. </strong>Некоторые
более общие типы регрессионных моделей
рассмотрены в разделе <a href="stnonlin.html#common"><i>Основные
типы нелинейных моделей</i></a>. После выбора модели
возникает вопрос: каким образом можно оценить
эти модели? Если вы знакомы с методами линейной
регрессии (описанными в разделе <a href="stmulreg.html"><i>Множественная
регрессия</i></a>) или дисперсионного анализа
(описанными в разделе <a href="stanman.html"><i>Дисперсионный
анализ</i></a>), то вы знаете, что все эти методы
используют оценивание по <i>методу наименьших
квадратов. </i>Основной смысл этого метода
заключается в минимизации суммы квадратов
отклонений наблюдаемых значений зависимой
переменной от значений, предсказанных моделью.
(Термин <i>наименьшие квадраты </i>впервые был
использован в работе Лежандра - Legendre, 1805.)<br>
<a NAME="nloss"></a><br>
<strong>Функция потерь. </strong>В стандартной
множественной регрессии оценивание
коэффициентов регрессии происходит “подбором”
коэффициентов, минимизирующих дисперсию
остатков (сумму квадратов остатков). Любые
отклонения наблюдаемых величин от предсказанных
означают некоторые <i>потери</i> в точности
предсказаний, например, из-за случайного шума
(ошибок). Поэтому можно сказать, что цель метода
наименьших квадратов заключается в минимизации <i>функции
потерь</i>. В этом случае, функция потерь
определяется как сумма квадратов отклонений от
предсказанных значений (термин функция потерь
был впервые использован в работе Вальда - Wald, 1939).
Когда эта функция достигает минимума, вы
получаете те же оценки для параметров
(свободного члена, коэффициентов регрессии), как,
если бы мы использовали <a href="stmulreg.html"><i>Множественную
регрессию</i></a>. Полученные оценки называются <i>оценками
по методу наименьших квадратов</i>. </p>

<p>Продолжая в том же духе, можно рассмотреть
другие функции потерь. Например, при минимизации
функции потерь, почему бы вместо суммы <i>квадратов</i>
отклонений не рассмотреть сумму <i>модулей </i>отклонений?
В самом деле, иногда это бывает полезно для
уменьшения влияния выбросов. Влияние,
оказываемое крупными остатками на всю сумму, <i>существенно</i>
увеличивается при их возведении в квадрат.
Однако если вместо суммы квадратов взять сумму
модулей выбросов, влияние остатков на
результирующую регрессионную кривую
существенно уменьшится.</p>

<p>Существуют несколько методов, которые могут
быть использованы для минимизации различных
видов функций потерь. Для получения
дополнительной информации смотрите: 

<ul>
  <li><a HREF="stnonlin.html#nleast">Метод наименьших квадратов</a> </li>
  <li><a HREF="stnonlin.html#nloss">Функция потерь</a> </li>
  <li><a HREF="stnonlin.html#nweighted">Метод взвешенных наименьших
    квадратов</a> </li>
  <li><a HREF="stnonlin.html#nmaximum">Метод максимума
    правдоподобия</a> </li>
  <li><a HREF="stnonlin.html#n2">Максимум правдоподобия и
    логит/пробит модели</a> </li>
  <li><a HREF="stnonlin.html#nfunction">Алгоритмы минимизации
    функций</a> </li>
  <li><a HREF="stnonlin.html#nstart">Начальные значения, размеры
    шагов и критерий сходимости</a> </li>
  <li><a HREF="stnonlin.html#npenalty">Штрафные функции, ограничение
    параметров</a> </li>
  <li><a HREF="stnonlin.html#nlocal">Локальные минимумы</a> </li>
  <li><a HREF="stnonlin.html#nquasi">Квази-ньютоновский метод</a> </li>
  <li><a HREF="stnonlin.html#nsimplex">Симплекс-метод</a> </li>
  <li><a HREF="stnonlin.html#nhooke">Метод Хука-Дживиса</a> </li>
  <li><a HREF="stnonlin.html#nrosenbrock">Метод Розенброка</a> </li>
  <li><a HREF="stnonlin.html#nhessian">Матрица Гессе и стандартные
    ошибки</a> </li>
</ul>

<p><a NAME="nweighted"></a></p>

<p><strong>Метод взвешенных наименьших квадратов.</strong>
Третьим по распространенности методом, в
дополнение к методу наименьших квадратов и
использованию для оценивания суммы модулей
отклонений (см. выше), является метод взвешенных
наименьших квадратов. Обычный метод наименьших
квадратов предполагает, что разброс <a href="../glossary/gloss_o.html#Residual">остатков</a> одинаковый при
всех значениях независимых переменных. Иными
словами, предполагается, что дисперсия ошибки
при всех измерениях одинакова. Часто, это
предположение не является реалистичным. В
частности, отклонения от него встречаются в
бизнесе, экономике, приложениях в биологии
(отметим, что оценки параметров по методу
взвешенных наименьших квадратов могут быть
также получены с помощью модуля <i>Множественная
регрессия</i>).</p>

<p>Например, вы хотите изучить связь между
проектной стоимостью постройки здания и суммой
реально потраченных средств. Это может оказаться
полезным для получения оценки ожидаемых
перерасходов. В этом случае разумно
предположить, что абсолютная величина
перерасходов (выраженная в долларах)
пропорциональна стоимости проекта. Поэтому, для
подбора <a href="stnonlin.html#index">линейной регрессионной
модели</a> следует использовать метод взвешенных
наименьших квадратов. Функция потерь может быть,
например, такой (см. книгу Neter, Wasserman, and Kutner, 1985,
стр.168): </p>

<p><font color="blue">Потери = (наблюд.-предск.)<sup>2</sup> * (1/x<sup>2</sup>)
</font></p>

<p>В этом уравнении первая часть функции потерь
означает стандартную функцию потерь для метода
наименьших квадратов (наблюдаемые минус
предсказанные в квадрате; т.е., квадрат <a href="../glossary/gloss_o.html#Residual">остатков</a>), а вторая равна
“весу” этой потери в каждом конкретном случае -
единица деленная на квадрат независимой
переменной (<font color="blue"><i>x</i></font>) для каждого
наблюдения. В ситуации реального оценивания,
программа просуммирует значения функции потерь
по всем наблюдениям (например, конструкторским
проектам), как описано выше и подберет параметры,
минимизирующие сумму. Возвращаясь к
рассмотренному примеру, чем больше проект (<font color="blue"><i>x</i></font>), тем меньше для нас значит одна и
та же ошибка в предсказании его стоимости. Этот
метод дает более устойчивые оценки для
параметров регрессии (более подробно, см. Neter,
Wasserman, and Kutner, 1985). <br>
<a NAME="nmaximum"></a><br>
<strong>Метод максимума правдоподобия.</strong>
Альтернативой использования метода наименьших
квадратов (см выше) является поиск максимума
функции <i>правдоподобия</i> или <i>ее логарифма.</i>
Эквивалентным способом является минимизация <i>логарифма
функции правдоподобия </i>со знаком минус (термин <i>максимум
правдоподобия </i>впервые был использован в
работе Фишера - Fisher, 1922a). В общем виде, функцию
правдоподобия определяется так: </p>

<p><font color="blue">L = F(Y,Модель) = <img src="../graphics/bigpiblu.gif" align="absmiddle" WIDTH="20" HEIGHT="23"><sub>i</sub><sup>n</sup><sub>= 1</sub> {p [y<sub>i</sub>,
Параметры модели(x<sub>i</sub>)]} </font></p>

<p>Теоретически, вы можете вычислить вероятность
принятия зависимой переменной определенных
значений(обозначенную нами <i>L</i>, от слова <i>Likelihood
- правдоподобие</i>), используя соответствующую
регрессионную модель. Воспользовавшись тем, что
все наблюдения независимы друг от друга, получим,
что наша функция правдоподобия равна
геометрической сумме (<img SRC="../graphics/bigpiblu.gif" ALIGN="ABSMIDDLE" WIDTH="20" HEIGHT="23">, для всех <font color="blue"><i>i</i> = 1</font> to <font color="blue"><i>n</i></font>) вероятностей конкретных
наблюдений (<font color="blue"><i>i</i></font>), заданных
соответствующей значению <font color="blue"><i>x</i></font>
моделью и параметрами. (Геометрическая сумма
означает, что нужно <i>перемножить</i> вероятности
по всем возможным случаям внутри скобок.) Часто
эти функции представляют в виде натурального
логарифма, в этом случае геометрическая сумма
становится обычной арифметической суммой (<img SRC="../graphics/bigpiblu.gif" ALIGN="ABSMIDDLE" WIDTH="20" HEIGHT="23">, для всех <font color="blue"><i>i</i>
= 1</font> to <font color="blue"><i>n</i></font>).</p>

<p>При выборе конкретной модели, чем больше
правдоподобие модели, тем больше вероятность,
что предсказанное значение зависимой переменной
окажется в выборке. Поэтому, чем больше
правдоподобие, тем лучше модель согласуется с
выборочными данными. Реальные вычисления для
конкретной модели могут оказаться достаточно
громоздкими, поскольку вам необходимо
“отслеживать” (вычислять) вероятности
появления различных значений зависимой
переменной <i>y</i> (выбрав модель и соответствующее
значение <i>x</i>). Оказывается, что если все
предположения для стандартной множественной
регрессии выполнены (они описаны в главе <i>Множественная
регрессия</i> руководства пользователя), то
стандартный метод наименьших квадратов (см. выше)
дает те же оценки, что и метод максимума
правдоподобия. Если предположение о постоянстве
дисперсии ошибки при всех значения независимой
переменной нарушено, то оценки по методу
максимума правдоподобия можно получить
используя метод взвешенных наименьших
квадратов. <br>
<a NAME="n2"></a><br>
<strong>Максимум правдоподобия и пробит/логит
модели. </strong>Рассмотрим функцию правдоподобия
для <a href="stnonlin.html#common">регрессионных моделей логит
и пробит</a>. Функция потерь для этих моделей
вычисляется как сумма натуральных логарифмов
логит или пробит правдоподобия <i>L<sub>1</sub></i>: </p>

<p><font color="blue">log(L<sub>1</sub>) = <img src="../graphics/sigmablu.gif" align="absmiddle" WIDTH="12" HEIGHT="19"><sub>i</sub><sup>n</sup><sub>= 1</sub> [y<sub>i</sub>*log(p<sub>i</sub>
) + (1-y<sub>i</sub> )*log(1-p<sub>i</sub> )] </font></p>

<p>где<br>
<font color="blue">log(L<sub>1</sub>)</font> натуральный логарифм
функции правдоподобия для выбранной (логит или
пробит) модели<br>
<font color="blue">y<sub>i</sub></font> <i>-<font color="blue"> i</font></i>-ое
наблюдаемое значение<br>
<font color="blue">p<sub>i</sub></font>&nbsp; вероятность появления
(предсказанная или подогнанная) (между 0 и 1)</p>

<p>Логарифм функции правдоподобия для нулевой
модели (<i>L<sub>0</sub></i>), т.е. модели, содержащей
только свободный член (и не включающей других
коэффициентов регрессии) вычисляется как: </p>

<p><font color="blue">log(L<sub>0</sub>) = n<sub>0</sub>*(log(n<sub>0</sub>/n)) + n<sub>1</sub>*(log(n<sub>1</sub>/n))
</font></p>

<p>где<br>
<font color="blue">log(L<sub>0</sub>)</font> натуральный логарифм
функции правдоподобия для нулевой (логит или
пробит) модели<br>
<font color="blue">n<sub>0</sub></font> число наблюдений со
значением 0<br>
<font color="blue">n<sub>1</sub></font> число наблюдений со
значением 1<br>
<font color="blue">n</font>&nbsp; общее число наблюдений <br>
<a NAME="nfunction"></a><br>
<strong>Алгоритмы минимизации функций</strong><b>. </b>Теперь,
после обсуждения различных регрессионных
моделей и функций потерь, используемых для их
оценки, единственное, что осталось “в тайне”,
это как находить минимумы функций потерь (т.е.
наборы параметров, наилучшим образом
соответствующие оцениваемой модели), и как
вычислять стандартные ошибки оценивания
параметров. <i>Нелинейное оценивание</i>
использует очень эффективный (<i>квази-ньютоновский</i>)
<a href="../glossary/gloss_a.html#Algorithm">алгоритм</a>, который
приближенно вычисляет вторую производную
функции потерь и использует ее при поиске
минимума (т.е., при оценке параметров по
соответствующей функции потерь). Кроме того, <i>Нелинейное
оценивание</i> предлагает несколько более общих
алгоритмов поиска минимума, использующих
различные стратегии поиска (не связанные с
вычислением вторых производных). Эти стратегии
иногда более эффективны при оценивании функций
потерь с локальными минимумами; поэтому, эти
методы часто очень полезны для нахождения <i>начальных
значений</i> с помощью <i>квази-ньютоновского</i>
метода.</p>

<p>Во всех случаях, вы можете вычислить
стандартные ошибки оценок параметров. Эти
вычисления проводятся с использованием частных
производных второго порядка по параметрам,
которые приближенно подсчитываются с
использованием метода конечных разностей. </p>

<p>Если вас интересует, не как именно происходит
минимизация функции потерь, а только то, что
такая минимизация <i>в принципе возможна</i>, вы
можете пропустить следующие разделы. Однако они
могут пригодиться, если получаемая
регрессионная модель будет плохо
согласовываться с данными. В этом случае,
итеративная процедура может не сойтись, выдавая
неожиданные (например, очень большие или очень
маленькие) оценки для параметров. </p>

<p>В следующих параграфах, мы сначала рассмотрим
некоторые вопросы, относящиеся к оптимизации без
ограничений, затем дадим краткий обзор методов
используемых в этом модуле. Более подробное
обсуждение этих методов имеется в книгах Brent (1973),
Gill and Murray (1974), Peressini, Sullivan, and Uhl (1988), и Wilde and Beightler
(1967). Более широкий обзор <a href="../glossary/gloss_a.html#Algorithm">алгоритмов</a>
можно найти в книгах Dennis and Schnabel (1983), Eason and Fenton (1974),
Fletcher (1969), Fletcher and Powell (1963), Fletcher and Reeves (1964), Hooke and Jeeves
(1961), Jacoby, Kowalik, and Pizzo (1972), и Nelder and Mead (1964). <br>
<a NAME="nstart"></a><br>
<strong>Начальные значения, размеры шагов и критерии
сходимости</strong><b>. </b>Общим моментом всех методов
оценивания является необходимость задания
пользователем некоторых начальных значений,
размера шагов и критерия сходимости алгоритма.
Все методы начинают свою работу с особого набора
предварительных оценок (<i>начальных значений</i>),
которые в дальнейшем последовательно уточняются
от итерации к итерации. При первой итерации <i>размер
шага</i> определяет, как сильно будут меняться
параметры. Наконец, <i>критерий сходимости</i>
определяет, когда итерационный процесс можно
прекратить. Например, процесс итераций можно
остановить, когда изменение функции потерь на
каждом шаге становится меньше определенной
величины. <br>
<a NAME="npenalty"></a><br>
<strong>Штрафные функции, ограничение параметров</strong><b>.
</b>Все процедуры <i>Нелинейного оценивания</i> не
имеют встроенных ограничений на область поиска.
Это означает, что программа будет изменять
значения параметров вне зависимости от
допустимости получаемых значений. Например, в
ходе логит регрессии оцениваемое значение
можете получиться равным 0.0<i>.</i> В этом случае мы
не можем вычислить логарифм (поскольку логарифм
нуля не определен). В этой ситуации программа
автоматически присваивает функции потерь <i>штрафное
значение</i>, т.е. очень большое значение. В
результате, оценивающие процедуры остаются
внутри допустимого диапазона. Однако, в
некоторых случаях, процесс оценивания
зацикливается, и в результате, мы получаем
огромное значение функции потерь. Это может
случиться, например, если, если регрессионное
уравнение включает взятие логарифма от
независимой переменной, которая в некоторых
случаях может принимать нулевое значение (в этом
случае возникают проблемы с логарифмированием).</p>

<p>Для того, чтобы определить ограничения на
область изменения параметров, следует добавить к
функции потерь некоторую штрафную функцию,
равную нулю при допустимых значениях параметра и
очень большую при недопустимых. Ниже приведен
пример определенной пользователем регрессии и
функции потерь, включающий наложение штрафа,
если хотя бы один из параметров <i>a</i> или <i>b </i>меньше
или равен нуля: </p>

<p>Оцениваемая функция: <font color="blue">v3 = a + b*v1 + (c*v2)</font><br>
Функция потерь: <font color="blue">L = (obs - pred)**2 + (a&lt;0)*100000 +
(b&lt;0)*100000</font><br>
<a NAME="nlocal"></a><br>
<strong>Локальные минимумы.</strong> Самой неприятной
проблемой при минимизации функции без
ограничений <i>являются локальные минимумы</i>.
Например, при небольшом смещении значения
параметра в любом направлении функция потерь
почти не изменяется. Однако если мы передвинем
параметр в совершенно другую область, значение
функции потерь может существенно уменьшиться. Вы
можете представлять себе такие локальные
минимумы как небольшие впадины на графике
функции потерь. Однако в большинстве
практических приложений локальные минимумы
приводят к неправдоподобно большим или
неправдоподобно малым значениям параметров с
очень большими стандартными ошибками. В этих
случаях следует задать другие начальные данные и
повторить поиск минимума еще раз. Отметим также,
что <i>симплекс</i> - метод (см. ниже) нечувствителен
к таким минимумам, поэтому, он может быть
использован для отыскания подходящих начальных
значений для сложных функций. <br>
<a NAME="nquasi"></a><br>
<strong>Квази-ньютоновский метод.</strong> Как вы,
наверное, помните, угловой коэффициент - тангенс
угла наклона графика функции в конкретной точке
равен производной этой функции (в этой точке), а
скорость его изменения в выбранной точке равна
второй производной функции в этой точке.
Квази-ньютоновский метод вычисляет значения
функции в различных точках для оценивания первой
и второй производной, используя эти данные для
определения направления изменения параметров и
минимизации функции потерь. <br>
<a NAME="nsimplex"></a><br>
<strong>Симплекс-метод.</strong> Этот алгоритм не
использует производные функции потерь. Вместо
этого, при каждой итерации функция оценивается в <i>m+1</i>
точках <i>m</i>-мерного пространства. Например, на
плоскости (т.е., при оценивании двух параметров)
программа будет вычислять значение функции
потерь в трех точках в окрестности текущего
минимума. Эти три точки определяют треугольник; в
многомерном пространстве. Получаемая фигура
называется <i>симплекс</i>. Интуитивно понятно, что
в двумерном пространстве три точки позволяют
выбрать “в каком направлении двигаться”, т.е., в
каком направлении на плоскости менять параметры
для минимизации функции. Похожие принципы
применимы в многомерном параметрическом
пространстве; т.е., <i>симплекс</i> будет постепенно
“смещаться вниз по склону”, в сторону
минимизации функции потерь; если же текущий шаг
окажется слишком большим для определения
точного направления спуска, (т.е., <i>симплекс </i>слишком
большой), процедура произведет уменьшение <i>симплекса</i>
и продолжит вычисления.</p>

<p>Дополнительное преимущество симплекс-метода в
том, что при нахождении минимума <i>симплекс</i>
снова увеличивается для проверки: не является ли
этот минимум локальным. Таким образом, <i>симплекс</i>
движется по поверхности по направлению к
минимуму функции подобно простому,
одноклеточному, организму, уменьшаясь и
увеличиваясь при обнаружении локальных
минимумов и “гребней”. <br>
<a NAME="nhooke"></a><br>
<strong>Метод Хука-Дживиса.</strong> В некотором смысле,
это простейший из всех <a href="../glossary/gloss_a.html#Algorithm">алгоритмов</a>.
При каждой итерации метод сначала определяет
схему расположения параметров, оптимизируя
текущую функцию потерь перемещением каждого
параметра по отдельности. При этом вся
комбинация параметров сдвигается на новое место.
Это новое положение в m-мерном пространстве
параметров определяется экстраполяцией вдоль
линии, соединяющей текущую базовую точку с новой
точкой. Размер шага этого процесса постоянно
меняется для попадания в оптимальную точку. Этот
метод обычно очень эффективен и его следует
использовать, если квази-ньютоновский и
симплекс-метод (см. выше) не дали
удовлетворительных оценок. <br>
<a NAME="nrosenbrock"></a><br>
<strong>Метод Розенброка.</strong> Даже если все
остальные методы не сработали, <i>метод
Розенброка </i>часто приводит к правильному
результату. Этот метод вращает пространство
параметров, располагая одну ось вдоль “гребня”
поверхности (этот метод также называется <i>метод
вращения координат</i>), при этом все другие
остаются ортогональными выбранной оси. Если
поверхность графика функции потерь имеет одну
вершину и различимые “гребни” в направлении
минимума функции потерь, этот метод приводит к
очень точным значениям параметров,
минимизирующим функцию потерь. Однако следует
отметить, что этот поисковый алгоритм
остановится преждевременно, если на область
значений параметров наложены несколько
ограничений (отражающихся в штрафном значении;
см. выше), которые пересекаются, приводя к
обрыванию “гребня”. <br>
<a NAME="nhessian"></a><br>
<strong>Матрица Гессе и стандартные ошибки.</strong>
Матрицу частных производных второго порядка
также часто называют <i>матрицей Гессе</i>.
Оказывается, что обратная к ней матрица
приблизительно равна матрице ковариаций
оцениваемых параметров. Интуитивно понятно, что <i>существует</i>
обратная зависимость между производными второго
порядка по параметрам и их стандартными
ошибками. Если изменить угловой коэффициент в
точке минимума функции и сделать минимум функции
более “резким”, то производные второго порядка
увеличатся; при этом, оценки параметров будут
практически стабильными в смысле, что параметры
в точке минимума будут легко уточняемы. Если же
производная второго порядка будет близка к нулю,
то угол наклона в точке минимума будет
практически неизменным, приводя к тому, что вы
можете двигать параметры практически в любом
направлении почти не изменяя значение функции
потерь. Поэтому стандартные ошибки параметров
будут очень большими.</p>

<p>Матрица Гессе и асимптотические стандартные
ошибки для параметров вычисляются отдельно
методом конечных разностей. Эта процедура
возвращает очень точные асимптотические
стандартные ошибки для всех методов оценивания. </p>

<table ALIGN="RIGHT">
  <tr>
    <td><font SIZE="1"><a HREF="stnonlin.html#index">В начало</a></font> </td>
  </tr>
</table>

<p><br CLEAR="RIGHT">
&nbsp;<a NAME="evaluating"></a> </p>

<p><font SIZE="4" COLOR="navy">Оценивание пригодности модели </font></p>

<p>После оценивания регрессионных параметров,
существенной стороной анализа является проверка
пригодности модели в целом. Например, если вы
определили линейную регрессионную модель, а
реальная зависимость переменных по своей
природе <a href="stnonlin.html#common">нелинейна</a>, то оценки
параметров (коэффициентов регрессии) и оценки
стандартных ошибок этих приближений могут
оказаться совершенно неудовлетворительными.
Рассмотрим некоторые методы проверки
пригодности модели. 

<ul>
  <li><a HREF="stnonlin.html#eproportion">Объясненная доля дисперсии</a>
  </li>
  <li><a HREF="stnonlin.html#egoodness">Критерий согласия хи-квадрат</a>
  </li>
  <li><a HREF="stnonlin.html#eplot">График наблюдаемых и
    предсказанных значений</a> </li>
  <li><a HREF="stnonlin.html#enormal">Нормальный и полунормальный
    график остатков</a> </li>
  <li><a HREF="stnonlin.html#eplotf">График функции подгонки</a> </li>
  <li><a HREF="stnonlin.html#evariance">Ковариационная матрица
    оценок параметров</a> </li>
</ul>

<p>&nbsp;<a NAME="eproportion"></a></p>

<p><strong>Объясненная доля дисперсии.</strong> Вне
зависимости от рассматриваемой модели, мы всегда
можем оценить полную дисперсию зависимой
переменной (полную сумму квадратов - total sum of squares,
SST), долю дисперсии, приходящейся на остатки
(сумму квадратов ошибок - error sum of squares, SSE), и долю
дисперсии относительно регрессионной модели
(сумму квадратов относительно регрессии - regression
sum of squares, SSR = SST - SSE). Отношение суммы квадратов
относительно регрессии к полной сумме квадратов
(SSR/SST) обозначается термином <i>объясненная доля
дисперсии </i>зависимой переменной (<i>y</i>) в
регрессионной модели. Таким образом, эта доля
эквивалентна значению <i>R-квадрат </i>(0 <img SRC="../graphics/lte.gif" ALIGN="ABSMIDDLE" WIDTH="11" HEIGHT="14"><i>R-квадрат</i> <img SRC="../graphics/lte.gif" ALIGN="ABSMIDDLE" WIDTH="11" HEIGHT="14">1, так называемому
квадрату смешанной корреляции (<i>коэффициенту
определенности</i>- <i>coefficient of determination</i> в
англоязычной литературе)). Даже если
распределение зависимой переменной не является
нормальным, это отношение помогает оценить,
насколько хорошо подобранная модель согласуется
с исходными данными. <br>
<a NAME="egoodness"></a><br>
<strong>Критерий согласия хи-квадрат.</strong> Для
регрессионных моделей пробит и логит, <i>Нелинейное
оценивание </i>использует оценивание по методу
максимума правдоподобия (т.е. максимизирует
функцию правдоподобия). Но оказывается, что можно
непосредственно сравнить правдоподобие <i>L<sub>0</sub></i>
нулевой модели, где все параметры наклона равны
нулю, с правдоподобием <i>L<sub>1</sub></i> подогнанной
модели. А именно, можно вычислить значение
статистики <i><a href="../glossary/gloss_r.html#Chi-square Distribution">хи-квадрат</a>
</i>для нашего отношения по формуле: </p>

<p><font color="blue">Хи-квадрат = -2 * (log(L<sub>0</sub>) - log(L<sub>1</sub>))
</font></p>

<p>Число степеней свободы для этого значения <a href="../glossary/gloss_r.html#Chi-square Distribution"><i>хи-квадрат</i></a>
равно разности числа параметров для подогнанной
и числа параметров для нулевой моделей, поэтому
число степеней свободы будет равно числу
независимых переменных в подогнанной логит или
пробит регрессии. Если <i>p</i>-уровень,
соответствующий этому значению <a href="../glossary/gloss_r.html#Chi-square Distribution"><i>хи-квадрат</i></a>,
является значимым, то вы можете сказать, что
оцениваемая модель значительно лучше
соответствует данным, чем нулевая модель, т.е.
параметры регрессии статистически значимы. <br>
<a NAME="eplot"></a><br>
<strong>График наблюдаемых и предсказанных
значений.</strong> При проведении исследований часто
полезным бывает использование <a href="../glossary/gloss_d.html#Scatterplot, 2D"><i>диаграммы рассеяния</i></a>
наблюдаемых и предсказанных значений. Если
модель хорошо соответствует данным, можно
ожидать, что точки расположатся вдоль прямой
линии, если же модель задана неправильно, то
полученная из точек на графике фигура будет мало
похожа на прямую линию. <br>
<a NAME="enormal"></a><br>
<strong>Нормальный и полунормальный графики
остатков.</strong> <i>Нормальный вероятностный график</i>
остатков показывает насколько распределение
остатков (ошибок) близко к нормальному. <br>
<a NAME="eplotf"></a><br>
<b>График функции подгонки.</b> Для моделей,
включающих две или три переменные (один или два
предиктора) полезно строить функцию подгонки с
использованием окончательных оценок параметров.
Посмотрите на пример 3М графика с двумя
предикторными переменными: </p>

<p><img BORDER="0" SRC="../popups/popup10.gif" alt="3М график" WIDTH="306" HEIGHT="218"> </p>

<p>Этот тип графика предоставляет хорошую
возможность проверить, подходит ли модель к
данным или нет, и где расположены явные выбросы. <br>
<a NAME="evariance"></a><br>
<strong>Ковариационная матрица оценок параметров.</strong>
Если подобранная модель сильно отличается от
реальной, или процедура оценивания “застряла”
на локальном минимуме, ошибки для оценок
параметров могут получиться очень большими. Это
означает, что как бы мы не меняли конечные
значения параметров, полученная в результате
функция потерь практически не изменится. Кроме
того, параметры могут оказаться сильно
коррелированными. Это говорит о том, что
некоторые параметры излишни. Поэтому изменение
функции потерь при изменении оценивающим
алгоритмом полученного значения одного
параметра может быть практически
скомпенсировано перемещением другого параметра
и изучение совместного влияния этих параметров
на функцию потерь оказывается излишним. </p>

<table ALIGN="RIGHT">
  <tr>
    <td><font SIZE="1"><a HREF="stnonlin.html#index">В начало</a></font> </td>
  </tr>
</table>

<p><br CLEAR="RIGHT">
<br>
<br>
</p>

<hr SIZE="1">

<p align="center"><br>
<img SRC="../stathoms.jpg" ALIGN="LEFT" WIDTH="151" HEIGHT="47"> <br CLEAR="ALL">
<font SIZE="1">(c) Copyright StatSoft, Inc., 1984-2001<br>
STATISTICA является торговой маркой StatSoft, Inc. </font></p>

<hr SIZE="1">
</body>
</html>
